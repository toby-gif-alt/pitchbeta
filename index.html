<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üéµ Absolute Pitch Trainer</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root { --bg:#0f172a; --card:#1e293b; --muted:#334155; --good:#16a34a; --bad:#dc2626; --text:#e5e7eb; --accent:#fbbf24; --neutral:#94a3b8; --muted2:#2a3a54; }
  *{box-sizing:border-box}
  body{font-family:'Fredoka',sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px}
  .card{max-width:1060px;margin:auto;background:var(--card);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.15)}
  h1,h2,h3{margin:0 0 8px}
  button{margin:6px;padding:10px 16px;border-radius:12px;border:none;cursor:pointer;font-size:14px;background:var(--muted);color:var(--text);transition:transform .06s ease, filter .12s ease, background .12s ease, border-color .12s ease}
  button:hover{transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  button:disabled{opacity:.55; cursor:not-allowed; background:var(--muted2); border:1.5px dashed var(--muted)}
  input,select{padding:10px 12px;border-radius:12px;border:1px solid var(--muted);background:var(--card);color:var(--text)}
  select{appearance:none;background-image:linear-gradient(45deg,transparent 50%,var(--text) 50%),linear-gradient(135deg,var(--text) 50%,transparent 50%),linear-gradient(to right,transparent,transparent);
         background-position:calc(100% - 20px) 16px, calc(100% - 14px) 16px, 100% 0; background-size:6px 6px,6px 6px, 2.5em 2.5em; background-repeat:no-repeat}
  label{opacity:.9}
  .screen{display:none}
  .pill{display:inline-flex;align-items:center;background:var(--muted);padding:8px 12px;border-radius:16px;font-size:13px;margin:6px;white-space:nowrap}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .note-pad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
  .note{min-height:64px;font-size:18px;border-radius:14px}
  .note.inert{background:var(--muted2) !important; border:1.5px dashed var(--muted); cursor:not-allowed}
  .wide{grid-column:1 / -1}
  #barStatus{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  #barControls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  #feedbackOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;pointer-events:none}
  #feedbackBox{min-width:240px;text-align:center;padding:16px 18px;border-radius:14px;font-weight:700;font-size:20px;box-shadow:0 20px 60px rgba(0,0,0,.35);transform:scale(.9);opacity:0;transition:transform .15s,opacity .15s}
  #feedbackOverlay.show #feedbackBox{transform:scale(1.05);opacity:1}
  #shepardOverlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:60}
  #shepardBox{background:var(--card);border:1px solid var(--muted);padding:20px 24px;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);text-align:center}
  #bootError{display:none;position:fixed;left:12px;right:12px;bottom:12px;background:var(--bad);color:var(--text);padding:10px 12px;border-radius:10px;box-shadow:0 4px 18px rgba(0,0,0,.35);z-index:9999;font:13px/1.35 system-ui,sans-serif;white-space:pre-wrap}

  /* Flappy */
  #flappyModal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:50}
  #flappyCanvas{background:var(--card);width:320px;height:480px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);cursor:pointer;-webkit-tap-highlight-color:transparent;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;outline:none}

  input[type="range"].disabled{opacity:.4;filter:grayscale(1)}

  /* Suggestion banner */
  #suggestBanner{display:none;margin:8px 0 4px;padding:10px 12px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted);color:var(--text);align-items:center;gap:10px}
  #suggestBanner button{margin:0 4px;padding:8px 12px;border-radius:10px;font-size:13px}
  #btnRestartSet{background:var(--good)}
  #btnDismissSuggest{background:var(--muted)}

  /* Modals */
  #strictModal,#welcomeModal,#newPitchModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,.55);pointer-events:auto}
  #strictBox,#welcomeBox,#newPitchBox{width:min(760px,92vw);background:var(--card);border:1px solid var(--muted);border-radius:16px;padding:18px 20px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
  #strictBox h3,#welcomeBox h2,#newPitchBox h2{margin:0 0 8px}
  #strictBtns,#welcomeBtns,#newPitchBtns{display:flex;gap:10px;justify-content:flex-end;margin-top:12px}
  #btnStrictResume{background:var(--good)}
  #btnStrictMenu{background:var(--muted)}
  #welcomeBtns button{background:var(--muted)}
  #btnHearNewPitch{background:var(--accent);color:var(--bg);font-weight:700}
  #btnContinueTraining{background:var(--good)}
  #tutorialWrap{background:var(--card);border:1px solid var(--muted);border-radius:12px;padding:12px;margin:10px 0}

  /* Progress (charts) */
  #progressCard{margin-top:14px}
  #progressControls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  #progressLegend{display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9}
  .legendDot{width:12px;height:12px;border-radius:50%}

  /* Tutorial pager */
  .tPage{display:none}
  .tPage.active{display:block}
  #tutorialNav{display:flex;gap:8px;justify-content:space-between;margin-top:10px}
  #tBack{visibility:hidden}

  /* Special exercise strip */
  #specialBar{display:none;align-items:center;justify-content:space-between;background:var(--muted2);border:1px solid var(--muted);color:var(--text);padding:8px 12px;border-radius:10px;margin-bottom:10px}

  /* Scope picker CTA styling */
  .scopeWrap{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted)}
  .scopeWrap:hover{box-shadow:0 0 0 2px rgba(251,191,36,.25) inset}
  .scopeSelect{background:var(--card);border:1.5px solid var(--muted);border-radius:10px;padding:8px 36px 8px 10px;font-weight:600}
  .scopeSelect:focus{outline:none; box-shadow:0 0 0 2px var(--accent)}
  .scopeBtn{background:var(--accent);color:var(--bg);font-weight:700}
</style>
</head>
<body>
  <!-- Start -->
  <div class="card screen" id="startScreen">
    <h1>Welcome!</h1>
    <p>Enter your name to begin:</p>
    <input id="userNameInput" placeholder="Your name" />
    <button id="startBtn">Start ‚ñ∂</button>
  </div>

  <!-- Welcome / Tutorial -->
  <div id="welcomeModal" aria-modal="true" role="dialog">
    <div id="welcomeBox" class="card">
      <h2>üìò How this program works</h2>
      <div id="tutorialWrap">
        <div class="tPage active" id="tPage1">
          <h3>üéØ Goal</h3>
          <p>Learn to recognize the <strong>12 pitches</strong> by ear (C, C#/Db, D, D#/Eb, E, F, F#/Gb, G, G#/Ab, A, A#/Bb, B). You start with a single pitch and add more.</p>
          <ul>
            <li><strong>Unlock order (study):</strong> alternate semitones around F: <strong>F, E, F#/Gb, Eb, G, D, Ab, Db, A, C, Bb, B</strong>.</li>
            <li>Training uses <strong>sets</strong> (how many pitches you‚Äôre learning) and <strong>blocks</strong> (24 per set).</li>
            <li><strong>RT (reaction time)</strong> = max time to answer; it increases slightly with set size.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage2">
          <h3>‚è± Daily session</h3>
          <ul>
            <li>Train for <strong>30 minutes</strong> (timer runs only while actively training).</li>
            <li>Menus, Flappy, and the 20-s <strong>Shepard tone</strong> don‚Äôt count.</li>
            <li>Blocks <strong>1‚Äì20</strong> with feedback; <strong>21‚Äì24</strong> are tests (no feedback).</li>
          </ul>
        </div>
        <div class="tPage" id="tPage3">
          <h3>üéπ Octaves (per study)</h3>
          <ul>
            <li>Training tones span <strong>three octaves</strong> and are randomized within blocks.</li>
            <li><strong>Piano/Sine:</strong> C4‚ÄìB6 ‚Ä¢ <strong>Guitar:</strong> C3‚ÄìB5</li>
            <li>This encourages learning the <em>chroma</em> (pitch class), not just pitch height.</li>
            <li>Tone length: <strong>800 ms</strong>.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage4">
          <h3>üß™ Special exercises (Block 15)</h3>
          <ul>
            <li>When you‚Äôre learning <strong>‚â• 5 pitches</strong>, Block 15 becomes specials:</li>
            <li><strong>Exercise A</strong>: 12 trials with feedback ‚Äî <em>Target (pitch)</em> vs <em>Other (¬±2 semitones)</em>.</li>
            <li><strong>Exercise B</strong>: 22 trials without feedback ‚Äî same task.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage5">
          <h3>üê§ Flappy breaks</h3>
          <ul>
            <li>Reward mini-game; every flap plays a random pitch.</li>
            <li>Timer stays paused until you press <strong>Play</strong> again.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage6">
          <h3>üìä Assessment Test</h3>
          <ul>
            <li><strong>Purpose:</strong> Measure your absolute pitch ability with 20 random pitches across different audio types.</li>
            <li><strong>When to take:</strong> At the start and end of your 8-week program, or weekly to track progress.</li>
            <li><strong>Features:</strong> No feedback during test, results saved to tracker for progress monitoring.</li>
            <li>View your assessment history and progress in the <strong>Track</strong> section from the main menu.</li>
          </ul>
        </div>
      </div>
      <div id="welcomeBtns">
        <div id="tutorialNav" style="width:100%">
          <button id="tBack">‚óÄ Back</button>
          <div style="flex:1"></div>
          <button id="tNext">Next ‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Menu -->
  <div class="card screen" id="menuScreen">
    <h1 id="greeting">Absolute Pitch Trainer</h1>
    <div class="row">
      <span class="pill" id="capInfo">Left: 30:00</span>
      <span class="pill" id="weekPill">This week: 0 hrs 0 mins</span>
      <span class="pill" id="lockoutPill" style="display:none">üîí Locked</span>
    </div>
    <div class="row">
      <button id="menuStart">‚ñ∂ Start Training</button>
      <button id="startAssessment">üìä Assessment Test</button>
      <button id="viewTracker">üìä Track</button>
      <button id="playFlappy">üê§ Flappy (lockout only)</button>
      <button id="resetLockout">‚ö° Reset lockout/timer</button>
      <button id="menuReset">‚ü≤ Reset (factory)</button>
    </div>

    <!-- Scope looks obviously changeable now -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Current scope:</span>
        <select id="setSizeSelect" class="scopeSelect"></select>
        <button id="applySetBtn" class="scopeBtn">Change‚Ä¶</button>
      </div>
    </div>
    
    <!-- Audio Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Audio type:</span>
        <select id="audioTypeSelect" class="scopeSelect">
          <option value="piano">Piano (C4-B6)</option>
          <option value="sine">Sine Wave (C4-B6)</option>
          <option value="guitar">Guitar (C3-B5)</option>
        </select>
        <button id="applyAudioBtn" class="scopeBtn">Change</button>
      </div>
    </div>
    
    <!-- Theme Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Theme:</span>
        <select id="themeSelect" class="scopeSelect">
          <option value="default">Dark Ocean</option>
          <option value="beach">Beach Sunset</option>
          <option value="jungle">Jungle Canopy</option>
          <option value="sky">Cloud Nine</option>
          <option value="desert">Desert Oasis</option>
          <option value="neon">Neon Nights</option>
          <option value="forest">Mystic Forest</option>
        </select>
        <button id="applyThemeBtn" class="scopeBtn">Change</button>
      </div>
    </div>

    <!-- Flappy Settings -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Flappy sound:</span>
        <select id="flappySoundSelect" class="scopeSelect">
          <option value="enabled">Enabled</option>
          <option value="muted">Muted</option>
        </select>
        <button id="applyFlappySoundBtn" class="scopeBtn">Change</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="card" id="progressCard">
      <h3>üìà Progress</h3>
      <div id="progressControls">
        <label for="pitchSelect">Pitch:</label>
        <select id="pitchSelect" style="padding-right:28px"></select>
        <label for="granularitySelect">View:</label>
        <select id="granularitySelect" style="padding-right:28px">
          <option value="WEEKLY" selected>Weekly (Day 1 ‚Üí 7)</option>
          <option value="OVERALL">Overall (Week 1 ‚Üí 8)</option>
        </select>
        <div id="progressLegend">
          <span class="legendDot" style="background:var(--good)"></span> <span id="legGood">Correct %</span>
          <span class="legendDot" style="background:var(--bad);margin-left:12px)"></span> <span id="legBad">Incorrect %</span>
          <span class="legendDot" style="background:var(--neutral);margin-left:12px)"></span> <span id="legTrend">No-trial day</span>
        </div>
      </div>
      <canvas id="progressCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
  </div>

  <!-- Assessment Tracker Screen -->
  <div class="card screen" id="trackerScreen">
    <h1>üìä Assessment Tracker</h1>
    <div class="row">
      <span class="pill" id="trackerCount">0 assessments</span>
      <button id="btnBackMenuTracker">‚Ü© Menu</button>
    </div>
    
    <div style="margin:20px 0">
      <div id="trackerLegend" style="display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9;margin-bottom:12px">
        <span class="legendDot" style="background:var(--good)"></span> <span>Exact Correct %</span>
        <span class="legendDot" style="background:var(--accent);margin-left:12px"></span> <span>Within ¬±1 semitone %</span>
      </div>
      <canvas id="trackerCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
    
    <div id="trackerDetails" style="margin-top:16px">
      <h3>Assessment History</h3>
      <div id="trackerHistory" style="max-height:200px;overflow-y:auto;border:1px solid var(--muted);border-radius:12px;padding:12px;background:var(--card)">
        <p style="opacity:0.7;text-align:center">No assessments completed yet</p>
      </div>
    </div>
  </div>

  <!-- Trainer -->
  <div class="card screen" id="trainerScreen">
    <div id="specialBar" class="row">
      <span id="specialText">Special Exercise</span>
      <span class="pill" id="specialCount">0 / 0</span>
    </div>

    <div id="suggestBanner" class="row">
      <span>Struggling in the test phase. Restart this pitch set?</span>
      <div style="margin-left:auto"></div>
      <button id="btnRestartSet">Restart set</button>
      <button id="btnDismissSuggest">Dismiss</button>
    </div>

    <div id="barStatus">
      <span class="pill" id="promptPill">Press Play to start</span>
      <span class="pill" id="setInfo">Set 1 / 12</span>
      <span class="pill" id="blockInfo">Block 1 / 24</span>
      <span class="pill" id="accInfo">Acc 0% (req 20%)</span>
      <span class="pill" id="autoInfo">Auto-next: Off</span>
      <span class="pill" id="delayInfo">RT limit: 1183ms ‚Ä¢ Delay: 1000ms</span>
      <span class="pill" id="blockTimeInfo">TimeBlock 1/5 00:00/06:00</span>
      <span class="pill" id="timerInfo">Time left: 30:00</span>
      <span class="pill" id="oobStatusPill">OOB 15%</span>
    </div>
    <div id="barControls">
      <button id="btnPlay">‚ñ∂ Play</button>
      <button id="btnPause">‚è∏ Pause</button>
      <button id="btnToggleAuto">‚èØ Toggle Auto-next</button>
      <input id="delaySlider" type="range" min="0" max="2000" step="50" value="1000" style="width:220px">
      <button id="btnBackMenu">‚Ü© Menu</button>
    </div>

    <!-- Note pad -->
    <div class="note-pad" id="notePad"></div>
    <div class="note-pad" style="margin-top:6px">
      <button class="note wide" id="btnOOB" type="button">Out of Bounds</button>
    </div>

    <!-- Binary pad for specials -->
    <div class="note-pad" id="binaryPad" style="display:none">
      <button class="note" id="btnTarget" type="button">Target</button>
      <button class="note" id="btnOther" type="button">Other (OOB)</button>
    </div>

    <p style="opacity:.75;margin-top:8px">800 ms tone ‚Ä¢ RT limit adapts with set size ‚Ä¢ 24 blocks per set ‚Ä¢ Octaves randomized (C4‚ÄìB6)</p>
  </div>

  <!-- Assessment Screen -->
  <div id="assessmentScreen" class="screen">
    <div class="card">
      <h2>üìä Assessment Test</h2>
      <div class="row">
        <span class="pill" id="assessmentProgress">Trial 0 / 20</span>
        <button id="btnBackMenuAssessment">‚Ü© Menu</button>
      </div>
      
      <div style="text-align:center;margin:20px 0">
        <span id="assessmentPrompt" class="pill">Press Start to begin assessment</span>
        <div style="margin-top:12px">
          <button id="btnStartAssessment">‚ñ∂ Start Assessment</button>
        </div>
      </div>
      
      <!-- Note pad for assessment -->
      <div class="note-pad" id="assessmentPad"></div>
      
      <div id="assessmentResults" style="display:none;text-align:center;margin-top:20px">
        <h3>Assessment Results</h3>
        <div id="assessmentStats" style="margin:16px 0"></div>
        <button id="btnRetryAssessment">Try Again</button>
        <button id="btnBackMenuFromResults">Back to Menu</button>
      </div>
      
      <p style="opacity:.75;margin-top:8px">20 random pitches using random audio types ‚Ä¢ No feedback during test</p>
    </div>
  </div>

  <!-- Feedback -->
  <div id="feedbackOverlay"><div id="feedbackBox"></div></div>

  <!-- Shepard overlay -->
  <div id="shepardOverlay">
    <div id="shepardBox">
      <h3>üîá Memory reset</h3>
      <p>Playing a 20-second Shepard tone‚Ä¶</p>
      <p id="shepardCountdown">20</p>
    </div>
  </div>

  <!-- Flappy -->
  <div id="flappyModal">
    <div class="card" style="text-align:center">
      <div style="position: relative;">
        <h3>üê§ Flappy Break</h3>
        <!-- E) Sound toggle checkbox at top-right -->
        <label id="flappySoundToggleLabel" style="position: absolute; top: 0; right: 0; display: flex; align-items: center; font-size: 13px; opacity: 0.9; cursor: pointer;">
          <input type="checkbox" id="flappySoundCheckbox" style="margin-right: 6px;">
          Mute Flappy sound
        </label>
      </div>
      <canvas id="flappyCanvas" width="320" height="480"></canvas>
      <div style="margin-top:8px">
        <button id="flappySoundToggle" style="margin-right:8px">üîä Sound On</button>
        <button id="flappyClose">Close</button>
      </div>
      <p id="flappyScore">Score: 0 ‚Ä¢ Best: 0</p>
      <p style="opacity:.8;font-size:12px">Tap/click (or Space) to flap. First tap starts ‚Äî each flap plays a random pitch.</p>
    </div>
  </div>

  <!-- Assessment Warning Modal -->
  <div id="assessmentWarningModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Test</h2>
      <p><strong>Timing Recommendations:</strong></p>
      <ul style="text-align:left;margin:16px 0">
        <li>Take this test at the <strong>start of your 8-week training program</strong></li>
        <li>Take it again at the <strong>end of the 8 weeks</strong> to track improvement</li>
        <li>Optionally take it <strong>weekly</strong> to monitor progress</li>
      </ul>
      <p style="opacity:0.8">This test uses 20 random pitches across different audio types without feedback to assess your current absolute pitch ability.</p>
      <div style="margin-top:20px">
        <button id="btnProceedAssessment" style="background:var(--good);margin:0 8px">Continue to Test</button>
        <button id="btnCancelAssessment" style="background:var(--muted);margin:0 8px">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Assessment Results Modal -->
  <div id="assessmentResultsModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Complete!</h2>
      <div id="modalAssessmentStats" style="margin:20px 0;font-size:18px"></div>
      <p style="opacity:0.8;margin:16px 0">Your results have been saved to the tracker.</p>
      <div style="margin-top:20px">
        <button id="btnRetakeAssessmentModal" style="background:var(--good);margin:0 8px">Try Again</button>
        <button id="btnBackMenuModal" style="background:var(--muted);margin:0 8px">Back to Menu</button>
      </div>
    </div>
  </div>

  <!-- Strict session modal -->
  <div id="strictModal" aria-modal="true" role="dialog">
    <div id="strictBox" class="card">
      <h3>‚ö†Ô∏è Don‚Äôt break your session</h3>
      <p>Training is meant to be one strict 30-minute session without interruption. Please finish, then wait until tomorrow.</p>
      <div id="strictBtns">
        <button id="btnStrictResume">Resume Training</button>
        <button id="btnStrictMenu">Go to Menu</button>
      </div>
    </div>
  </div>

  <!-- New Pitch Introduction Modal -->
  <div id="newPitchModal" aria-modal="true" role="dialog">
    <div id="newPitchBox" class="card">
      <h2>üéâ Well Done!</h2>
      <p id="newPitchMessage">Now you are learning: <strong id="newPitchName">F</strong></p>
      <div id="newPitchBtns">
        <button id="btnHearNewPitch">üîä Hear It</button>
        <button id="btnContinueTraining">Continue</button>
      </div>
    </div>
  </div>

  <div id="bootError"></div>

<script>
/* ------------------ CONSTANTS ------------------ */
const AUDIO_PIANO='./audio';
const AUDIO_GUITAR='./Guitar';
const AUDIO_TYPES = {PIANO: 'piano', SINE: 'sine', GUITAR: 'guitar'};

// Theme definitions
const THEMES = {
  default: {
    name: 'Dark Ocean',
    bg: '#0f172a',
    card: '#1e293b', 
    muted: '#334155',
    muted2: '#2a3a54',
    text: '#e5e7eb',
    good: '#16a34a',
    bad: '#dc2626',
    accent: '#fbbf24',
    neutral: '#94a3b8'
  },
  beach: {
    name: 'Beach Sunset',
    bg: '#0f2027',
    card: '#2c5aa0',
    muted: '#44749d',
    muted2: '#5a86ba',
    text: '#fff8dc',
    good: '#ff7f50',
    bad: '#dc143c',
    accent: '#ffa500',
    neutral: '#87ceeb'
  },
  jungle: {
    name: 'Jungle Canopy', 
    bg: '#1a2f1a',
    card: '#2d4a2d',
    muted: '#456545',
    muted2: '#3a5a3a',
    text: '#e8f5e8',
    good: '#32cd32',
    bad: '#cd5c5c',
    accent: '#adff2f',
    neutral: '#9acd32'
  },
  sky: {
    name: 'Cloud Nine',
    bg: '#e6f2ff',
    card: '#ffffff',
    muted: '#b8d4f0',
    muted2: '#a3c9ea',
    text: '#1e3a8a',
    good: '#10b981',
    bad: '#ef4444',
    accent: '#3b82f6',
    neutral: '#6b7280'
  },
  desert: {
    name: 'Desert Oasis',
    bg: '#2d1810',
    card: '#8b4513',
    muted: '#cd853f',
    muted2: '#a0522d',
    text: '#faebd7',
    good: '#daa520',
    bad: '#b22222',
    accent: '#ff8c00',
    neutral: '#d2b48c'
  },
  neon: {
    name: 'Neon Nights',
    bg: '#0a0a0f',
    card: '#1a1a2e',
    muted: '#16213e',
    muted2: '#0f172a',
    text: '#00ffff',
    good: '#00ff00',
    bad: '#ff1493',
    accent: '#ff00ff',
    neutral: '#9370db'
  },
  forest: {
    name: 'Mystic Forest',
    bg: '#0d1421',
    card: '#1e3a3a',
    muted: '#2f5a5a',
    muted2: '#1a3030',
    text: '#f0fff0',
    good: '#228b22',
    bad: '#dc143c',
    accent: '#ffd700',
    neutral: '#8fbc8f'
  }
};
const PC=["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
const PC_LABEL={ C:"C", Db:"C#/Db", D:"D", Eb:"D#/Eb", E:"E", F:"F", Gb:"F#/Gb", G:"G", Ab:"G#/Ab", A:"A", Bb:"A#/Bb", B:"B" };
const UNLOCK_ORDER = ["F","E","Gb","Eb","G","D","Ab","Db","A","C","Bb","B"];

const LEVELS_PER_SET=24, SETS=12, LEVELS_TOTAL=SETS*LEVELS_PER_SET;
const TONE_MS=800;
const THRESH_24=[0.20,0.25,0.30,0.35,0.40,0.45,0.50,0.55,0.60,0.60,0.65,0.70,0.75,0.78,0.80,0.83,0.85,0.88,0.90,0.90,0.90,0.90,0.90,0.90];
function blockHasFeedback(block){ return block<=20; }
function rtWindowForSet(n){const a=1183,b=2028;return Math.round(a+(n-1)*(b-a)/11);}
const OOB_RATE=0.25;
const SESS_DAILY_MS=30*60*1000;
const BLOCK_DURATION_MS=6*60*1000;
const BREAK_DURATION_MS=60*1000;
const WEEKLY_TARGET_MS=2*3600*1000;
const LOCKOUT_MS=60*60*1000;
const LATENCY_CUSHION_MS=100;

/* ------------------ JITTER SYSTEM CONSTANTS ------------------ */
const JITTER_LEVELS = {
  0: { // JL0 (onboarding)
    jitterMin: 3, jitterMax: 8,
    probeRate: 0.02, 
    anchorRate: 0.10
  },
  1: { // JL1 (early)  
    jitterMin: 5, jitterMax: 10,
    probeRate: 0.05,
    anchorRate: 0.08
  },
  2: { // JL2 (mid)
    jitterMin: 5, jitterMax: 15,
    probeRate: 0.08,
    anchorRate: 0.05
  },
  3: { // JL3 (mature)
    jitterMin: 5, jitterMax: 15,
    probeRate: 0.11,
    anchorRate: 0.05
  }
};

/* ------------------ THEME SYSTEM ------------------ */
function applyTheme(themeName) {
  const theme = THEMES[themeName] || THEMES.default;
  const root = document.documentElement;
  
  root.style.setProperty('--bg', theme.bg);
  root.style.setProperty('--card', theme.card);
  root.style.setProperty('--muted', theme.muted);
  root.style.setProperty('--muted2', theme.muted2);
  root.style.setProperty('--text', theme.text);
  root.style.setProperty('--good', theme.good);
  root.style.setProperty('--bad', theme.bad);
  root.style.setProperty('--accent', theme.accent);
  root.style.setProperty('--neutral', theme.neutral);
}

/* ------------------ SAFE HELPERS + STATE ------------------ */
function byId(id){ return document.getElementById(id); }
function safe(id, fn){ const el=byId(id); if(el) try{ fn(el); }catch(e){report(e);} }
function showFlex(id){ safe(id, el=> el.style.display='flex'); }
function showBlock(id){ safe(id, el=> el.style.display='block'); }
function hide(id){ safe(id, el=> el.style.display='none'); }
function text(id, v){ safe(id, el=> el.textContent=v); }
function report(err){ const el=byId('bootError'); if(!el) return; el.style.display='block'; el.textContent = '‚ö†Ô∏è Script error: ' + (err && err.message ? err.message : String(err)); if(err && err.stack){ el.textContent += '\n' + err.stack; } }

let state;
try{
  state = JSON.parse(localStorage.getItem('apTrainer')||'null') || {
    userName:null,
    levelIndex:1,
    levelTrials:0, levelCorrect:0,
    shepardDoneFor:-1,
    sessions:[], trials:[],
    startDate:null, lockoutUntil:null, capResetAt:null,
    testFailStreak:0, suggestShownSet:null,
    lastSeen:null, flappyHighScore:0,
    thisWeekIdx:0, thisWeekMs:0,
    levelFailCounts:{},
    specialRanForLevel:null,
    audioType: AUDIO_TYPES.PIANO,
    assessmentScores: [],
    theme: 'default',
    flappySoundEnabled: true,
    flappyMuted: false,
    currentBlock: 1,
    blockStartTime: null,
    inBreak: false,
    breakStartTime: null,
    totalBlocks: 25,
    timeblock: {
      activeMs: 0,
      running: false,
      startedAt: null,
      breaksCompletedToday: 0,
      breakActive: false,
      breakEndsAt: null
    },
    oobController: {
      targetOobPct: 15,
      lastAdaptTimeBlock: 0,
      last60InBounds: [],
      recentOobTrials: [],
      healthCheckActive: false,
      healthCheckEndTimeBlock: 0,
      globalTimeBlockIndex: 0,
      oobSeries: []
    },
    trialOpen: false,
    toneStartMs: null,
    jitter: {
      levelByPc: {},
      statsByPc: {}
    }
  };
} catch(e){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, shepardDoneFor:-1, sessions:[], trials:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null, audioType: AUDIO_TYPES.PIANO, currentBlock: 1, blockStartTime: null, inBreak: false, breakStartTime: null, totalBlocks: 25, timeblock: { activeMs: 0, running: false, startedAt: null, breaksCompletedToday: 0, breakActive: false, breakEndsAt: null }, oobController: { targetOobPct: 15, lastAdaptTimeBlock: 0, last60InBounds: [], recentOobTrials: [], healthCheckActive: false, healthCheckEndTimeBlock: 0, globalTimeBlockIndex: 0, oobSeries: [] }, inBoundsLast60: [], trainingBlockIndex: 1, trainingBlockTrials: 0, currentBlockOctaveCount: {3: 0, 4: 0, 5: 0}, oobHealthCheckActive: false, oobHealthCheckEndBlock: 0, oob: { targetPct: 0.15, streak: 0, blockTarget: 0, plan: [], planOctaveMix: [], currentBlockIndex: 0, currentTrialInBlock: 0 }, trialOpen: false, toneStartMs: null };
}
// Migration for audioType
if (!state.audioType) {
  state.audioType = AUDIO_TYPES.PIANO;
  save();
}
// Migration for block tracking
if (typeof state.currentBlock === 'undefined') {
  state.currentBlock = 1;
  state.blockStartTime = null;
  state.inBreak = false;
  state.breakStartTime = null;
  state.totalBlocks = 25;
  save();
}
// Migration for assessmentScores
if (!state.assessmentScores) {
  state.assessmentScores = [];
  save();
}
// Migration for theme
if (!state.theme) {
  state.theme = 'default';
  save();
}
// Migration for flappyMuted
if (state.flappyMuted === undefined) {
  state.flappyMuted = false;
  save();
}
// Migration for timeblock system
if (!state.timeblock) {
  state.timeblock = {
    activeMs: 0,
    running: false,
    startedAt: null,
    breaksCompletedToday: 0,
    breakActive: false,
    breakEndsAt: null
  };
  save();
}
// Normalize timeblock state on load
normalizeTimeBlockState();
// Migration for oobController
if (!state.oobController) {
  state.oobController = {
    targetOobPct: 15,
    lastAdaptTimeBlock: 0,
    last60InBounds: [],
    recentOobTrials: [],
    healthCheckActive: false,
    healthCheckEndTimeBlock: 0,
    globalTimeBlockIndex: 0,
    oobSeries: []
  };
  save();
}
// Migration for new adaptive OOB state
if (typeof state.oobTargetPct === 'undefined') {
  state.oobTargetPct = 0.15;  // Convert from percentage to decimal
  state.oobStreak = 0;
  state.inBoundsLast60 = [];
  state.trainingBlockIndex = Math.floor((state.levelIndex - 1) / 1) + 1;  // Current training block
  state.trainingBlockTrials = state.levelTrials || 0;
  state.currentBlockOctaveCount = {3: 0, 4: 0, 5: 0};
  state.oobHealthCheckActive = false;
  state.oobHealthCheckEndBlock = 0;
  save();
}

// Migration for new OOB pre-planning state structure
if (!state.oob) {
  state.oob = {
    targetPct: state.oobTargetPct || 0.15,  // Current adaptive target
    streak: state.oobStreak || 0,           // Consecutive OOB trials scheduled
    blockTarget: 0,                        // Frozen target for current block
    plan: [],                              // Array of 20 booleans for current block
    planOctaveMix: [],                     // Pre-computed octaves for planned OOB slots
    currentBlockIndex: 0,                  // Track which block we're in
    currentTrialInBlock: 0                 // Track which trial in current block (0-19)
  };
  // Clean up old state variables
  delete state.oobTargetPct;
  delete state.oobStreak;
  save();
}

// Migration for trial input locking properties
if (typeof state.trialOpen === 'undefined') {
  state.trialOpen = false;
  state.toneStartMs = null;
  save();
}

// Migration for jitter system
if (!state.jitter) {
  state.jitter = {
    levelByPc: {},
    statsByPc: {}
  };
  save();
}

// Migration for confusion tracking
if (!state.confusionMatrix || !state.perfStats || typeof state.lastInBoundsPc === 'undefined') {
  // Initialize confusion tracking structures
  state.confusionMatrix = {};
  for (const truePc of PC) {
    state.confusionMatrix[truePc] = {};
    for (const guessPc of PC) {
      state.confusionMatrix[truePc][guessPc] = 0;
    }
  }
  
  state.perfStats = {};
  for (const pc of PC) {
    state.perfStats[pc] = {
      last40InBounds: [],
      last40Acc: 0,
      meanRT: 0,
      totalSeen: 0
    };
  }
  
  state.lastInBoundsPc = null;
  save();
}

// Initialize confusion scheduler state for frozen block weights
if (!state.conf) {
  state.conf = {
    blockWeights: {},           // Frozen weights for current 20-trial block
    topPairAtBlockStart: null,  // Top confusion pair computed at block start
    prevPc: null,               // Previous PC for anti-streak tracking
    runLen: 0                   // Current run length for anti-streak
  };
  save();
}

// Apply theme on load
applyTheme(state.theme);
function save(){ try{ localStorage.setItem('apTrainer', JSON.stringify(state)); }catch(e){ report(e); } }
window.state = state;

/* ------------------ TIME HELPERS ------------------ */
function fmtMMSS(ms){ const s=Math.max(0,Math.floor(ms/1000)); const m=Math.floor(s/60); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
function fmtHMM(ms){ const s=Math.max(0,Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h}h ${String(m).padStart(2,'0')}m`; }
function fmtHrsMins(ms){ let s=Math.max(0, Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h} hr${h===1?'':'s'} ${m} min${m===1?'':'s'}`; }
function dateAtMidnight(ts){ const d=new Date(ts); d.setHours(0,0,0,0); return d.getTime(); }
function todayKey(ts){ return dateAtMidnight(ts||Date.now()); }
function weekIndex(ts){ const base=ts||Date.now(); if(!state.startDate) return 0; return Math.floor((base-state.startDate)/(7*24*60*60*1000)); }
function currentWeekIdx(){ return weekIndex(Date.now()); }
function weekStartTs(){ if(!state.startDate) return todayKey(Date.now()); const idx=currentWeekIdx(); const base=dateAtMidnight(state.startDate); return base + idx*7*86400000; }

/* ------------------ DURATION ------------------ */
function activeDuration(session){
  const endAt = session.end ?? Date.now();
  let total = Math.max(0, endAt - session.start);
  for(const p of (session.pauses||[])){
    const pe = p.end ?? Date.now();
    const ps = p.start ?? session.start;
    const a = Math.max(session.start, ps);
    const b = Math.min(endAt, pe);
    if(b > a) total -= (b - a);
  }
  return Math.max(0, total);
}

/* ------------------ FLAGS/TIMERS ------------------ */
let sessionActive=false, paused=false;
let rtTimer=null, autoTimer=null, tickId=null, timeblockTickId=null, breakModalTimer=null;
function stopAllTimers(){ if(tickId){ clearInterval(tickId); tickId=null; } if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; } if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; } if(timeblockTickId){ cancelAnimationFrame(timeblockTickId); timeblockTickId=null; } if(breakModalTimer){ clearInterval(breakModalTimer); breakModalTimer=null; }

/* one-shot suppression so strict modal doesn't appear right after specials */
}
let suppressStrictOnce=false;

/* ------------------ TIMEBLOCK SYSTEM ------------------ */
// A) TimeBlock state & ticking (count only during active training)
// Add/normalize state.timeblock structure
function normalizeTimeBlockState() {
  state.timeblock = {
    activeMs: state.timeblock?.activeMs || 0,  // counts ONLY when training is active AND NOT on break
    running: !!state.timeblock?.running,
    startedAt: state.timeblock?.startedAt || null,  // performance.now() of last resume
    breaksCompletedToday: state.timeblock?.breaksCompletedToday || 0, // 0..4
    breakActive: !!state.timeblock?.breakActive,
    breakEndsAt: state.timeblock?.breakEndsAt || null
  };
}

// Tick function (requestAnimationFrame):
function tickTimeBlock(now = performance.now()) {
  if (!state.timeblock) return;
  const tb = state.timeblock;
  if (tb.running && !tb.breakActive) {
    if (tb.startedAt == null) tb.startedAt = now;
    const dt = Math.max(0, now - tb.startedAt);
    tb.activeMs += dt;
    tb.startedAt = now;
    if (tb.activeMs >= 6*60*1000) beginTimeBlockBreak();
  }
  renderTrainerHeaderTimeBlock(); // uses tb.activeMs
  requestAnimationFrame(tickTimeBlock);
}

function startTimeBlockTimer() {
  if (!state.timeblock.running) {
    state.timeblock.running = true;
    state.timeblock.startedAt = performance.now();
    save();
  }
  // Start the loop once on trainer mount:
  requestAnimationFrame(tickTimeBlock);
}

function pauseTimeBlockTimer() {
  if (state.timeblock.running) {
    // Update one final time before pausing
    if (state.timeblock.startedAt) {
      const now = performance.now();
      state.timeblock.activeMs += now - state.timeblock.startedAt;
    }
    state.timeblock.running = false;
    save();
  }
}

// Keep legacy functions for compatibility
function timeblockTick() {
  return tickTimeBlock();
}

function updateTimeBlockMs() {
  if (state.timeblock.running && state.timeblock.startedAt) {
    const now = performance.now();
    state.timeblock.activeMs += now - state.timeblock.startedAt;
    state.timeblock.startedAt = now;
  }
}

// B) Begin/End break logic (modal stays up for full 60s)
function beginTimeBlockBreak() {
  const tb = state.timeblock;
  tb.running = false;
  tb.breakActive = true;
  tb.breakEndsAt = Date.now() + 60_000;
  showFlappyModal({ countdown: tb.breakEndsAt }); // open modal; show 60s countdown; inputs in trainer disabled
  
  // Start break modal timer that checks every 250ms
  if (breakModalTimer) clearInterval(breakModalTimer);
  breakModalTimer = setInterval(() => {
    maybeCloseBreakModal();
  }, 250);
  
  // Log TimeBlock completion
  logTimeBlockOobData({ 
    event: 'timeblock_completed',
    timeBlockIndex: state.timeblock.breaksCompletedToday + 1
  });
  
  save();
  
  // Pause training
  if (sessionActive && !paused) {
    pauseStart('timeblock-break');
  }
  
  openFlappyModalForTimeBlockBreak();
}

function showFlappyModal(options = {}) {
  openFlappyModal();
  if (options.countdown) {
    updateTimeBlockBreakUI();
  }
}

function endTimeBlockBreak() {
  state.timeblock.activeMs = 0;
  state.timeblock.breakActive = false;
  state.timeblock.breakEndsAt = null;
  state.timeblock.breaksCompletedToday++;
  
  if (state.timeblock.breaksCompletedToday >= 5) {
    endDayAndLockout();
  } else {
    // Resume training:
    state.timeblock.running = true; 
    state.timeblock.startedAt = performance.now();
  }
  
  save();
}

function endDayAndLockout() {
  const now = Date.now();
  state.lockoutUntil = now + 60 * 60 * 1000; // 1 hour lockout
  state.capResetAt = state.lockoutUntil;
  
  // Reset TimeBlock system for next day
  state.timeblock = {
    activeMs: 0,
    running: false,
    startedAt: null,
    breaksCompletedToday: 0,
    breakActive: false,
    breakEndsAt: null
  };
  
  save();
  endSession(true);
}

function openFlappyModalForTimeBlockBreak() {
  openFlappyModal();
  updateTimeBlockBreakUI();
}

function updateTimeBlockBreakUI() {
  if (!state.timeblock.breakActive || !state.timeblock.breakEndsAt) return;
  
  const now = Date.now();
  const remaining = Math.max(0, state.timeblock.breakEndsAt - now);
  
  // At exactly breakEndsAt, close the modal immediately (do NOT wait for the current flappy round to end).
  if (remaining <= 0) {
    // Break time is up - close modal and end break
    const flappyModal = byId('flappyModal');
    if (flappyModal && flappyModal.style.display === 'flex') {
      closeFlappy();
    }
    endTimeBlockBreakAndCloseModal();
    return;
  }
  
  // Always keep modal open until Date.now() >= breakEndsAt.
  // If the player loses early, the modal STAYS open with the countdown still visible
  const flappyModal = byId('flappyModal');
  if (flappyModal && flappyModal.style.display === 'flex') {
    let breakMessage = flappyModal.querySelector('#timeBlockBreakMessage');
    if (!breakMessage) {
      breakMessage = document.createElement('p');
      breakMessage.id = 'timeBlockBreakMessage';
      breakMessage.style.cssText = 'margin: 8px 0; font-weight: 600; color: var(--accent);';
      const flappyCard = flappyModal.querySelector('.card');
      if (flappyCard) {
        flappyCard.insertBefore(breakMessage, flappyCard.querySelector('canvas'));
      }
    }
    breakMessage.textContent = `TimeBlock break: ${fmtMMSS(remaining)} remaining`;
    
    // Show "Play again" option if game is not running and no crash overlay is shown
    const crashOverlay = flappyModal.querySelector('#flappyCrashOverlay');
    if (!running && !crashOverlay) {
      let playAgainBtn = flappyModal.querySelector('#playAgainBtn');
      if (!playAgainBtn) {
        playAgainBtn = document.createElement('button');
        playAgainBtn.id = 'playAgainBtn';
        playAgainBtn.textContent = 'Play again';
        playAgainBtn.style.cssText = 'margin-right: 8px;';
        const closeBtn = flappyModal.querySelector('#flappyClose');
        if (closeBtn && closeBtn.parentNode) {
          closeBtn.parentNode.insertBefore(playAgainBtn, closeBtn);
        }
        playAgainBtn.onclick = () => {
          running = true;
          resetFlappy();
          flappyRAF = requestAnimationFrame(step);
        };
      }
    } else if (running) {
      // Remove play again button if game is running
      const playAgainBtn = flappyModal.querySelector('#playAgainBtn');
      if (playAgainBtn) playAgainBtn.remove();
    }
  }
}

// C) Header display (do not reset on menu)
function renderTrainerHeaderTimeBlock() {
  // Calculate i = Math.min(5, (state.timeblock?.breaksCompletedToday || 0) + (state.timeblock?.breakActive ? 1 : 1));
  // i is 1..5 for the current/next TimeBlock being worked on
  const breaksCompleted = state.timeblock?.breaksCompletedToday || 0;
  const i = Math.min(5, breaksCompleted + 1);
  
  // Show "TimeBlock i/5  mm:ss / 06:00"
  // Compute mm:ss from state.timeblock.activeMs (clamp to 0..360000).
  const activeMs = Math.max(0, Math.min(360000, state.timeblock?.activeMs || 0));
  const mmss = fmtMMSS(activeMs);
  
  text('blockTimeInfo', `TimeBlock ${i}/5  ${mmss} / 06:00`);
}

// F) Fix missing logger reference
function logTimeBlockOobData(payload = {}) {
  window.qa = window.qa || {}; 
  qa.timeBlocks = qa.timeBlocks || [];
  qa.timeBlocks.push({
    date: new Date().toISOString(),
    breaksCompletedToday: state.timeblock?.breaksCompletedToday ?? null,
    activeMs: state.timeblock?.activeMs ?? null,
    oobTarget: state.oob?.blockTarget ?? state.oob?.targetPct ?? null,
    event: 'timeblock_completed',
    timeBlockIndex: (state.timeblock?.breaksCompletedToday || 0) + 1,
    ...payload
  });
}

/* Removed updateTimeBlockDisplay - now using renderTrainerHeaderTimeBlock */

function endTimeBlockBreakAndCloseModal() {
  endTimeBlockBreak();
  
  // Close Flappy modal if open
  const flappyModal = byId('flappyModal');
  if (flappyModal && flappyModal.style.display === 'flex') {
    closeFlappy();
  }
  
  // Resume training if session is active
  if (sessionActive && paused) {
    pauseEnd();
    safe('btnPause', el=> el.textContent='‚è∏ Pause');
    text('promptPill','TimeBlock break over ‚Äî press Play to continue');
  }
}

// B) Countdown governs closure, not game state
function maybeCloseBreakModal() {
  if (!state.timeblock.breakActive || !state.timeblock.breakEndsAt) return;
  
  if (Date.now() >= state.timeblock.breakEndsAt) {
    // Stop the break modal timer
    if (breakModalTimer) {
      clearInterval(breakModalTimer);
      breakModalTimer = null;
    }
    
    // Hard close regardless of current game state
    closeFlappyModal();
    // end break
    state.timeblock.breakActive = false;
    state.timeblock.activeMs = 0;
    state.timeblock.breaksCompletedToday++;
    // resume training if <5 TimeBlocks; otherwise end day/lockout
    if (state.timeblock.breaksCompletedToday < 5) {
      state.timeblock.running = true;
      state.timeblock.startedAt = performance.now();
    } else {
      endDayAndLockout();
    }
    save();
    
    // Resume training if session is active
    if (sessionActive && paused) {
      pauseEnd();
      safe('btnPause', el=> el.textContent='‚è∏ Pause');
      text('promptPill','TimeBlock break over ‚Äî press Play to continue');
    }
  }
}

function closeFlappyModal() {
  running = false; 
  cancelAnimationFrame(flappyRAF); 
  byId('flappyModal').style.display = 'none'; 
  detachFlappyControls();
  
  if (score > (state.flappyHighScore || 0)) { 
    state.flappyHighScore = score; 
    save(); 
  }
  
  // Remove break message if it exists
  const breakMessage = byId('timeBlockBreakMessage');
  if (breakMessage) breakMessage.remove();
  
  // Remove crash overlay if it exists
  const crashOverlay = byId('flappyCrashOverlay');
  if (crashOverlay) crashOverlay.remove();
}

/* ------------------ SANITY ------------------ */
function sealDanglingSession(){
  try{
    const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
    if(!rec) return;
    if(rec.end == null){
      const now = Date.now();
      if(rec.pauses && rec.pauses.length){
        const last = rec.pauses[rec.pauses.length-1];
        if(last && !last.end) last.end = now;
      }
      rec.end = now; save();
    }
  }catch(e){ report(e); }
}

/* ------------------ UI ------------------ */
function showScreen(id){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  if(id === 'menuScreen'){
    sessionActive=false; paused=false;
    // C) On leaving Trainer (menu etc): pause the tick (set running=false) but DO NOT reset activeMs.
    pauseTimeBlockTimer();
    stopAllTimers(); sealDanglingSession(); updateCapsUI();
    try{ populatePitchSelect(); drawChart(); }catch(_){}
  } else if(id !== 'trainerScreen'){
    if(sessionActive && !paused){ 
      pauseStart('nav-away'); 
      pauseTimeBlockTimer();
    }
  }
  const el = byId(id); if(el) el.style.display='block';
}
function ensureWeekRoll(){ const wi=currentWeekIdx(); if(state.thisWeekIdx!==wi){ state.thisWeekIdx=wi; state.thisWeekMs=0; save(); } }
function isLocked(){ return state.lockoutUntil && Date.now() < state.lockoutUntil; }
function updateCapsUI(){
  ensureWeekRoll();
  const left = Math.max(0, SESS_DAILY_MS - msUsedQuota());
  text('capInfo', `Left: ${fmtMMSS(left)}`);
  const usedW = state.thisWeekMs || 0;
  const wp = byId('weekPill');
  if(wp){
    wp.textContent = `This week: ${fmtHrsMins(usedW)}`;
    let color = '#dc2626';
    if(usedW >= 1*3600000 && usedW < 2*3600000) color = 'var(--text)';
    else if(usedW >= 2*3600000 && usedW < 3*3600000) color = '#16a34a';
    else if(usedW >= 3*3600000) color = '#fbbf24';
    wp.style.color = color;
    wp.title = `Target: ${fmtHMM(WEEKLY_TARGET_MS)}`;
  }
  const locked = isLocked();
  const lp = byId('lockoutPill');
  if(lp){
    if(locked){ lp.style.display='inline-flex'; lp.textContent = `üîí Locked (${fmtHMM(state.lockoutUntil - Date.now())} left)`; }
    else lp.style.display='none';
  }
  const pf = byId('playFlappy'); if(pf) pf.disabled = !locked;
}
function setFromIndex(i){return Math.floor((i-1)/LEVELS_PER_SET)+1;}
function blockFromIndex(i){return ((i-1)%LEVELS_PER_SET)+1;}
function thresholdForIndex(i){return THRESH_24[blockFromIndex(i)-1];}
function trainedSet(k){ return UNLOCK_ORDER.slice(0,k); }

// B) Helper function to pick OOB PC when isOOB is true
function pickOobPc(trained) {
  const set = setFromIndex(state.levelIndex);
  const oobCandidates = currentOOBs(set);
  
  if (oobCandidates.length === 0) {
    console.warn('pickOobPc: No OOB candidates available');
    return null;
  }
  
  return oobCandidates[Math.floor(Math.random() * oobCandidates.length)];
}

// A) Source of truth for trained set - implements getTrainedPCs() requirement
function getTrainedPCs() {
  // Preferred: read from existing app state
  if (Array.isArray(state?.training?.activeSet) && state.training.activeSet.length) {
    return [...state.training.activeSet];
  }

  if (Array.isArray(state?.currentSet) && state.currentSet.length) {
    return [...state.currentSet];
  }

  // Fallback: derive from UI (enabled pitch buttons) 
  const els = Array.from(document.querySelectorAll('.note-btn:not([aria-disabled="true"])'));
  const pcs = els.map(el => el.dataset.pc || el.textContent?.trim()).filter(Boolean);
  if (pcs.length > 0) {
    return Array.from(new Set(pcs));
  }

  // Final fallback: use current trained set from level index
  const set = setFromIndex(state.levelIndex);
  return trainedSet(set);
}

/* ------------------ AUDIO ------------------ */
let ACTX=null; const BUF_CACHE=new Map();
let FLAPPY_AUDIO_BUFFER = null; // E) Preload flappy audio buffer

function getCtx(){ if(!ACTX){ ACTX=new (window.AudioContext||window.webkitAudioContext)(); } return ACTX; }
async function resumeCtx(){ try{ const ctx=getCtx(); if(ctx.state==='suspended') await ctx.resume(); }catch(e){ report(e); } }
async function loadBuffer(url){ if(BUF_CACHE.has(url)) return BUF_CACHE.get(url); const res=await fetch(url); if(!res.ok) throw new Error('Missing audio '+url); const arr=await res.arrayBuffer(); const buf=await getCtx().decodeAudioData(arr); BUF_CACHE.set(url,buf); return buf; }
async function closeAudio(){ try{ if(ACTX){ await ACTX.close(); } }catch(_){} finally{ ACTX=null; BUF_CACHE.clear(); FLAPPY_AUDIO_BUFFER=null; } }

// E) Preload flappy audio once on app init
async function preloadFlappyAudio() {
  try {
    await resumeCtx();
    FLAPPY_AUDIO_BUFFER = await loadBuffer('./audio/flappy.mp3');
  } catch (e) {
    console.warn('Could not preload flappy audio:', e);
  }
}

// E) Flappy sound function
function playFlappySound() {
  if (state.flappyMuted) return;
  
  try {
    const ctx = getCtx();
    if (FLAPPY_AUDIO_BUFFER) {
      const src = ctx.createBufferSource();
      src.buffer = FLAPPY_AUDIO_BUFFER;
      const g = ctx.createGain(); 
      g.gain.value = 0.5; // Reasonable volume
      src.connect(g).connect(ctx.destination);
      src.start();
    }
  } catch (e) {
    console.warn('Could not play flappy sound:', e);
  }
}

/* Guitar sample mapping - available samples and their pitches */
const GUITAR_SAMPLES = {
  'E2': 'E2.wav', 'A2': 'A2.wav', 'D3': 'D3.wav', 
  'G3': 'G3.wav', 'B3': 'B3.wav', 'E4': 'E4.wav', 'A4': 'A4.wav'
};

/* Find closest guitar sample for pitch shifting */
function findClosestGuitarSample(targetNote) {
  const m=/^([A-G](?:b)?)(\d)$/.exec(targetNote);
  const pc=m?m[1]:'A', o=m?+m[2]:4;
  const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
  const targetSemis=(idx[pc]??9)+(o-4)*12;
  
  let bestSample = 'E2';
  let bestDistance = 999;
  
  for (const sampleNote of Object.keys(GUITAR_SAMPLES)) {
    const sm=/^([A-G](?:b)?)(\d)$/.exec(sampleNote);
    const spc=sm?sm[1]:'E', so=sm?+sm[2]:2;
    const sampleSemis=(idx[spc]??4)+(so-4)*12;
    const distance = Math.abs(targetSemis - sampleSemis);
    if (distance < bestDistance) {
      bestDistance = distance;
      bestSample = sampleNote;
    }
  }
  
  return { sample: bestSample, semitones: targetSemis - ((idx[bestSample.match(/^([A-G](?:b)?)/)[1]]??4)+((+bestSample.match(/(\d)$/)[1])-4)*12) };
}

/* Always play a tone (sample -> oscillator -> fallback) */
async function playSample(note, detuneCents = 0){
  // Capture tone start timing for reaction time calculation
  state.toneStartMs = performance.now();
  state.trialOpen = true;
  
  try{
    await resumeCtx();
    const ctx = getCtx();
    
    // Calculate detune multiplier
    const detuneMultiplier = Math.pow(2, detuneCents / 1200);
    
    // Handle different audio types
    if (state.audioType === AUDIO_TYPES.PIANO) {
      try{
        const url = `${AUDIO_PIANO}/${note}.mp3`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply detune using detune property if available, otherwise playbackRate
        if (src.detune) {
          src.detune.value = detuneCents;
        } else {
          src.playbackRate.value = detuneMultiplier;
        }
        
        const g = ctx.createGain(); g.gain.value = 1;
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        src.start(t); src.stop(t + TONE_MS/1000);
        return;
      }catch(_e){}
    } else if (state.audioType === AUDIO_TYPES.GUITAR) {
      try{
        const {sample, semitones} = findClosestGuitarSample(note);
        const url = `${AUDIO_GUITAR}/${GUITAR_SAMPLES[sample]}`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply both pitch shifting and detune
        const pitchRatio = Math.pow(2, semitones / 12);
        const combinedRatio = pitchRatio * detuneMultiplier;
        
        if (src.detune) {
          src.playbackRate.value = pitchRatio;
          src.detune.value = detuneCents;
        } else {
          src.playbackRate.value = combinedRatio;
        }
        
        // Guitar samples are louder, so reduce gain
        const g = ctx.createGain(); 
        g.gain.value = 0.7; // Reduce guitar volume
        
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        src.start(t); src.stop(t + TONE_MS/1000 / pitchRatio);
        return;
      }catch(_e){}
    } else if (state.audioType === AUDIO_TYPES.SINE) {
      // Skip to sine wave generation
    } else {
      // Default to piano, fallback to sine
      try{
        const url = `${AUDIO_PIANO}/${note}.mp3`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply detune using detune property if available, otherwise playbackRate
        if (src.detune) {
          src.detune.value = detuneCents;
        } else {
          src.playbackRate.value = detuneMultiplier;
        }
        
        const g = ctx.createGain(); g.gain.value = 1;
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        src.start(t); src.stop(t + TONE_MS/1000);
        return;
      }catch(_e){}
    }
    
    // Fallback to sine wave
    const m=/^([A-G](?:b)?)(\d)$/.exec(note);
    const pc=m?m[1]:'A', o=m?+m[2]:4;
    const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
    const semis=(idx[pc]??9)+(o-4)*12;
    const baseFreq=440*Math.pow(2,(semis-9)/12);
    const detunedFreq = baseFreq * detuneMultiplier;
    
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type='sine'; osc.frequency.value=detunedFreq;
    const t0 = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.25, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + TONE_MS/1000);
    osc.connect(g).connect(ctx.destination);
    osc.start(t0); osc.stop(t0 + TONE_MS/1000);
  }catch(e){
    try{
      const ctx=getCtx(); const osc=ctx.createOscillator(); const g=ctx.createGain();
      osc.type='sine'; osc.frequency.value=440 * detuneMultiplier;
      const t0=ctx.currentTime; g.gain.setValueAtTime(0.0001,t0); g.gain.linearRampToValueAtTime(0.2,t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t0+0.3);
      osc.connect(g).connect(ctx.destination); osc.start(t0); osc.stop(t0+0.3);
    }catch(_){}
  }
}

/* Flappy sound for Flappy Bird lockout */
/* Removed - now using playFlappySound() defined in AUDIO section */

/* ------------------ Shepard (pauses) ------------------ */
let shepRunning=false;
async function playShepard20s(){
  const wasActive = sessionActive && !paused;
  if(wasActive) pauseStart('shepard');
  await resumeCtx();
  const overlay=byId('shepardOverlay'), counterEl=byId('shepardCountdown');
  if(!overlay||!counterEl) return;
  overlay.style.display='flex'; shepRunning=true;
  const ctx=getCtx(); const oscillators=[]; const partials=8, base=55, dur=20; const now=ctx.currentTime;
  for(let i=0;i<partials;i++){
    const osc=ctx.createOscillator(); const g=ctx.createGain(); const f=base*Math.pow(2,i);
    osc.type='sine'; osc.frequency.setValueAtTime(f, now); osc.frequency.exponentialRampToValueAtTime(f/2, now+dur);
    const amp=Math.exp(-Math.pow((i-(partials-1)/2)/2,2)); g.gain.setValueAtTime(0.05*amp, now);
    osc.connect(g).connect(ctx.destination); oscillators.push(osc);
  }
  oscillators.forEach(o=>o.start(now)); oscillators.forEach(o=>o.stop(now+dur));
  let left=20; counterEl.textContent=left;
  const id=setInterval(()=>{ left--; counterEl.textContent=left; if(left<=0) clearInterval(id); },1000);
  await new Promise(r=>setTimeout(r,dur*1000));
  overlay.style.display='none'; shepRunning=false;
  if(wasActive){ pauseEnd(); safe('btnPause', el=> el.textContent='‚è∏ Pause'); }
}

/* ------------------ TRAINING FLOW ------------------ */
let autoNext=false, delayMs=1000;
let currentNote=null, truePc=null, isOOBTrial=false;
let firstRtBonusMs=0, inFlightTrial=false;
let suggestedRestartFlag=false;

// Jitter system globals for current trial
let currentDetuneCents=0, currentDetuneMode='jitter', currentJlLevel=null;

/* Specials runtime */
let special=null; // {mode:'A'|'B', targetPc:'F', total:12|22, done:0, withFeedback:true, correct:0}

/* Assessment runtime */
let assessmentActive=false, assessmentTrials=[], assessmentCurrentTrial=0;

const PC2I={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
function currentOOBs(setSize){
  if(setSize>=12) return [];
  const learned = trainedSet(setSize).map(n=>PC2I[n]).sort((a,b)=>a-b);
  const low=learned[0], high=learned[learned.length-1];
  const up1=(high+1)%12, up2=(high+2)%12, dn1=(low+11)%12, dn2=(low+10)%12;
  const out=[];
  if(!learned.includes(up1)) out.push(PC[up1]);
  if(!learned.includes(up2) && !learned.includes(up1)) out.push(PC[up2]);
  if(!learned.includes(dn1)) out.push(PC[dn1]);
  if(!learned.includes(dn2) && !learned.includes(dn1)) out.push(PC[dn2]);
  return out;
}
function getPlusMinusTwoSemitones(targetPc){
  const targetIndex = PC2I[targetPc];
  if (targetIndex === undefined) return [targetPc]; // fallback
  
  const pitches = [];
  for (let offset = -2; offset <= 2; offset++) {
    const index = (targetIndex + offset + 12) % 12;
    pitches.push(PC[index]);
  }
  return pitches;
}
function currentOctaves(){ 
  if (state.audioType === AUDIO_TYPES.GUITAR) {
    return [3,4,5]; // Guitar uses C3-B5
  }
  return [4,5,6]; // Piano uses C4-B6
}
function rand(a){ return a[Math.floor(Math.random()*a.length)]; }
function pcLabel(pc){ return PC_LABEL[pc] || pc; }

/* ------------------ ADAPTIVE OOB CONTROLLER (Training Block Based) ------------------ */
function updateTrainingBlockOobController(trial) {
  // Update rolling window for in-bounds trials only
  if (!trial.oob && !trial.timeout && trial.guess !== null) {
    state.inBoundsLast60.push({
      correct: trial.correct,
      time: trial.time
    });
    // Keep only last 60
    if (state.inBoundsLast60.length > 60) {
      state.inBoundsLast60.shift();
    }
  }
  
  // Track octave distribution for this training block
  if (!trial.oob && trial.note) {
    const octave = parseInt(trial.note.slice(-1));
    if (state.currentBlockOctaveCount[octave] !== undefined) {
      state.currentBlockOctaveCount[octave]++;
    }
  }
  
  // Update OOB streak using new state structure
  if (trial.oob) {
    state.oob.streak++;
  } else {
    state.oob.streak = 0;  // Reset streak on in-bounds trial
  }
  
  // Advance trial index within current block
  state.oob.currentTrialInBlock++;
  
  save();
}

function getTrainingBlockAcc60() {
  if (state.inBoundsLast60.length === 0) return 0;
  const correct = state.inBoundsLast60.filter(t => t.correct).length;
  return correct / state.inBoundsLast60.length;
}

function adaptOobTargetAtTrainingBlockBoundary(blockIndex) {
  // Only adapt at boundary after every 3 Training Blocks (blocks 3, 6, 9, 12, 15, 18, 21, 24)
  if (blockIndex % 3 !== 0) return false;
  
  const acc60 = getTrainingBlockAcc60();
  
  // Adjust target OOB% using new state structure
  if (acc60 > 0.85) {
    state.oob.targetPct = Math.max(0.05, state.oob.targetPct - 0.03);
  } else if (acc60 < 0.70) {
    state.oob.targetPct = Math.min(0.35, state.oob.targetPct + 0.03);
  }
  // Else hold current target
  
  // Reset health caps if active
  if (state.oobHealthCheckActive) {
    state.oobHealthCheckActive = false;
    state.oobHealthCheckEndBlock = 0;
  }
  
  save();
  return true;  // Adaptation occurred
}

function updateOobHealthCheckTrainingBlock() {
  // Check if health check should end (after 2 Training Blocks)
  if (state.oobHealthCheckActive && state.trainingBlockIndex >= state.oobHealthCheckEndBlock) {
    state.oobHealthCheckActive = false;
    state.oobHealthCheckEndBlock = 0;
    save();
  }
  
  // Check if we need to start health check based on last 20 OOB trials
  if (!state.oobHealthCheckActive) {
    const recentOobTrials = state.trials.filter(t => t.oob).slice(-20);
    if (recentOobTrials.length >= 20) {
      const oobCorrect = recentOobTrials.filter(t => t.correct).length;
      const oobAcc = oobCorrect / 20;
      
      if (oobAcc < 0.60) {
        state.oobHealthCheckActive = true;
        state.oobHealthCheckEndBlock = state.trainingBlockIndex + 2;
        save();
      }
    }
  }
}

/* ------------------ CONFUSION-AWARE SCHEDULING ------------------ */

// Initialize confusion tracking structures
function initializeConfusionTracking() {
  if (!state.confusionMatrix) {
    // Initialize 12x12 confusion matrix
    state.confusionMatrix = {};
    for (const truePc of PC) {
      state.confusionMatrix[truePc] = {};
      for (const guessPc of PC) {
        state.confusionMatrix[truePc][guessPc] = 0;
      }
    }
  } else {
    // Ensure all entries exist without overwriting existing values
    for (const truePc of PC) {
      if (!state.confusionMatrix[truePc]) {
        state.confusionMatrix[truePc] = {};
      }
      for (const guessPc of PC) {
        if (state.confusionMatrix[truePc][guessPc] === undefined) {
          state.confusionMatrix[truePc][guessPc] = 0;
        }
      }
    }
  }
  
  if (!state.perfStats) {
    // Initialize per-note performance stats
    state.perfStats = {};
    for (const pc of PC) {
      state.perfStats[pc] = {
        last40InBounds: [],
        last40Acc: 0,
        meanRT: 0,
        totalSeen: 0
      };
    }
  } else {
    // Ensure all entries exist without overwriting existing values
    for (const pc of PC) {
      if (!state.perfStats[pc]) {
        state.perfStats[pc] = {
          last40InBounds: [],
          last40Acc: 0,
          meanRT: 0,
          totalSeen: 0
        };
      } else {
        // Ensure all required properties exist
        if (!state.perfStats[pc].last40InBounds) {
          state.perfStats[pc].last40InBounds = [];
        }
        if (state.perfStats[pc].last40Acc === undefined) {
          state.perfStats[pc].last40Acc = 0;
        }
        if (state.perfStats[pc].meanRT === undefined) {
          state.perfStats[pc].meanRT = 0;
        }
        if (state.perfStats[pc].totalSeen === undefined) {
          state.perfStats[pc].totalSeen = 0;
        }
      }
    }
  }
  
  if (state.lastInBoundsPc === undefined) {
    state.lastInBoundsPc = null;
  }
}

// Update confusion matrix on in-bounds error
function updateConfusionMatrix(truePc, guessPc) {
  // Ensure confusion matrix structure exists
  if (!state.confusionMatrix) {
    state.confusionMatrix = {};
  }
  if (!state.confusionMatrix[truePc]) {
    state.confusionMatrix[truePc] = {};
  }
  if (state.confusionMatrix[truePc][guessPc] === undefined) {
    state.confusionMatrix[truePc][guessPc] = 0;
  }
  
  // Now safely increment
  state.confusionMatrix[truePc][guessPc]++;
}

// Update per-note performance stats
function updatePerfStats(pc, correct, rtMs) {
  // Ensure perfStats structure exists
  if (!state.perfStats) {
    state.perfStats = {};
  }
  if (!state.perfStats[pc]) {
    state.perfStats[pc] = {
      last40InBounds: [],
      last40Acc: 0,
      meanRT: 0,
      totalSeen: 0
    };
  }
  
  const stats = state.perfStats[pc];
  
  // Ensure last40InBounds exists
  if (!stats.last40InBounds) {
    stats.last40InBounds = [];
  }
  
  // Add to last40InBounds
  stats.last40InBounds.push({correct, rtMs});
  if (stats.last40InBounds.length > 40) {
    stats.last40InBounds.shift();
  }
  
  // Recalculate stats
  const validTrials = stats.last40InBounds.filter(t => t.rtMs != null && !isNaN(t.rtMs));
  stats.last40Acc = stats.last40InBounds.length > 0 ? 
    stats.last40InBounds.filter(t => t.correct).length / stats.last40InBounds.length : 0;
  stats.meanRT = validTrials.length > 0 ? 
    validTrials.reduce((sum, t) => sum + t.rtMs, 0) / validTrials.length : 0;
  stats.totalSeen++;
}

// D) Compute stats at block START and build frozen block weights - ONLY from in-bounds in trained set
function computeBlockWeightsAtStart() {
  // D) Use getTrainedPCs() as source of truth for trained set
  const trainedPcs = getTrainedPCs();
  
  // D) Compute perf stats from last 40 in-bounds trials per trained PC
  for (const pc of trainedPcs) {
    const stats = state.perfStats[pc];
    if (stats && stats.last40InBounds) {
      const last40N = stats.last40InBounds.length;
      const last40Acc = last40N > 0 ? 
        stats.last40InBounds.filter(t => t.correct).length / last40N : 0;
      stats.last40Acc = last40Acc;
    }
  }
  
  // D) Find topPair from last ~200 in-bounds trials (restricted to trained PCs)
  const topPair = getTopConfusionPair();
  
  // E) Build frozen block weights ONLY over trained PCs
  const weights = {};
  for (const pc of trainedPcs) {
    let w = 1.0; // Base weight
    
    // Weakness boost: if perf[pc].last40Acc < 0.80 ‚Üí w += 0.5
    const stats = state.perfStats[pc];
    const last40Acc = (stats && typeof stats.last40Acc === 'number') ? stats.last40Acc : 1; // Default to 1.0 if no data (no weakness boost for unknowns)
    if (last40Acc < 0.80) {
      w += 0.5;
    }
    
    // Top confusion boost: if pc === topPair.true ‚Üí w += 0.5
    if (topPair && topPair.true === pc) {
      w += 0.5;
    }
    
    // Floor: w = Math.max(w, 0.5)
    w = Math.max(w, 0.5);
    weights[pc] = w;
  }
  
  // Normalize to sum 1
  const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
  if (totalWeight > 0) {
    for (const pc of trainedPcs) {
      weights[pc] = weights[pc] / totalWeight;
    }
  } else {
    // Fallback: uniform distribution if all weights are 0 (should not happen due to floor)
    const uniformWeight = 1.0 / trainedPcs.length;
    for (const pc of trainedPcs) {
      weights[pc] = uniformWeight;
    }
  }
  
  // Store frozen weights and reset streak tracking
  state.conf.blockWeights = weights;
  state.conf.topPairAtBlockStart = topPair;
  state.conf.prevPc = null;
  state.conf.runLen = 0;
  
  save();
}
function getTopConfusionPair() {
  // D) Get trained PCs as source of truth
  const trainedPcs = getTrainedPCs();
  
  // D) Only use last ~200 in-bounds trials restricted to trained PCs
  const last200InBounds = (state.trials || [])
    .filter(t => !t.oob && !t.timeout && t.guess !== null && 
                 trainedPcs.includes(t.pc) && trainedPcs.includes(t.guess))
    .slice(-200);
  
  // D) Build temp confusion matrix ONLY over trained PCs
  const tempConf = {};
  for (const truePc of trainedPcs) {
    tempConf[truePc] = {};
    for (const guessPc of trainedPcs) {
      tempConf[truePc][guessPc] = 0;
    }
  }
  
  // Count errors only (true != guess), restricted to trained PCs
  for (const trial of last200InBounds) {
    if (!trial.correct && trial.pc && trial.guess && 
        trainedPcs.includes(trial.pc) && trainedPcs.includes(trial.guess)) {
      if (tempConf[trial.pc] && tempConf[trial.pc][trial.guess] !== undefined) {
        tempConf[trial.pc][trial.guess]++;
      }
    }
  }
  
  // D) Find the highest confusion count among trained PCs only
  let topTrue = null;
  let topWrong = null;
  let maxCount = 0;
  
  for (const truePc of trainedPcs) {
    for (const wrongPc of trainedPcs) {
      if (truePc !== wrongPc && tempConf[truePc][wrongPc] > maxCount) {
        maxCount = tempConf[truePc][wrongPc];
        topTrue = truePc;
        topWrong = wrongPc;
      }
    }
  }
  
  return maxCount > 0 ? {true: topTrue, wrong: topWrong, count: maxCount} : null;
}

// F) Anti-streak ‚â§ 2 for in-bounds sampling with guardrails
function choosePcWithAntiStreak() {
  const trained = getTrainedPCs();
  
  // H) Guardrails: If no trained PCs, return null
  if (!trained || trained.length === 0) {
    console.warn('choosePcWithAntiStreak: No trained PCs available');
    return null;
  }
  
  // H) Guardrails: If only one trained PC, return it directly (anti-streak is moot)
  if (trained.length === 1) {
    const onlyPc = trained[0];
    state.conf.prevPc = onlyPc;
    state.conf.runLen = (state.conf.prevPc === onlyPc) ? (state.conf.runLen || 0) + 1 : 1;
    return onlyPc;
  }
  
  const W = state.conf.blockWeights;
  if (!W || Object.keys(W).length === 0) {
    console.warn('choosePcWithAntiStreak: No block weights available');
    return null;
  }
  
  // Helper: sample from discrete distribution
  function sampleDiscrete(weights) {
    const keys = Object.keys(weights);
    const rand = Math.random();
    let cumulative = 0;
    for (const pc of keys) {
      cumulative += weights[pc];
      if (rand <= cumulative) return pc;
    }
    return keys[keys.length - 1]; // Fallback
  }
  
  // Helper: sample excluding a specific PC
  function sampleDiscreteExclude(weights, excludePc) {
    const filtered = {};
    let totalWeight = 0;
    for (const pc in weights) {
      if (pc !== excludePc) {
        filtered[pc] = weights[pc];
        totalWeight += weights[pc];
      }
    }
    if (totalWeight === 0) return null;
    
    // Normalize and sample
    for (const pc in filtered) {
      filtered[pc] = filtered[pc] / totalWeight;
    }
    return sampleDiscrete(filtered);
  }
  
  // Helper: find PC with highest weight excluding a specific PC
  function argmaxKey(weights, scoreFn) {
    let bestPc = null;
    let bestScore = -Infinity;
    for (const pc in weights) {
      const score = scoreFn(pc);
      if (score > bestScore) {
        bestScore = score;
        bestPc = pc;
      }
    }
    return bestPc;
  }
  
  let pc = sampleDiscrete(W); // Weighted pick
  
  if (pc === state.conf.prevPc && state.conf.runLen >= 2) {
    // Try once excluding prevPc
    pc = sampleDiscreteExclude(W, state.conf.prevPc) || pc;
    if (pc === state.conf.prevPc) {
      // Force change: pick the highest weight among PCs != prevPc
      pc = argmaxKey(W, k => (k === state.conf.prevPc ? -Infinity : W[k]));
    }
  }
  
  // Update streak bookkeeping
  if (pc === state.conf.prevPc) {
    state.conf.runLen++;
  } else {
    state.conf.prevPc = pc;
    state.conf.runLen = 1;
  }
  
  return pc;
}

// Confusion-aware note selection for in-bounds trials with guardrails
function selectInBoundsNoteConfusionAware(usable) {
  // H) Guardrails: Get trained PCs and handle edge cases
  const trained = getTrainedPCs();
  
  if (!trained || trained.length === 0) {
    console.warn('selectInBoundsNoteConfusionAware: No trained PCs, skipping Step 4');
    // Fallback to uniform over last known trained set if available
    return usable && usable.length > 0 ? usable[Math.floor(Math.random() * usable.length)] : null;
  }
  
  if (trained.length === 1) {
    // H) If only one trained PC, weights = {trained[0]: 1} and anti-streak is moot
    state.conf.blockWeights = { [trained[0]]: 1.0 };
    state.conf.topPairAtBlockStart = null;
    state.conf.prevPc = trained[0];
    state.conf.runLen = (state.conf.runLen || 0) + 1;
    save();
    return trained[0];
  }
  
  initializeConfusionTracking();
  
  // Check if we need to compute weights at the start of a new 20-trial TrainingBlock
  // Fixed condition: check for start of block (every 20 trials) OR missing weights
  const isBlockStart = (state.trainingBlockTrials % 20) === 0;
  const hasNoWeights = !state.conf.blockWeights || Object.keys(state.conf.blockWeights).length === 0;
  
  if (isBlockStart || hasNoWeights) {
    computeBlockWeightsAtStart();
  }
  
  // Use frozen block weights with anti-streak rule
  return choosePcWithAntiStreak();
}

// G) Log confusion series data for completed training blocks (once per block)
function logConfusionSeriesData(blockIndex) {
  // Only log once per 20-trial training block (every block completion)
  
  // Create qa object if needed
  if (!window.qa) window.qa = {};
  if (!window.qa.confSeries) window.qa.confSeries = [];
  
  // G) Log the confusion series entry using frozen weights (keys must match trained)
  window.qa.confSeries.push({
    blockIndex: blockIndex,
    weights: {...(state.conf.blockWeights || {})},  // Copy to ensure keys match trained
    topConfusion: state.conf.topPairAtBlockStart
  });
}

/* ------------------ NEW OOB PRE-PLANNING SYSTEM ------------------ */

function initializeOobBlockPlan() {
  // Freeze the current target for this entire 20-trial Training Block
  state.oob.blockTarget = state.oob.targetPct;
  
  // Apply health check cap if active
  let effectiveTarget = state.oob.blockTarget;
  if (state.oobHealthCheckActive) {
    effectiveTarget = Math.min(effectiveTarget, 0.12); // Cap to 12%
  }
  
  // Compute planned OOB count for this block
  const plannedOOB = Math.round(effectiveTarget * 20);
  
  // Build the plan array with even distribution and streak guard
  state.oob.plan = createOobPlan(plannedOOB);
  
  // Pre-compute octave mix for this block based on current in-bounds octave proportions
  state.oob.planOctaveMix = createOctaveMixForBlock();
  
  // Reset block tracking
  state.oob.currentTrialInBlock = 0;
  
  save();
}

function createOobPlan(plannedOOB) {
  // Create array of 20 false values
  const plan = new Array(20).fill(false);
  
  // If no OOB planned, return all false
  if (plannedOOB === 0) {
    return plan;
  }
  
  // Distribute OOB trials evenly across the 20 slots
  // Use even spacing to avoid clustering
  const spacing = 20 / plannedOOB;
  
  let placed = 0;
  for (let i = 0; i < plannedOOB && placed < plannedOOB; i++) {
    let targetSlot = Math.floor(i * spacing);
    
    // Find next available slot that doesn't violate 2-in-a-row rule
    while (targetSlot < 20 && placed < plannedOOB) {
      if (canPlaceOobAt(plan, targetSlot)) {
        plan[targetSlot] = true;
        placed++;
        break;
      }
      targetSlot++;
    }
  }
  
  // If we couldn't place all planned OOB due to spacing constraints,
  // try to fill remaining slots from the end, respecting the 2-in-a-row rule
  for (let slot = 19; slot >= 0 && placed < plannedOOB; slot--) {
    if (!plan[slot] && canPlaceOobAt(plan, slot)) {
      plan[slot] = true;
      placed++;
    }
  }
  
  return plan;
}

function canPlaceOobAt(plan, slot) {
  // Check if placing OOB at this slot would create >2 in a row
  
  // Count consecutive OOB before this slot
  let beforeCount = 0;
  for (let i = slot - 1; i >= 0 && plan[i]; i--) {
    beforeCount++;
  }
  
  // Count consecutive OOB after this slot
  let afterCount = 0;
  for (let i = slot + 1; i < 20 && plan[i]; i++) {
    afterCount++;
  }
  
  // Check if placing here would create a streak > 2
  const totalStreak = beforeCount + 1 + afterCount;
  return totalStreak <= 2;
}

function createOctaveMixForBlock() {
  // Get octave distribution from current training block
  const totalInBounds = state.currentBlockOctaveCount[3] + state.currentBlockOctaveCount[4] + state.currentBlockOctaveCount[5];
  
  // If no in-bounds trials yet in this block, use equal distribution
  if (totalInBounds === 0) {
    const availableOctaves = currentOctaves();
    return availableOctaves.map(oct => ({ octave: oct, weight: 1.0 / availableOctaves.length }));
  }
  
  // Calculate proportions and only include octaves that have appeared
  const mix = [];
  const availableOctaves = currentOctaves();
  
  for (const octave of availableOctaves) {
    const count = state.currentBlockOctaveCount[octave] || 0;
    if (count > 0) {  // Only include octaves that haven't appeared in-bounds yet
      mix.push({ octave: octave, weight: count / totalInBounds });
    }
  }
  
  // If no octaves have appeared yet, fall back to equal distribution
  if (mix.length === 0) {
    return availableOctaves.map(oct => ({ octave: oct, weight: 1.0 / availableOctaves.length }));
  }
  
  return mix;
}

function sampleOctaveFromMix(octaveMix) {
  if (octaveMix.length === 0) {
    return rand(currentOctaves());
  }
  
  const randomValue = Math.random();
  let cumulative = 0;
  
  for (const item of octaveMix) {
    cumulative += item.weight;
    if (randomValue <= cumulative) {
      return item.octave;
    }
  }
  
  // Fallback to last item
  return octaveMix[octaveMix.length - 1].octave;
}

function shouldBeOobTrialNew() {
  // A) Enforce streak guard at scheduling time
  if (state.oob.streak >= 2) {
    return false; // FORCE in-bounds trial
  }
  
  // B) Use pre-planned OOB slots
  // Check if we're at the start of a new block and need to initialize plan
  if (state.oob.currentTrialInBlock === 0 || state.oob.plan.length === 0) {
    initializeOobBlockPlan();
  }
  
  // Get the planned decision for this trial position
  const trialIndex = state.oob.currentTrialInBlock;
  if (trialIndex >= 20) {
    // Safety check - shouldn't happen, but if it does, return false
    return false;
  }
  
  return state.oob.plan[trialIndex] === true;
}

function getOobCandidatesWithMirroring(set) {
  const baseOobs = currentOOBs(set);
  if (baseOobs.length === 0) return [];
  
  // Use pre-computed octave mix for this trial
  const targetOctave = sampleOctaveFromMix(state.oob.planOctaveMix);
  
  // For health check: prefer OOB chroma far from trained notes
  if (state.oobHealthCheckActive) {
    const trainedPcs = trainedSet(set);
    const trainedIndices = trainedPcs.map(pc => PC2I[pc]);
    
    const farOobs = baseOobs.filter(pc => {
      const pcIndex = PC2I[pc];
      return !trainedIndices.some(trainedIdx => {
        const dist = Math.min(
          Math.abs(pcIndex - trainedIdx),
          12 - Math.abs(pcIndex - trainedIdx)
        );
        return dist <= 1; // Avoid ¬±1 semitone
      });
    });
    
    const candidateList = farOobs.length > 0 ? farOobs : baseOobs;
    return {pc: rand(candidateList), octave: targetOctave};
  }
  
  return {pc: rand(baseOobs), octave: targetOctave};
}

function logTrainingBlockOobData(blockIndex, adaptBoundary) {
  // Calculate observed OOB% for this Training Block
  const blockTrials = state.trials.filter(t => 
    t.set === setFromIndex(state.levelIndex) && 
    t.block === blockFromIndex(state.levelIndex)
  );
  const oobTrials = blockTrials.filter(t => t.oob);
  const observedPct = blockTrials.length > 0 ? (oobTrials.length / blockTrials.length) : 0;
  
  // Push to qa.oobSeries (note: this creates qa object if it doesn't exist)
  if (!window.qa) window.qa = {};
  if (!window.qa.oobSeries) window.qa.oobSeries = [];
  
  // C) Use frozen block target in logging as specified
  window.qa.oobSeries.push({
    setIndex: setFromIndex(state.levelIndex),
    blockIndex: blockIndex,
    adaptBoundary: adaptBoundary,
    targetPct: state.oob.blockTarget,  // Use frozen-in-block value
    last60Acc: getTrainingBlockAcc60(),
    observedPctThisBlock: observedPct
  });
}

function updateOobStatusPillNew() {
  const targetPctDisplay = Math.round(100 * state.oob.targetPct);
  text('oobStatusPill', `OOB ${targetPctDisplay}%`);
}

function updateLevelUI(){
  const set=setFromIndex(state.levelIndex), block=blockFromIndex(state.levelIndex);
  text('setInfo', `Set ${set} / 12`);
  text('blockInfo', `Block ${block} / 24`);
  if(block >= 21){ text('accInfo', `Testing ‚Äî No Feedback`); }
  else{
    const req=(thresholdForIndex(state.levelIndex)*100).toFixed(0);
    const acc=((state.levelCorrect/state.levelTrials*100)||0).toFixed(0);
    text('accInfo', `Acc ${acc}% (req ${req}%)`);
  }
  text('delayInfo', `RT limit: ${rtWindowForSet(set)}ms ‚Ä¢ Delay: ${delayMs}ms`);
  
  // Update block time display with current/total format
  updateBlockTimeDisplay();
  
  // Update OOB status pill
  updateOobStatusPillNew();
}

function updateBlockTimeDisplay() {
  // Calculate blocks per set (24 blocks total, 5 blocks per set for timing purposes)
  const BLOCKS_PER_SET = 5;
  const currentTrainingBlock = ((state.currentBlock - 1) % BLOCKS_PER_SET) + 1;
  const blockTime = getBlockActiveTime();
  const blockTimeStr = fmtMMSS(blockTime);
  text('blockTimeInfo', `${currentTrainingBlock}/${BLOCKS_PER_SET} ${blockTimeStr}/6:00`);
}

/* Build note pad and attach handlers */
function paintNotes(){
  const pad=byId('notePad'); if(!pad) return; pad.innerHTML='';
  const set=setFromIndex(state.levelIndex);
  const learned = new Set(trainedSet(set));
  const sorted = PC.filter(pc=> learned.has(pc));
  for(const pc of sorted){
    const b=document.createElement('button');
    b.textContent=pcLabel(pc);
    b.dataset.pc=pc;
    b.className='note';
    b.type='button';
    b.addEventListener('click', ()=> guess(pc));
    pad.appendChild(b);
  }
  safe('btnOOB', el=> {
    el.style.display = set>=12 ? 'none' : 'block';
    el.onclick = ()=> chooseOOB();
  });
}

/* Shepard gating for tests */
function maybeRunShepard(){
  const blk=blockFromIndex(state.levelIndex);
  if(!blockHasFeedback(blk) && state.shepardDoneFor!==state.levelIndex){
    state.shepardDoneFor=state.levelIndex; save();
    return playShepard20s();
  }
  return Promise.resolve();
}

/* ---------- Specials at BLOCK 15 (weakest from last 15 blocks) ---------- */
function chooseWeakestFromLastBlocks(nBlocks=15){
  const set = setFromIndex(state.levelIndex);
  const curBlock = blockFromIndex(state.levelIndex);
  const from = Math.max(1, curBlock - (nBlocks - 1));
  const trained = new Set(trainedSet(set));
  const windowTrials = (state.trials||[]).filter(t =>
    t.set === set && t.block >= from && t.block <= curBlock && t.block >= 1 && t.block <= 20
  );
  const stats = new Map();
  for(const pc of trained) stats.set(pc, {ok:0, n:0, order:UNLOCK_ORDER.indexOf(pc)});
  for(const t of windowTrials){ if(!trained.has(t.pc)) continue; const s=stats.get(t.pc); s.n++; if(t.correct) s.ok++; }
  let pick=null;
  for(const [pc,s] of stats){
    if(pick===null) pick={pc,...s};
    else if(s.ok < pick.ok || (s.ok===pick.ok && s.n > pick.n) || (s.ok===pick.ok && s.n===pick.n && s.order < pick.order)) pick={pc,...s};
  }
  return pick ? pick.pc : UNLOCK_ORDER[Math.min(set-1, UNLOCK_ORDER.length-1)];
}
function startSpecialAtBlock15(){
  const set = setFromIndex(state.levelIndex);
  if(set < 5) return false;
  if(blockFromIndex(state.levelIndex) !== 15) return false;
  if(state.specialRanForLevel === state.levelIndex) return false;
  state.specialRanForLevel = state.levelIndex; save();

  const targetPc = chooseWeakestFromLastBlocks(15);
  special = {mode:'A', targetPc, total:12, done:0, withFeedback:true, correct:0};
  showSpecialUI(true, `Special A ‚Äî focus: ${pcLabel(targetPc)}`);
  text('btnTarget', `Target (${pcLabel(targetPc)})`);
  text('btnOther',  'Other (¬±2 semitones)');
  nextSpecialTrial(true);
  return true;
}
function showSpecialUI(show, label){
  if(show){
    showFlex('specialBar'); text('specialText', label||'Special Exercise');
    text('specialCount', '0 / 0');
    showBlock('binaryPad'); hide('notePad'); hide('btnOOB');
  }else{
    hide('specialBar'); hide('binaryPad'); showBlock('notePad');
    const set=setFromIndex(state.levelIndex);
    safe('btnOOB', el=> el.style.display = set>=12 ? 'none' : 'block');
  }
}
function nextSpecialTrial(){
  if(!special) return;
  const set=setFromIndex(state.levelIndex);
  const plusMinusTwoPitches = getPlusMinusTwoSemitones(special.targetPc);
  const isTarget = Math.random()<0.5;
  const pitchPc = isTarget ? special.targetPc : rand(plusMinusTwoPitches.filter(p => p !== special.targetPc));
  truePc = pitchPc; isOOBTrial = !isTarget;
  currentNote = `${pitchPc}${rand(currentOctaves())}`;
  playSample(currentNote);
  clearTimeout(rtTimer); rtTimer=null; // no RT in specials
  text('promptPill','Target or Other?');
  text('specialCount', `${special.done} / ${special.total}`);
}
function endSpecialOrAdvance(){
  if(!special) return;
  if(special.done >= special.total){
    if(special.mode==='A'){
      special = {mode:'B', targetPc: special.targetPc, total:22, done:0, withFeedback:false, correct:0};
      showSpecialUI(true, `Special B ‚Äî focus: ${pcLabel(special.targetPc)}`);
      text('btnTarget', `Target (${pcLabel(special.targetPc)})`);
      nextSpecialTrial();
    }else{
      const trials = (state.trials||[]).filter(t=> (t.special==='A' || t.special==='B') && t.pc===special.targetPc);
      const ok = trials.filter(t=> t.correct).length;
      const n  = trials.length;
      const pct = n ? Math.round((ok/n)*1000)/10 : 0;
      alert(`üéâ Hooray! You identified ${pcLabel(special.targetPc)} at ${pct}% accuracy.`);
      special = null; showSpecialUI(false);
      text('promptPill','Specials done ‚Äî press Play to continue');
      /* one-shot suppress strict modal after specials */
      suppressStrictOnce = true;
    }
  }
}
function answerSpecial(userSaysTarget){
  if(!special) return;
  const correct = (userSaysTarget && !isOOBTrial) || (!userSaysTarget && isOOBTrial);
  state.trials.push({note:currentNote, pc:truePc, guess:userSaysTarget?'TARGET':'OTHER', correct, timeout:false, oob:isOOBTrial, set:setFromIndex(state.levelIndex), block:0, time:Date.now(), special:special.mode});
  save();
  if(special.withFeedback){
    feedback(correct, correct ? undefined : (isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`));
  }
  if(correct) special.correct = (special.correct||0) + 1;
  special.done++; text('specialCount', `${special.done} / ${special.total}`);
  if(special.done >= special.total) { endSpecialOrAdvance(); return; }
  setTimeout(()=> nextSpecialTrial(), Math.max(500, delayMs));
}

/* ------------------ ASSESSMENT TEST ------------------ */
function startAssessment() {
  // Show warning modal first
  byId('assessmentWarningModal').style.display = 'flex';
}

function proceedWithAssessment() {
  // Hide warning modal and start assessment
  byId('assessmentWarningModal').style.display = 'none';
  
  showScreen('assessmentScreen');
  assessmentActive = false;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  text('assessmentProgress', 'Trial 0 / 20');
  text('assessmentPrompt', 'Press Start to begin assessment');
  hide('assessmentResults');
  
  populateAssessmentNotes();
}

function cancelAssessment() {
  byId('assessmentWarningModal').style.display = 'none';
}

function populateAssessmentNotes() {
  const pad = byId('assessmentPad');
  if (!pad) return;
  pad.innerHTML = '';
  
  for (const pc of PC) {
    const b = document.createElement('button');
    b.textContent = pcLabel(pc);
    b.dataset.pc = pc;
    b.className = 'note';
    b.type = 'button';
    b.addEventListener('click', () => assessmentGuess(pc));
    pad.appendChild(b);
  }
}

function beginAssessment() {
  assessmentActive = true;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  // Generate 20 random trials with random audio types and pitches
  for (let i = 0; i < 20; i++) {
    const audioTypes = [AUDIO_TYPES.PIANO, AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR];
    const randomAudioType = rand(audioTypes);
    const randomPc = rand(PC);
    
    // Use appropriate octave range for the audio type
    let octaves;
    if (randomAudioType === AUDIO_TYPES.GUITAR) {
      octaves = [3, 4, 5];
    } else {
      octaves = [4, 5, 6];
    }
    const randomOctave = rand(octaves);
    
    assessmentTrials.push({
      pc: randomPc,
      note: `${randomPc}${randomOctave}`,
      audioType: randomAudioType,
      answered: false,
      guess: null,
      correct: false
    });
  }
  
  nextAssessmentTrial();
}

async function nextAssessmentTrial() {
  if (assessmentCurrentTrial >= assessmentTrials.length) {
    completeAssessment();
    return;
  }
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  text('assessmentProgress', `Trial ${assessmentCurrentTrial + 1} / 20`);
  text('assessmentPrompt', 'Listening‚Ä¶ choose the pitch');
  
  // Temporarily change audio type for this trial
  const originalAudioType = state.audioType;
  state.audioType = trial.audioType;
  
  try {
    await playSample(trial.note);
  } finally {
    // Restore original audio type
    state.audioType = originalAudioType;
  }
}

function assessmentGuess(pc) {
  if (!assessmentActive || assessmentCurrentTrial >= assessmentTrials.length) return;
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  if (trial.answered) return;
  
  trial.answered = true;
  trial.guess = pc;
  trial.correct = (pc === trial.pc);
  
  assessmentCurrentTrial++;
  
  // Small delay before next trial
  setTimeout(() => {
    if (assessmentCurrentTrial < assessmentTrials.length) {
      nextAssessmentTrial();
    } else {
      completeAssessment();
    }
  }, 800);
}

function completeAssessment() {
  assessmentActive = false;
  
  let correct = 0;
  let nearMiss = 0; // Within ¬±1 semitone
  
  for (const trial of assessmentTrials) {
    if (trial.correct) {
      correct++;
    } else if (trial.guess) {
      const targetIdx = PC2I[trial.pc];
      const guessIdx = PC2I[trial.guess];
      const distance = Math.min(
        Math.abs(targetIdx - guessIdx),
        12 - Math.abs(targetIdx - guessIdx)
      );
      if (distance <= 1) {
        nearMiss++;
      }
    }
  }
  
  const exactPercent = Math.round((correct / 20) * 100);
  const nearMissPercent = Math.round((nearMiss / 20) * 100);
  
  // Store result
  const result = {
    date: Date.now(),
    exact: exactPercent,
    nearMiss: nearMissPercent,
    trials: assessmentTrials.slice()
  };
  
  state.assessmentScores.push(result);
  save();
  
  // Show results in modal
  const modalStats = byId('modalAssessmentStats');
  if (modalStats) {
    modalStats.innerHTML = `
      <div style="font-size:18px;margin:8px 0">
        <div><strong>Exact Correct: ${exactPercent}%</strong> (${correct}/20)</div>
        <div>Within ¬±1 semitone: ${nearMissPercent}% (${nearMiss}/20)</div>
      </div>
    `;
  }
  
  // Show results modal
  byId('assessmentResultsModal').style.display = 'flex';
  
  // Update chart if possible
  try { drawChart(); } catch(_) {}
}

/* ------------------ ASSESSMENT TRACKER ------------------ */
function showTracker() {
  showScreen('trackerScreen');
  updateTrackerDisplay();
  drawTrackerChart();
}

function updateTrackerDisplay() {
  const scores = state.assessmentScores || [];
  const count = scores.length;
  text('trackerCount', `${count} assessment${count === 1 ? '' : 's'}`);
  
  const history = byId('trackerHistory');
  if (!history) return;
  
  if (count === 0) {
    history.innerHTML = '<p style="opacity:0.7;text-align:center">No assessments completed yet</p>';
    return;
  }
  
  // Sort by date (most recent first)
  const sortedScores = [...scores].sort((a, b) => b.date - a.date);
  
  let html = '';
  sortedScores.forEach((score, index) => {
    const date = new Date(score.date).toLocaleDateString();
    const time = new Date(score.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    html += `
      <div style="padding:8px;margin:4px 0;border-radius:8px;background:var(--muted2);display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>${date} ${time}</strong>
        </div>
        <div>
          <span style="color:var(--good)">Exact: ${score.exact}%</span> ‚Ä¢ 
          <span style="color:var(--accent)">¬±1: ${score.nearMiss}%</span>
        </div>
      </div>
    `;
  });
  
  history.innerHTML = html;
}

function drawTrackerChart() {
  const canvas = byId('trackerCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  
  const P = {l: 56, r: 24, t: 16, b: 28};
  const AX = P.l, AY = P.t, AW = W - P.l - P.r, AH = H - P.t - P.b;
  
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  const colMuted = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.fillStyle = colCard;
  ctx.fillRect(0, 0, W, H);
  
  const scores = state.assessmentScores || [];
  if (scores.length === 0) {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
    ctx.font = '14px Fredoka, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No assessment data yet', W / 2, H / 2);
    return;
  }
  
  // Sort by date
  const sortedScores = [...scores].sort((a, b) => a.date - b.date);
  
  const maxTests = Math.max(10, sortedScores.length);
  const xScale = (i) => AX + (i / (maxTests - 1)) * AW;
  const yScale = (pct) => AY + AH - (pct / 100) * AH;
  
  // Draw grid lines
  ctx.strokeStyle = colMuted;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 100; i += 20) {
    const y = yScale(i);
    ctx.beginPath();
    ctx.moveTo(AX, y);
    ctx.lineTo(AX + AW, y);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(AX, AY);
  ctx.lineTo(AX, AY + AH);
  ctx.lineTo(AX + AW, AY + AH);
  ctx.stroke();
  
  // Draw Y-axis labels
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
  ctx.font = '12px Fredoka, sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 100; i += 20) {
    ctx.fillText(`${i}%`, AX - 8, yScale(i) + 4);
  }
  
  if (sortedScores.length > 1) {
    // Draw exact scores line
    const exactColor = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.beginPath();
    ctx.strokeStyle = exactColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.exact);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Draw near-miss scores line
    const nearMissColor = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.beginPath();
    ctx.strokeStyle = nearMissColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.nearMiss);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }
  
  // Draw data points
  sortedScores.forEach((score, i) => {
    const x = xScale(i);
    
    // Exact score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.exact), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.fill();
    
    // Near-miss score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.nearMiss), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.fill();
  });
}

/* -------- Normal trials -------- */
function guess(pc){
  if(!sessionActive || paused || shepRunning || special) return;
  if(!currentNote){ return; }
  if(!state.trialOpen) return; // Input locking - ignore late clicks
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  const isOOB = !!isOOBTrial;
  const clicked = pc;
  const correct = isOOB ? (clicked === 'OOB') : (clicked === truePc);
  recordTrial({ guess: clicked, correct: correct, timeout: false });
  feedback(correct, correct ? undefined : (isOOB ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`));
  currentNote = null; // Clear currentNote to prevent repeated guesses
  advanceCheck();
  scheduleAuto();
}
function chooseOOB(){
  if(!sessionActive || paused || shepRunning || special) return;
  if(!currentNote) return;
  if(!state.trialOpen) return; // Input locking - ignore late clicks
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  const isOOB = !!isOOBTrial;
  const clicked = 'OOB';
  const correct = isOOB ? (clicked === 'OOB') : (clicked === truePc);
  recordTrial({ guess: clicked, correct: correct, timeout: false });
  const msg = correct ? undefined : `Incorrect ‚Äî ${pcLabel(truePc)}`;
  feedback(correct, msg);
  currentNote = null; // Clear currentNote to prevent repeated guesses
  advanceCheck();
  scheduleAuto();
}

/* Driving */
function scheduleAuto(){ if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; } if(autoNext && sessionActive && !paused && !shepRunning && !special){ autoTimer = setTimeout(()=> nextTrial(true), delayMs); } }
async function nextTrial(forceNew=false){
  if(!sessionActive || paused || shepRunning || special) return;
  if(inFlightTrial) return;

  /* clear the one-shot strict suppression as soon as normal play resumes */
  suppressStrictOnce = false;

  if(startSpecialAtBlock15()) return;

  inFlightTrial=true;
  try{
    await resumeCtx();
    await maybeRunShepard();
    if(paused || !sessionActive || special) return;
    if(!currentNote || forceNew){
      // B) Schedule path must tag in-bounds/OOB explicitly
      const trained = getTrainedPCs();
      const isOOB = shouldBeOobTrialNew() && currentOOBs(setFromIndex(state.levelIndex)).length > 0;
      
      let truePc;
      if (isOOB) {
        truePc = pickOobPc(trained);
      } else {
        // Use confusion-aware scheduler for in-bounds
        const usable = trainedSet(setFromIndex(state.levelIndex));
        truePc = selectInBoundsNoteConfusionAware(usable) || (trained.length > 0 ? trained[Math.floor(Math.random() * trained.length)] : 'F'); // Fallback
      }
      
      // B) Create trial object with explicit tagging
      const trial = {
        truePc,  // the ground-truth pitch class being presented
        plannedOOB: !!isOOB,
        // ... (octave/timbre fields will be added)
      };
      
      // B) Before audio playback, set and freeze the oob flag - do NOT recalc later
      trial.oob = trial.plannedOOB;         // freeze this flag now
      if (trial.oob) {
        trial.detuneCents = 0; 
        trial.detuneMode = 'oob'; 
        trial.jlLevel = null;
        
        // Set octave for OOB
        const set = setFromIndex(state.levelIndex);
        const oobResult = getOobCandidatesWithMirroring(set);
        currentNote = `${truePc}${oobResult.octave}`;
      } else {
        // in-bounds: call chooseDetuneMode(truePc) and assign cents/mode/jlLevel
        const detuneInfo = selectDetune(truePc, false);
        trial.detuneCents = detuneInfo.cents;
        trial.detuneMode = detuneInfo.mode;
        trial.jlLevel = detuneInfo.jlLevel;
        
        const octave = rand(currentOctaves());
        currentNote = `${truePc}${octave}`;
      }
      
      // Store frozen trial state globally for grading to use
      isOOBTrial = trial.oob;  // This preserves the frozen flag
      currentDetuneCents = trial.detuneCents;
      currentDetuneMode = trial.detuneMode;
      currentJlLevel = trial.jlLevel;
      window.currentTrialState = trial;  // Store for recordTrial to use
    }
    
    await playSample(currentNote, currentDetuneCents);
    if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
    const baseRt = rtWindowForSet(setFromIndex(state.levelIndex));
    const rtms = baseRt + firstRtBonusMs + LATENCY_CUSHION_MS;
    firstRtBonusMs = 0;
    rtTimer = setTimeout(()=>handleTimeout(), rtms);
    
    // Update prompt pill with jitter level indicator (debug only)
    let promptText = 'Listening‚Ä¶ choose the pitch';
    if (!isOOBTrial && currentJlLevel !== null) {
      promptText += ` JL${currentJlLevel}`;
    }
    text('promptPill', promptText);
  }catch(e){ report(e); }
  finally{ inFlightTrial=false; }
}
function handleTimeout(){
  if(!sessionActive || paused || special) return;
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  recordTrial({ guess: null, correct: false, timeout: true });
  feedback(false, isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`);
  advanceCheck(); scheduleAuto();
}

/* Suggestion banner */
function hideSuggestBanner(){ hide('suggestBanner'); }
function showSuggestBanner(){ const set = setFromIndex(state.levelIndex); if(state.suggestShownSet === set) return; byId('suggestBanner').style.display='flex'; }
function restartCurrentSet(){
  const set = setFromIndex(state.levelIndex);
  state.levelIndex = (set-1)*LEVELS_PER_SET + 1;
  state.levelTrials = 0; state.levelCorrect = 0;
  state.shepardDoneFor = -1; state.testFailStreak = 0;
  state.suggestShownSet = null; save();
  updateLevelUI(); paintNotes();
  text('promptPill', `Restarted Set ${set}. Press Play to begin.`);
  hideSuggestBanner();
}
function maybeSuggestRestart(){
  const block = blockFromIndex(state.levelIndex);
  if(block < 21){ state.testFailStreak = 0; hideSuggestBanner(); suggestedRestartFlag=false; save(); return; }
  if(state.testFailStreak >= 10 && !suggestedRestartFlag){ suggestedRestartFlag = true; showSuggestBanner(); }
}

function recordTrial(trial) {
  // Close the trial immediately to prevent late clicks
  state.trialOpen = false;
  
  // Calculate reaction time
  let rtMs = trial.rtMs;
  if (rtMs == null) {
    rtMs = performance.now() - (state.toneStartMs || performance.now());
  }
  
  // C) Grading must NOT change oob flag - keep the oob flag that was frozen at scheduling time
  // Use the frozen trial state from scheduling, don't recompute oob
  const frozenTrial = window.currentTrialState || {};
  const isOOB = frozenTrial.oob !== undefined ? frozenTrial.oob : !!isOOBTrial;
  const clicked = trial.guess;
  
  // C) Only compute correctness from guess vs truePc
  const correct = isOOB ? (clicked === 'OOB') : (clicked === truePc);
  
  // Update counters
  state.levelTrials++;
  if(correct) state.levelCorrect++;
  state.trainingBlockTrials++;
  
  const block = blockFromIndex(state.levelIndex);
  if(block >= 21){ 
    if(correct){ 
      state.testFailStreak=0; 
      hideSuggestBanner(); 
      suggestedRestartFlag=false; 
    } else { 
      state.testFailStreak=(state.testFailStreak||0)+1; 
    } 
  } else { 
    state.testFailStreak=0; 
    hideSuggestBanner(); 
    suggestedRestartFlag=false; 
  }
  
  // C) Create trial record preserving frozen oob flag and detune info from scheduling
  const trialRecord = {
    note: currentNote, 
    pc: truePc, 
    guess: clicked, 
    correct: correct, 
    timeout: trial.timeout || false, 
    oob: isOOB,  // Use the frozen flag, not recomputed
    set: setFromIndex(state.levelIndex), 
    block: block, 
    time: Date.now(),
    rtMs: rtMs,
    // Jitter system fields - use frozen values from scheduling
    detuneCents: frozenTrial.detuneCents !== undefined ? frozenTrial.detuneCents : currentDetuneCents,
    detuneMode: frozenTrial.detuneMode || currentDetuneMode,
    jlLevel: frozenTrial.jlLevel !== undefined ? frozenTrial.jlLevel : currentJlLevel,
    timbreUsed: state.audioType
  };
  
  state.trials.push(trialRecord);
  
  // D) Update confusion tracking ONLY for in-bounds trials in trained set
  if (!isOOB && !trial.timeout && clicked !== null && truePc) {
    const trainedPcs = getTrainedPCs();
    
    // Only track if both true and guess are in the trained set
    if (trainedPcs.includes(truePc) && (clicked === 'OOB' || trainedPcs.includes(clicked))) {
      // Update confusion matrix on errors
      if (!correct && clicked !== 'OOB') {
        updateConfusionMatrix(truePc, clicked);
      }
      
      // Update per-note performance stats
      updatePerfStats(truePc, correct, rtMs);
      
      // Update last in-bounds PC for anti-streak
      state.lastInBoundsPc = truePc;
      
      // Add top confusion pair to trial record for logging
      if (state.conf.topPairAtBlockStart) {
        trialRecord.confTopPairAtTime = state.conf.topPairAtBlockStart;
      }
    }
  }
  
  // D) Update jitter statistics ONLY for in-bounds trials with trained PCs
  if (!isOOB) {
    const trainedPcs = getTrainedPCs();
    if (trainedPcs.includes(truePc)) {
      addJitterStat(truePc, correct, rtMs);
      evaluateJitterLevel(truePc);
    }
  }
  
  // Update new OOB controller with this trial
  updateTrainingBlockOobController(trialRecord);
  
  save(); updateLevelUI(); try{ drawChart(); }catch(_){}; 
  if(block >= 21 && !correct) maybeSuggestRestart();
}

function feedback(ok, wrongMsgOverride){
  const fb=blockHasFeedback(blockFromIndex(state.levelIndex));
  if(!fb && !special?.withFeedback) return;
  const box=byId('feedbackBox'); const overlay=byId('feedbackOverlay');
  if(!box||!overlay) return;
  box.style.background= ok? 'var(--good)':'var(--bad)';
  if(ok) box.textContent = 'Correct!';
  else   box.textContent = wrongMsgOverride || 'Incorrect';
  overlay.style.display='flex'; requestAnimationFrame(()=>overlay.classList.add('show'));
  setTimeout(()=>{ overlay.classList.remove('show'); overlay.style.display='none'; }, 500);
}

function advanceCheck(){
  if(state.levelTrials<20) return;
  const acc=state.levelCorrect/state.levelTrials, need=thresholdForIndex(state.levelIndex);
  const passed = acc>=need;
  const block = blockFromIndex(state.levelIndex);
  const key = String(state.levelIndex);
  
  // Training Block completed - handle adaptive OOB
  const adaptBoundary = adaptOobTargetAtTrainingBlockBoundary(block);
  logTrainingBlockOobData(block, adaptBoundary);
  updateOobHealthCheckTrainingBlock();
  updateOobStatusPillNew();
  
  // Log confusion series data
  logConfusionSeriesData(block);
  
  // Reset training block counters
  state.trainingBlockTrials = 0;
  state.currentBlockOctaveCount = {3: 0, 4: 0, 5: 0};
  
  // Reset OOB plan for next block
  state.oob.currentTrialInBlock = 0;
  state.oob.plan = [];
  state.oob.planOctaveMix = [];
  
  // Show feedback for test blocks (21-24) at completion
  if(block >= 21) {
    const percentage = Math.round(acc * 100);
    if(passed) {
      alert(`Well done, you passed with ${percentage}%!`);
    } else {
      // Suppress strict modal during failure dialogs
      suppressStrictOnce = true;
      alert(`Sorry you didn't make it with ${percentage}%.`);
      
      // Check for 10-fail streak and show struggle suggestion
      if(state.testFailStreak >= 10) {
        const confirmed = confirm(`Struggling? Perhaps go back to the start of set?\n\nClick OK to restart the set, or Cancel to dismiss and try again.`);
        if(confirmed) {
          restartCurrentSet();
          return;
        }
      }
      // Keep suppression active after dialogs
      suppressStrictOnce = true;
    }
  }
  
  if(!passed){
    state.levelFailCounts[key] = (state.levelFailCounts[key]||0) + 1;
    if(state.levelFailCounts[key] >= 10){
      if(confirm('You‚Äôve attempted this level 10+ times without passing. Drop to a lower level?')){
        if(state.levelIndex>1) state.levelIndex--;
        state.levelTrials=0; state.levelCorrect=0; state.shepardDoneFor=-1;
        save(); updateLevelUI(); paintNotes();
        alert('Dropped one level. Keep going!');
        return;
      }
    }
  }else{
    state.levelFailCounts[key]=0;
  }
  state.levelTrials=0; state.levelCorrect=0;
  if(passed && state.levelIndex<LEVELS_TOTAL){
    const oldSet = setFromIndex(state.levelIndex);
    state.levelIndex++;
    state.trainingBlockIndex++;  // Advance training block
    const newSet = setFromIndex(state.levelIndex);
    save(); updateLevelUI(); paintNotes();
    
    // Check if we're moving to a new set (new pitch introduced)
    if(newSet > oldSet && newSet <= UNLOCK_ORDER.length){
      showNewPitchModal(newSet);
    }
    // Note: Removed startFlappyReward() - Flappy only opens from TimeBlock breaks
  } else save();
}

/* ------------------ SESSION ------------------ */
function startSession(){
  stopAllTimers();
  sealDanglingSession();
  if(isLocked()){
    const left = state.lockoutUntil - Date.now();
    alert(`Training is locked for ${fmtHMM(left)}.\nYou can still play Flappy from the menu, or Reset lockout/timer.`);
    showScreen('menuScreen'); return;
  }
  showScreen('trainerScreen');
  if(!state.startDate) state.startDate=Date.now();
  ensureWeekRoll();
  sessionActive=true; paused=false;
  (state.sessions||[]).push({start:Date.now(),end:null,pauses:[],completed:false}); 
  
  // C) On entering Trainer screen: do NOT reset activeMs; if running, resume from startedAt; otherwise show the current elapsed.
  if (!state.timeblock.breakActive) {
    if (state.timeblock.running) {
      // Resume from where we left off
      state.timeblock.startedAt = performance.now();
    }
    // Do not reset activeMs - it persists across navigation
    startTimeBlockTimer();
  }
  
  state.lastSeen = Date.now(); save();
  updateCapsUI(); updateLevelUI(); paintNotes();
  text('promptPill','Press Play to start');
  stopAllTimers();
  tickId=setInterval(()=>{
    ensureWeekRoll();
    if(sessionActive && !paused && !shepRunning){ 
      state.thisWeekMs = (state.thisWeekMs||0) + 1000; 
      save(); 
    }
    
    if(sessionActive && !paused){
      // Update total time display  
      const left = Math.max(0, SESS_DAILY_MS - msUsedQuota());
      text('timerInfo', `Left: ${fmtMMSS(left)}`);
      
      if(left<=0){
        endDayAndLockout();
      }
    }
    
    // Handle TimeBlock break countdown
    if (state.timeblock.breakActive && state.timeblock.breakEndsAt) {
      updateTimeBlockBreakUI();
      
      const now = Date.now();
      if (now >= state.timeblock.breakEndsAt) {
        // Check if Flappy round has ended
        if (!running) {
          // No flappy game running, end break automatically
          endTimeBlockBreakAndCloseModal();
        }
        // If flappy is still running, let user continue but show message
      }
    }
    
    updateCapsUI(); 
    try { drawChart(); } catch(_) {}
  },1000);
}
function endSession(auto){
  if(!sessionActive) return;
  sessionActive=false;
  stopAllTimers();
  const rec=state.sessions[state.sessions.length-1]; if(rec && !rec.end) rec.end=Date.now();
  save(); updateCapsUI(); try{ drawChart(); }catch(_){};
  if(auto){
    const left = state.lockoutUntil ? fmtHMM(state.lockoutUntil - Date.now()) : 'some time';
    alert(`Cap reached. Locked for ${left}.`);
  }
}
function pauseStart(reason){
  const rec=state.sessions[state.sessions.length-1]; if(!rec) return;
  rec.pauses=rec.pauses||[]; const last=rec.pauses[rec.pauses.length-1];
  if(!(last && !last.end)) rec.pauses.push({start:Date.now(), end:null, reason});
  paused=true;
  // Pause TimeBlock timer when training pauses (but don't reset activeMs)
  if (reason !== 'timeblock-break') {
    pauseTimeBlockTimer();
  }
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
}
function pauseEnd(){
  const rec=state.sessions[state.sessions.length-1]; if(!rec||!rec.pauses||!rec.pauses.length) return;
  const last=rec.pauses[rec.pauses.length-1]; if(last && !last.end) last.end=Date.now();
  paused=false;
  // Resume TimeBlock timer when training resumes
  if (!state.timeblock.breakActive) {
    startTimeBlockTimer();
  }
}
function pauseResume(){
  if(!sessionActive) return;
  if(paused){ pauseEnd(); safe('btnPause', el=> el.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else if(currentNote){ nextTrial(false); } }
  else { safe('btnPause', el=> el.textContent='‚ñ∂ Resume'); pauseStart('user'); }
}

/* ------------------ QUOTA ------------------ */
function quotaStart(){ if(state.capResetAt && Date.now() >= state.capResetAt) return state.capResetAt; const d = new Date(); d.setHours(0,0,0,0); return d.getTime(); }
function msUsedQuota(){ const start = quotaStart(); return (state.sessions || []).filter(s => s.start >= start).reduce((a, s) => a + activeDuration(s), 0); }

/* ------------------ JITTER SYSTEM ------------------ */

// Initialize jitter level for a pitch class if not exists
function initJitterForPc(pc) {
  if (!state.jitter.levelByPc[pc]) {
    state.jitter.levelByPc[pc] = 0; // Start at JL0
  }
  if (!state.jitter.statsByPc[pc]) {
    state.jitter.statsByPc[pc] = {
      last40: [],
      acc: 0,
      medianCents: 0,
      sdCents: 0
    };
  }
}

// Get jitter level for a pitch class
function getJitterLevel(pc) {
  initJitterForPc(pc);
  return state.jitter.levelByPc[pc];
}

// Add a trial result to the per-PC statistics  
function addJitterStat(pc, correct, rtMs) {
  initJitterForPc(pc);
  const stats = state.jitter.statsByPc[pc];
  
  // Add to last40 array
  stats.last40.push({ correct, rtMs, time: Date.now() });
  
  // Keep only last 40 in-bounds trials
  if (stats.last40.length > 40) {
    stats.last40 = stats.last40.slice(-40);
  }
  
  // Recalculate statistics
  updateJitterStats(pc);
}

// Update calculated statistics for a pitch class
function updateJitterStats(pc) {
  const stats = state.jitter.statsByPc[pc];
  if (!stats || stats.last40.length === 0) return;
  
  // Calculate accuracy
  const correct = stats.last40.filter(t => t.correct).length;
  stats.acc = correct / stats.last40.length;
  
  // Use simple error proxy as specified: 0 for correct, 100 for incorrect
  const errors = stats.last40.map(t => t.correct ? 0 : 100);
  
  // Calculate median
  const sorted = [...errors].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  stats.medianCents = sorted.length % 2 === 0 ? 
    (sorted[mid - 1] + sorted[mid]) / 2 : 
    sorted[mid];
    
  // Calculate standard deviation
  const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
  const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
  stats.sdCents = Math.sqrt(variance);
}

// Evaluate promotion/demotion for a pitch class
function evaluateJitterLevel(pc) {
  const stats = state.jitter.statsByPc[pc];
  if (!stats || stats.last40.length < 20) return; // Need at least 20 trials
  
  const currentLevel = getJitterLevel(pc);
  const acc = stats.acc;
  
  let newLevel = currentLevel;
  
  // Demote (rescue) if accuracy < 0.75
  if (acc < 0.75) {
    newLevel = Math.max(0, currentLevel - 1);
  }
  // Promotion conditions (require at least 20 in last-40)
  else if (currentLevel === 0 && acc >= 0.75) {
    newLevel = 1;
  }
  else if (currentLevel === 1 && acc >= 0.80) {
    newLevel = 2;
  }
  else if (currentLevel === 2 && acc >= 0.90) {
    newLevel = 3;
  }
  
  // Clamp to valid range [0,3]
  newLevel = Math.max(0, Math.min(3, newLevel));
  
  if (newLevel !== currentLevel) {
    state.jitter.levelByPc[pc] = newLevel;
    console.log(`Jitter level change for ${pcLabel(pc)}: JL${currentLevel} -> JL${newLevel} (acc=${(acc*100).toFixed(1)}%)`);
    save();
  }
}

// Create a function chooseDetuneMode(pc) that returns "anchor" | "probe" | "jitter"
function chooseDetuneMode(pc) {
  const L = state.jitter.levelByPc[pc] || 0;
  const specs = JITTER_LEVELS[L];
  
  const rand = Math.random();
  
  // Use cumulative probability sampling
  if (rand < specs.anchorRate) {
    return 'anchor';
  }
  if (rand < specs.anchorRate + specs.probeRate) {
    return 'probe';  
  }
  return 'jitter';
}

// Export chooseDetuneMode to window for debugging and validation
window.chooseDetuneMode = chooseDetuneMode;

// Select detune mode and value for a trial
function selectDetune(pc, isOOB) {
  // OOB trials always get no detune
  if (isOOB) {
    return {
      cents: 0,
      mode: 'oob',
      jlLevel: null
    };
  }
  
  // Get jitter level and choose mode
  const level = getJitterLevel(pc);
  const mode = chooseDetuneMode(pc);
  const specs = JITTER_LEVELS[level];
  
  if (mode === 'anchor') {
    return {
      cents: 0,
      mode: 'anchor',
      jlLevel: level
    };
  }
  
  if (mode === 'probe') {
    const sign = Math.random() < 0.5 ? -1 : 1;
    const cents = sign * (25 + Math.random() * 15); // ¬±25..¬±40¬¢
    return {
      cents: cents,
      mode: 'probe',
      jlLevel: level
    };
  }
  
  // Jitter mode
  const sign = Math.random() < 0.5 ? -1 : 1;
  const cents = sign * (specs.jitterMin + Math.random() * (specs.jitterMax - specs.jitterMin));
  return {
    cents: cents,
    mode: 'jitter',
    jlLevel: level
  };
}

/* ------------------ BLOCK SYSTEM ------------------ */
function getBlockActiveTime() {
  if (!state.blockStartTime) return 0;
  const now = Date.now();
  const rec = state.sessions[state.sessions.length - 1];
  if (!rec) return 0;
  
  // Calculate active time in current block (excluding pauses)
  let totalPauseTime = 0;
  if (rec.pauses) {
    rec.pauses.forEach(p => {
      const pStart = Math.max(p.start, state.blockStartTime);
      const pEnd = p.end ? Math.min(p.end, now) : now;
      if (pStart < pEnd) totalPauseTime += pEnd - pStart;
    });
  }
  
  return Math.max(0, now - state.blockStartTime - totalPauseTime);
}

function startNewBlock() {
  state.blockStartTime = Date.now();
  state.inBreak = false;
  state.breakStartTime = null;
  save();
}

function checkBlockCompletion() {
  // D) Disabled legacy block system - Flappy modal is opened ONLY from beginTimeBlockBreak()
  // This legacy block system is replaced by the 6-minute TimeBlock system
  return;
}

/* D) Removed legacy block system functions - only TimeBlock system should trigger Flappy */

/* D) Removed updateBreakUI - legacy function, now using updateTimeBlockBreakUI */

/* ------------------ PROGRESS / CHARTS ------------------ */
function eightWeekBins(pitch){
  const t0=todayKey(Date.now());
  const bins=[];
  for(let w=1; w<=8; w++){ const start=t0 - (w-1)*7*86400000; const end=start+7*86400000; bins.push({w,start,end,n:0,ok:0}); }
  const oldest=bins[7].start;
  const trials=(state.trials||[]).filter(tr=>{
    const d=dateAtMidnight(tr.time);
    return d>=oldest && d<bins[0].end && (pitch==='OVERALL'|| tr.pc===pitch);
  });
  for(const tr of trials){
    const d=dateAtMidnight(tr.time);
    const daysAgo=Math.floor((t0 - d)/86400000);
    const w=Math.floor(daysAgo/7)+1;
    const idx=Math.min(8,Math.max(1,w))-1;
    const b=bins[idx]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function thisWeekBins(pitch){
  const ws = weekStartTs();
  const bins=[];
  for(let i=0;i<7;i++){ bins.push({day:i+1,start:ws+i*86400000,end:ws+(i+1)*86400000,n:0,ok:0}); }
  const trials=(state.trials||[]).filter(tr=> tr.time>=ws && tr.time<ws+7*86400000 && (pitch==='OVERALL'|| tr.pc===pitch));
  for(const tr of trials){
    const day = Math.floor((dateAtMidnight(tr.time) - ws)/86400000);
    const b = bins[Math.max(0, Math.min(6, day))]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function drawLine(ctx, pts, color, xscale, yscale){ ctx.beginPath(); let started=false; for(const p of pts){ if(p.y===null) continue; const x=xscale(p.x), y=yscale(p.y); if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y); } if(!started) return; ctx.strokeStyle=color; ctx.lineWidth=2.5; ctx.stroke(); }
function drawDot(ctx, x, y, color, r=6){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); }
function drawChart(){
  const canvas = byId('progressCanvas'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  const P={l:56,r:24,t:16,b:28}; const AX=P.l, AY=P.t, AW=W-P.l-P.r, AH=H-P.t-P.b;
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  ctx.fillStyle=colCard; ctx.fillRect(0,0,W,H);
  const mode=byId('granularitySelect')?.value||'WEEKLY';
  const pitch=byId('pitchSelect')?.value||'OVERALL';
  const colGood=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a';
  const colNeutral=getComputedStyle(document.documentElement).getPropertyValue('--neutral')||'#94a3b8';
  const colMuted=getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#334155';
  const colText=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb';
  const yscale=(v)=> AY + AH - (v/100)*AH;

  /* Y grid + labels */
  ctx.strokeStyle=colMuted; ctx.lineWidth=1; ctx.beginPath();
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy); ctx.moveTo(AX,y); ctx.lineTo(AX+AW,y);} ctx.stroke();
  ctx.fillStyle=colText; ctx.font='12px system-ui,sans-serif';
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy)+4; ctx.fillText(String(gy)+'%', 8, y); }

  if(mode==='WEEKLY'){
    const bins=thisWeekBins(pitch);
    const xscale=(d)=> AX + ((d - 1)/(7 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.fillText(`Day ${d}`, x-18, H-6); }
    const pts=bins.map(b=> b.n===0? {x:b.day,y:null}:{x:b.day,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const b of bins){
      if(b.n>0) drawDot(ctx,xscale(b.day), yscale(Math.round((b.ok/b.n)*1000)/10), colGood, 6);
      else      drawDot(ctx,xscale(b.day), yscale(0), colNeutral, 5);
    }
  } else {
    const weeks=eightWeekBins(pitch);
    const xscale=(w)=> AX + ((w - 1)/(8 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.fillText(`Week ${w}`, x-22, H-6); }
    const pts=weeks.map(b=> b.n===0? {x:b.w,y:null}:{x:b.w,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const p of weeks){
      if(p.n>0) drawDot(ctx,xscale(p.w), yscale(Math.round((p.ok/p.n)*1000)/10), colGood, 5);
      else      drawDot(ctx,xscale(p.w), yscale(0), colNeutral, 4);
    }
  }
  ctx.fillStyle=colText; ctx.font='13px system-ui,sans-serif';
  const label=(pitch==='OVERALL')?'Overall':`Pitch: ${pcLabel(pitch)}`;
  ctx.fillText(label, AX, AY-2);
}

/* Pitch dropdown + view toggle */
function populatePitchSelect(){
  const sel = byId('pitchSelect'); if(!sel) return;
  sel.innerHTML='';
  const mk=(v,t)=>{ const o=document.createElement('option'); o.value=v; o.textContent=t; return o; };
  sel.appendChild(mk('OVERALL','Overall'));
  PC.forEach(pc=> sel.appendChild(mk(pc, pcLabel(pc))));
  sel.onchange = ()=> drawChart();
  const gran = byId('granularitySelect'); if(gran){ gran.onchange = ()=> drawChart(); gran.value='WEEKLY'; }
}

/* ------------------ TUTORIAL PAGER ------------------ */
let tIndex = 0;
function setTutorialPage(i){
  tIndex = Math.max(0, Math.min(5, i));
  ['tPage1','tPage2','tPage3','tPage4','tPage5','tPage6'].forEach((id, idx)=>{
    const el = byId(id);
    if(el) el.classList.toggle('active', idx===tIndex);
  });
  const back = byId('tBack'); if(back) back.style.visibility = (tIndex===0 ? 'hidden' : 'visible');
  const next = byId('tNext'); if(next) next.textContent = (tIndex===5 ? 'Got it' : 'Next ‚ñ∂');
}
function nextTutorial(){ if(tIndex<5){ setTutorialPage(tIndex+1); return; } hide('welcomeModal'); showScreen('menuScreen'); updateCapsUI(); populatePitchSelect(); drawChart(); }
function prevTutorial(){ setTutorialPage(tIndex-1); }

/* ------------------ WIRING ------------------ */
function wireOnce(){
  sealDanglingSession();
  try{ populatePitchSelect(); drawChart(); }catch(_){}
  
  // E) Preload flappy audio on app init
  preloadFlappyAudio();
  
  // Start
  safe('startBtn', el=> el.onclick=()=>{
    const name=(byId('userNameInput')?.value||'').trim()||'Player';
    state.userName=name; save();
    safe('greeting', g=> g.textContent=`Hello ${state.userName}!`);
    showFlex('welcomeModal'); setTutorialPage(0);
  });
  safe('tNext', el=> el.onclick=()=> nextTutorial());
  safe('tBack', el=> el.onclick=()=> prevTutorial());

  // Menu
  safe('menuStart',   el=> el.onclick=()=> startSession());
  safe('startAssessment', el=> el.onclick=()=> startAssessment());
  safe('viewTracker', el=> el.onclick=()=> showTracker());
  safe('playFlappy',  el=> el.onclick=()=> openFlappyFromMenu());
  safe('resetLockout',el=> el.onclick=()=>{
    if(!confirm('Reset lockout/timer now? This starts a fresh 30-minute window immediately.')) return;
    state.lockoutUntil = null; state.capResetAt = Date.now(); state.lastSeen = Date.now();
    // Reset block system
    state.currentBlock = 1;
    state.blockStartTime = null;
    state.inBreak = false;
    state.breakStartTime = null;
    save(); updateCapsUI(); alert('Timer reset. You can start training now.');
  });
  safe('menuReset',   el=> el.onclick=()=> doFactoryReset());

  // Assessment warning modal
  safe('btnProceedAssessment', el=> el.onclick=()=> proceedWithAssessment());
  safe('btnCancelAssessment', el=> el.onclick=()=> cancelAssessment());
  
  // Assessment results modal
  safe('btnRetakeAssessmentModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    proceedWithAssessment();
  });
  safe('btnBackMenuModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    showScreen('menuScreen'); 
    populatePitchSelect(); 
    drawChart();
  });

  // Assessment screen
  safe('btnStartAssessment', el=> el.onclick=()=> beginAssessment());
  safe('btnBackMenuAssessment', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });
  safe('btnRetryAssessment', el=> el.onclick=()=> { hide('assessmentResults'); beginAssessment(); });
  safe('btnBackMenuFromResults', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Tracker screen
  safe('btnBackMenuTracker', el=> el.onclick=()=> { showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Set selector
  safe('setSizeSelect', sel=>{
    if(!sel.options.length){
      for(let i=1;i<=SETS;i++){
        const o=document.createElement('option');
        o.value=i; o.textContent=`${i} ${i===1?'pitch':'pitches'}`;
        sel.appendChild(o);
      }
    }
    sel.value = String(setFromIndex(state.levelIndex));
  });
  safe('applySetBtn', el=> el.onclick=()=>{
    const v = parseInt(byId('setSizeSelect')?.value||'1',10)||1;
    state.levelIndex=(v-1)*LEVELS_PER_SET+1; state.levelTrials=0; state.levelCorrect=0; state.shepardDoneFor=-1; state.testFailStreak=0; suggestedRestartFlag=false; state.suggestShownSet=null; save();
    alert(`Scope set to ${v} ${v===1?'pitch':'pitches'} (Block 1/24)`); paintNotes();
  });

  // Audio type selection
  safe('audioTypeSelect', el=> {
    el.value = state.audioType || AUDIO_TYPES.PIANO;
  });
  safe('applyAudioBtn', el=> el.onclick=()=>{
    const newType = byId('audioTypeSelect')?.value || AUDIO_TYPES.PIANO;
    state.audioType = newType;
    save();
    const labels = {
      [AUDIO_TYPES.PIANO]: 'Piano (C4-B6)',
      [AUDIO_TYPES.SINE]: 'Sine Wave (C4-B6)', 
      [AUDIO_TYPES.GUITAR]: 'Guitar (C3-B5)'
    };
    alert(`Audio changed to ${labels[newType] || 'Piano'}`);
  });

  // Theme selection
  safe('themeSelect', el=> {
    el.value = state.theme || 'default';
  });
  safe('applyThemeBtn', el=> el.onclick=()=>{
    const newTheme = byId('themeSelect')?.value || 'default';
    state.theme = newTheme;
    save();
    applyTheme(newTheme);
    const themeName = THEMES[newTheme]?.name || 'Dark Ocean';
    alert(`Theme changed to ${themeName}`);
  });

  // Flappy sound selection
  safe('flappySoundSelect', el=> {
    el.value = state.flappyMuted ? 'muted' : 'enabled';
  });
  safe('applyFlappySoundBtn', el=> el.onclick=()=>{
    const newSetting = byId('flappySoundSelect')?.value || 'enabled';
    state.flappyMuted = (newSetting === 'muted');
    save();
    alert(`Flappy sound ${state.flappyMuted ? 'muted' : 'enabled'}`);
  });

  // Trainer controls
  safe('btnPlay',        el=> el.onclick=async()=>{ firstRtBonusMs=2000; await resumeCtx(); if(paused){ pauseEnd(); } safe('btnPause', b=> b.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else nextTrial(true); });
  safe('btnPause',       el=> el.onclick=()=> pauseResume());
  safe('btnBackMenu',    el=> el.onclick=()=>{
    if(sessionActive){ if(!paused) pauseStart('user-leave'); openStrictModal(); }
    else { showScreen('menuScreen'); populatePitchSelect(); drawChart(); }
  });
  safe('btnToggleAuto',  el=> el.onclick=()=>{
    autoNext=!autoNext; text('autoInfo',`Auto-next: ${autoNext?'On':'Off'}`);
    const sl=byId('delaySlider'); if(sl){ sl.disabled=!autoNext; sl.classList.toggle('disabled', !autoNext); }
    if(!autoNext && autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
  });
  safe('delaySlider', sl=>{
    sl.disabled=true; sl.classList.add('disabled');
    sl.oninput=(e)=>{ delayMs=parseInt(e.target.value,10)||0; updateLevelUI(); };
  });

  // Specials
  safe('btnTarget',el=> el.onclick=()=> answerSpecial(true));
  safe('btnOther', el=> el.onclick=()=> answerSpecial(false));

  // Strict modal buttons
  safe('btnStrictResume', el=> el.onclick=()=>{ closeStrictModal(); showScreen('trainerScreen'); });
  safe('btnStrictMenu',   el=> el.onclick=()=>{ closeStrictModal(); showScreen('menuScreen'); });

  // New pitch modal buttons
  safe('btnHearNewPitch', el=> el.onclick=async()=>{ 
    const pitch = UNLOCK_ORDER[setFromIndex(state.levelIndex) - 1];
    await playNewPitchDemo(pitch); 
  });
  safe('btnContinueTraining', el=> el.onclick=()=>{ 
    closeNewPitchModal(); 
    // D) Removed startFlappyReward() - Flappy only opens from TimeBlock breaks
  });

  // Initial screen
  if(!state.userName){ showScreen('startScreen'); }
  else { safe('greeting', g=> g.textContent=`Hello ${state.userName}!`); showScreen('menuScreen'); updateCapsUI(); }
}

/* ------------------ FLAPPY ------------------ */
let fCtx, flappyRAF=null, running=false, score=0, pipes=[], bird, pipeTimer=0, lastTs=null;

/* Flappy now: start with bigger gap, shrink over first 5 pipes, then keep constant.
   Speed still scales with score. */
const FLAPPY = { gravity:900, flap:-380, baseSpeed:140, maxSpeed:260, speed:140, baseGap:140, gap:140, introPipes:5, introExtra:60, spawnEvery:1.20, width:52 };

function openFlappyFromMenu(){ 
  if(isLocked()) {
    openFlappyModal(); 
  } else if (state.inBreak && sessionActive) {
    // Allow reopening flappy during breaks
    openFlappyModal();
  } else {
    alert('Flappy is intended for lockout/rewards.'); 
  }
}
function openFlappyModal(){ 
  byId('flappyModal').style.display='flex'; 
  const c=byId('flappyCanvas'); 
  if(!c) return; 
  fCtx=c.getContext('2d'); 
  resetFlappy(); 
  attachFlappyControls();
  
  // Show sound toggle button and update description during breaks or lockout
  const soundToggle = byId('flappySoundToggle');
  const description = byId('flappyModal').querySelector('p:last-child');
  
  // Always show sound toggle and update it based on current state
  if (soundToggle) {
    soundToggle.style.display = 'inline-block';
    soundToggle.textContent = state.flappyMuted ? 'üîá Sound Off' : 'üîä Sound On';
  }
  
  // E) Setup sound toggle checkbox
  const soundCheckbox = byId('flappySoundCheckbox');
  if (soundCheckbox) {
    soundCheckbox.checked = state.flappyMuted;
    soundCheckbox.onchange = () => {
      state.flappyMuted = soundCheckbox.checked;
      save();
      // Update button text too
      if (soundToggle) {
        soundToggle.textContent = state.flappyMuted ? 'üîá Sound Off' : 'üîä Sound On';
      }
    };
  }
  
  // C) Hide close button and prevent ESC/backdrop clicks during countdown
  const closeBtn = byId('flappyClose');
  if (state.timeblock?.breakActive && state.timeblock?.breakEndsAt) {
    // During break countdown - hide close button and disable modal close
    if (closeBtn) closeBtn.style.display = 'none';
    byId('flappyModal').style.pointerEvents = 'none'; // Disable backdrop clicks
    byId('flappyModal').querySelector('.card').style.pointerEvents = 'auto'; // Re-enable card clicks
  } else {
    // Normal flappy (lockout) - show close button
    if (closeBtn) closeBtn.style.display = 'inline-block';
    byId('flappyModal').style.pointerEvents = 'auto';
  }
  
  // Update description based on context
  if (description) {
    if (state.timeblock?.breakActive || isLocked()) {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap makes a flappy sound.';
    } else {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap plays a random pitch.';
    }
  }
}
/* D) Removed startFlappyReward() - Flappy only opens from TimeBlock breaks */

// A) Decouple game end from modal close - show overlay during TimeBlock breaks
function onFlappyLose() {
  running = false; // Stop the game
  
  // Call maybeCloseBreakModal when a flappy round ends
  maybeCloseBreakModal();
  
  // If we're in a TimeBlock break, show crash overlay instead of closing modal
  if (state.timeblock.breakActive && state.timeblock.breakEndsAt) {
    const now = Date.now();
    const remaining = Math.max(0, state.timeblock.breakEndsAt - now);
    
    if (remaining > 0) {
      // Show crash overlay with remaining time
      showFlappyCrashOverlay(remaining);
      return; // Don't close the modal
    }
  }
  
  // Not in a break or break time is up - close normally
  closeFlappy(true);
}

function showFlappyCrashOverlay(remaining) {
  const flappyModal = byId('flappyModal');
  if (!flappyModal || flappyModal.style.display !== 'flex') return;
  
  // Remove existing crash overlay if any
  const existingOverlay = flappyModal.querySelector('#flappyCrashOverlay');
  if (existingOverlay) existingOverlay.remove();
  
  // Create crash overlay
  const overlay = document.createElement('div');
  overlay.id = 'flappyCrashOverlay';
  overlay.style.cssText = `
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9);
    color: var(--text);
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    z-index: 100;
  `;
  
  const timeText = document.createElement('p');
  timeText.id = 'crashOverlayTime';
  timeText.style.cssText = 'margin: 0 0 16px 0; font-weight: 600; color: var(--accent);';
  
  const buttonsDiv = document.createElement('div');
  buttonsDiv.style.cssText = 'display: flex; gap: 12px; justify-content: center;';
  
  const playAgainBtn = document.createElement('button');
  playAgainBtn.textContent = 'Play again';
  playAgainBtn.style.cssText = 'padding: 8px 16px; border-radius: 8px; border: none; background: var(--good); color: var(--text); cursor: pointer;';
  playAgainBtn.onclick = () => {
    overlay.remove();
    running = true;
    resetFlappy();
    flappyRAF = requestAnimationFrame(step);
  };
  
  const justRestBtn = document.createElement('button');
  justRestBtn.textContent = 'Just rest';
  justRestBtn.style.cssText = 'padding: 8px 16px; border-radius: 8px; border: none; background: var(--muted); color: var(--text); cursor: pointer;';
  justRestBtn.onclick = () => {
    overlay.remove();
  };
  
  // Function to update the time text
  const updateTimeText = () => {
    if (!state.timeblock.breakActive || !state.timeblock.breakEndsAt) {
      overlay.remove();
      return;
    }
    const now = Date.now();
    const remaining = Math.max(0, state.timeblock.breakEndsAt - now);
    if (remaining <= 0) {
      overlay.remove();
      return;
    }
    timeText.textContent = `You crashed! ‚è≥ ${fmtMMSS(remaining)} left`;
  };
  
  // Initial update
  updateTimeText();
  
  // Update every second
  const updateTimer = setInterval(updateTimeText, 1000);
  
  // Clean up timer when overlay is removed
  const originalRemove = overlay.remove;
  overlay.remove = function() {
    clearInterval(updateTimer);
    originalRemove.call(this);
  };
  
  buttonsDiv.appendChild(playAgainBtn);
  buttonsDiv.appendChild(justRestBtn);
  overlay.appendChild(timeText);
  overlay.appendChild(buttonsDiv);
  
  const flappyCard = flappyModal.querySelector('.card');
  if (flappyCard) {
    flappyCard.style.position = 'relative';
    flappyCard.appendChild(overlay);
  }
}

function closeFlappy(){
  running=false; cancelAnimationFrame(flappyRAF); byId('flappyModal').style.display='none'; detachFlappyControls();
  if(score > (state.flappyHighScore||0)){ state.flappyHighScore = score; save(); }
  
  // Remove break message if it exists
  const breakMessage = byId('breakMessage');
  if (breakMessage) breakMessage.remove();
  
  // If we're in a break and closing flappy manually, we should still wait for break time to finish
  if (state.inBreak && sessionActive) {
    // Don't resume training yet - keep paused until break time is up
    safe('btnPause', el=> el.textContent='‚è∏ Pause');
    text('promptPill','Break time remaining - press "Play Flappy" from menu to reopen or wait for break to end');
  } else if(sessionActive){
    safe('btnPause', el=> el.textContent='‚ñ∂ Resume');
    currentNote=null; clearTimeout(rtTimer); rtTimer=null; clearTimeout(autoTimer); autoTimer=null;
    text('promptPill','Flappy over ‚Äî press Play to continue');
  }
}
function resetFlappy(){ const cnv=byId('flappyCanvas'); if(!cnv) return; bird={x:60,y:cnv.height/2,vy:0,wing:0}; pipes=[]; score=0; pipeTimer=0; lastTs=null; FLAPPY.speed=FLAPPY.baseSpeed; FLAPPY.gap=FLAPPY.baseGap + FLAPPY.introExtra; FLAPPY.introPipes=5; text('flappyScore',`Score: 0 ‚Ä¢ Best: ${state.flappyHighScore||0}`); }
function flap(){ 
  bird.vy = FLAPPY.flap; 
  
  // Only play sound if not muted
  if (!state.flappyMuted) {
    // During TimeBlock breaks or lockout, always play flappy sound
    // During regular play (rewards), play random pitches
    if (state.timeblock?.breakActive || isLocked()) {
      playFlappySound();
    } else {
      // Regular flappy bird with musical pitches (only during rewards)
      const pc = rand(PC); 
      const note = `${pc}${rand(currentOctaves())}`; 
      playSample(note);
    }
  }
}
function progressiveDifficulty(){ // only speed scales; gap remains constant after intro
  const target = FLAPPY.baseSpeed + Math.min(Math.floor(score/5)*18, FLAPPY.maxSpeed - FLAPPY.baseSpeed);
  FLAPPY.speed = target;
}
function drawBird(){ const ctx=fCtx; if(!ctx) return; const body=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#fbbf24'; const wingCol=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; const outline=getComputedStyle(document.documentElement).getPropertyValue('--bg')||'#0f172a';
  ctx.save();
  const tilt=Math.max(-0.6,Math.min(0.6,bird.vy/380)); ctx.translate(bird.x,bird.y); ctx.rotate(tilt);
  ctx.fillStyle=body; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb'; ctx.beginPath(); ctx.arc(3,-4,3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=outline; ctx.beginPath(); ctx.arc(4,-4,1.5,0,Math.PI*2); ctx.fill();
  bird.wing+=0.25; const wing=Math.sin(bird.wing)*0.9; ctx.save(); ctx.rotate(wing);
  ctx.fillStyle=wingCol; ctx.beginPath(); ctx.moveTo(-2,2); ctx.quadraticCurveTo(-16,4,-8,12); ctx.quadraticCurveTo(0,10,-2,2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.restore();
  ctx.restore();
}
function drawPipes(){ const ctx=fCtx; if(!ctx) return; const col=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; ctx.fillStyle=col; const cnv=byId('flappyCanvas'); if(!cnv) return; for(const p of pipes){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; ctx.fillRect(p.x,0,FLAPPY.width,topH); ctx.fillRect(p.x,bottomY,FLAPPY.width,cnv.height-bottomY); } }
function spawnPipe(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const h=cnv.height, m=40;

  // intro ramp: linearly reduce gap to baseGap across first 5 pipes
  if(FLAPPY.introPipes > 0){
    const k = FLAPPY.introPipes; // 5..1
    const extraNow = Math.round(FLAPPY.introExtra * (k/5));
    FLAPPY.gap = FLAPPY.baseGap + extraNow;
    FLAPPY.introPipes--;
    if(FLAPPY.introPipes === 0) FLAPPY.gap = FLAPPY.baseGap; // lock it
  }

  const gapY=Math.max(m,Math.min(h-m-FLAPPY.gap,Math.random()*(h-FLAPPY.gap-2*m)))+FLAPPY.gap/2;
  pipes.push({x: cnv.width, gapY: gapY, passed:false});
}
function step(ts){
  if(!running) return;
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  if(lastTs===null) lastTs = ts;
  let dt = (ts - lastTs) / 1000; if(dt > 0.033) dt = 0.033; lastTs = ts;
  bird.vy += FLAPPY.gravity * dt; bird.y  += bird.vy * dt;
  pipeTimer -= dt; if(pipeTimer <= 0){ pipeTimer += FLAPPY.spawnEvery; spawnPipe(); }
  for(const p of pipes){ p.x -= FLAPPY.speed * dt; }
  for(const p of pipes){ if(!p.passed && p.x + FLAPPY.width < bird.x){ p.passed = true; score++; progressiveDifficulty(); text('flappyScore',`Score: ${score} ‚Ä¢ Best: ${state.flappyHighScore||0}`); } }
  pipes = pipes.filter(p=> p.x + FLAPPY.width > 0);
  fCtx.clearRect(0,0,cnv.width,cnv.height); drawPipes(); drawBird();
  if(bird.y < 0 || bird.y > cnv.height){ return onFlappyLose(); }
  for(const p of pipes){ if(bird.x+10>p.x && bird.x-10<p.x+FLAPPY.width){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; if(bird.y-10<topH || bird.y+10>bottomY){ return onFlappyLose(); } } }
  flappyRAF = requestAnimationFrame(step);
}
let _flHandlers=null;
function attachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const startOrFlap = () => { if(!running){ running=true; resetFlappy(); flappyRAF=requestAnimationFrame(step); } else { flap(); } };
  const onCanvasClick  = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onTouchStart   = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onKey          = (e)=>{ 
    if(e.code==='Space'){ e.preventDefault(); startOrFlap(); } 
    // C) Prevent ESC from closing modal during break countdown
    if(e.code==='Escape' && state.timeblock?.breakActive && state.timeblock?.breakEndsAt) {
      e.preventDefault();
      e.stopPropagation();
    }
  };
  const onClose        = ()=> {
    // C) Only allow manual close if not during break countdown
    if (state.timeblock?.breakActive && state.timeblock?.breakEndsAt) {
      return; // Ignore close attempts during break
    }
    closeFlappy(false);
  };
  cnv.addEventListener('click', onCanvasClick);
  cnv.addEventListener('touchstart', onTouchStart, { passive:false });
  window.addEventListener('keydown', onKey);
  safe('flappyClose', el=> el.onclick=onClose);
  safe('flappySoundToggle', el=> el.onclick=()=> {
    state.flappyMuted = !state.flappyMuted;
    save();
    el.textContent = state.flappyMuted ? 'üîá Sound Off' : 'üîä Sound On';
    // Update checkbox too
    const checkbox = byId('flappySoundCheckbox');
    if (checkbox) checkbox.checked = state.flappyMuted;
  });
  _flHandlers={onCanvasClick,onTouchStart,onKey,onClose};
}
function detachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!_flHandlers||!cnv) return;
  cnv.removeEventListener('click', _flHandlers.onCanvasClick);
  cnv.removeEventListener('touchstart', _flHandlers.onTouchStart);
  window.removeEventListener('keydown', _flHandlers.onKey);
  safe('flappyClose', el=> el.onclick=null);
  safe('flappySoundToggle', el=> el.onclick=null);
}

/* ------------------ STRICT MODAL + NAV GUARDS ------------------ */
let strictModalPending=false;
function openStrictModal(){ if(suppressStrictOnce){ suppressStrictOnce=false; return; } showFlex('strictModal'); setTimeout(()=> byId('btnStrictResume')?.focus(), 0); }
function closeStrictModal(){ hide('strictModal'); strictModalPending=false; }

/* New Pitch Modal */
function showNewPitchModal(setNumber){
  const newPitch = UNLOCK_ORDER[setNumber - 1];
  text('newPitchName', pcLabel(newPitch));
  showFlex('newPitchModal');
  setTimeout(()=> byId('btnHearNewPitch')?.focus(), 0);
}
function closeNewPitchModal(){
  hide('newPitchModal');
}
async function playNewPitchDemo(pitch){
  try{
    await resumeCtx();
    const octaves = currentOctaves();
    
    // Play the pitch slowly across all three octaves
    for(let i = 0; i < octaves.length; i++){
      const note = `${pitch}${octaves[i]}`;
      await playSample(note);
      // Wait 1.2 seconds between notes for slow demonstration  
      await new Promise(resolve => setTimeout(resolve, 1200));
    }
  }catch(e){
    report(e);
  }
}
function reconcileAwayTime(){
  const now = Date.now();
  const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
  if(rec && rec.pauses && rec.pauses.length){
    const openPause = rec.pauses[rec.pauses.length-1];
    if(openPause && !openPause.end){ openPause.end = now; save(); }
  }
  state.lastSeen = now; save();
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden && sessionActive && !paused){ pauseStart('hidden'); strictModalPending = true; }
  if(!document.hidden){ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; }
});
window.addEventListener('blur', ()=>{ if(sessionActive && !paused){ pauseStart('blur'); strictModalPending = true; } });
window.addEventListener('focus', ()=>{ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; });
window.addEventListener('pagehide', ()=>{ try{ if(sessionActive && !paused){ pauseStart('pagehide'); strictModalPending = true; } state.lastSeen = Date.now(); save(); }catch(_){}});

/* --- beforeunload guard --- */
let allowUnloadOnce = false;
window.addEventListener('beforeunload', (e)=>{
  if(allowUnloadOnce) return;
  if(sessionActive && !paused){ e.preventDefault(); e.returnValue=''; }
});

/* ------------------ FACTORY RESET ------------------ */
async function wipeAllStorage(){ try{ localStorage.clear(); }catch(_){}
  try{ sessionStorage.clear(); }catch(_){}
  if('caches' in window){ try{ const keys = await caches.keys(); await Promise.all(keys.map(k=>caches.delete(k))); }catch(_){ } }
  if('indexedDB' in window){
    try{
      if(indexedDB.databases){
        const dbs = await indexedDB.databases();
        await Promise.all((dbs||[]).map(db=> db && db.name ? new Promise(res=>{ const rq = indexedDB.deleteDatabase(db.name); rq.onsuccess=rq.onerror=rq.onblocked=()=>res(); }) : Promise.resolve()));
      }
    }catch(_){}
  }
}
function forceStartScreen(){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  const input = byId('userNameInput');
  byId('startScreen').style.display='block';
  if(input){ input.value=''; input.focus(); }
}
function resetInMemoryStateToDefaults(){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, shepardDoneFor:-1, sessions:[], trials:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null, audioType: AUDIO_TYPES.PIANO, assessmentScores: [], theme: 'default', flappySoundEnabled: true, flappyMuted: false, timeblock: { activeMs: 0, running: false, startedAt: null, breaksCompletedToday: 0, breakActive: false, breakEndsAt: null }, oobController: { targetOobPct: 15, lastAdaptTimeBlock: 0, last60InBounds: [], recentOobTrials: [], healthCheckActive: false, healthCheckEndTimeBlock: 0, globalTimeBlockIndex: 0, oobSeries: [] }, inBoundsLast60: [], trainingBlockIndex: 1, trainingBlockTrials: 0, currentBlockOctaveCount: {3: 0, 4: 0, 5: 0}, oob: { targetPct: 0.15, streak: 0, blockTarget: 0, plan: [], planOctaveMix: [], currentBlockIndex: 0, currentTrialInBlock: 0 }, trialOpen: false, toneStartMs: null };
  save();
}
function doFactoryReset(){
  (async ()=>{
    try{
      if(!confirm('Reset EVERYTHING to factory settings? This erases your progress, timers, and settings.')) return;
      stopAllTimers(); sessionActive=false; paused=false;
      await closeAudio(); await wipeAllStorage(); resetInMemoryStateToDefaults(); forceStartScreen();
      allowUnloadOnce = true; setTimeout(()=>{ try{ location.reload(); }catch(_){ } }, 0);
    }catch(e){ report(e); alert('Reset failed: '+e.message); }
  })();
}

/* ------------------ QA HELPERS ------------------ */
// QA helper functions for testing and debugging

// 1) window.qaSnapshot(tag?:string): returns an object with debugging info
window.qaSnapshot = function(tag) {
  try {
    // Calculate counts from state.trials
    const trials = state.trials || [];
    const totalTrials = trials.length;
    const totalCorrect = trials.filter(t => t.correct).length;
    const totalOOB = trials.filter(t => t.oob).length;
    const totalTimeout = trials.filter(t => t.timeout).length;
    
    // Get last 200 trials (shallow copy)
    const trialsTail = trials.slice(-200);
    
    const snapshot = {
      ts: new Date().toISOString(),
      tag: tag || null,
      set: setFromIndex(state.levelIndex),
      block: blockFromIndex(state.levelIndex),
      dailyMs: SESS_DAILY_MS,
      lockoutMs: LOCKOUT_MS,
      audioType: state.audioType,
      octaves: currentOctaves(),
      trialsTail: trialsTail,
      counts: {
        totalTrials: totalTrials,
        totalCorrect: totalCorrect,
        totalOOB: totalOOB,
        totalTimeout: totalTimeout
      }
    };
    
    // Include oobConstRate if OOB_RATE exists
    if (typeof OOB_RATE !== 'undefined') {
      snapshot.oobConstRate = OOB_RATE;
    }
    
    return snapshot;
  } catch (e) {
    console.error('qaSnapshot error:', e);
    return { error: e.message };
  }
};

// 2) window.qaDownload(obj, name): downloads JSON pretty-printed to "<name>.json"
window.qaDownload = function(obj, name) {
  try {
    const jsonString = JSON.stringify(obj, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `${name || 'qa-data'}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the URL object
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error('qaDownload error:', e);
  }
};

// 3) window.qaSimBlock(n=20, seed=123): synthetic trial simulation
window.qaSimBlock = function(n = 20, seed = 123) {
  try {
    // Simple seeded random number generator for reproducible results
    let seedValue = seed;
    const seededRandom = () => {
      seedValue = (seedValue * 9301 + 49297) % 233280;
      return seedValue / 233280;
    };
    
    const currentSet = setFromIndex(state.levelIndex);
    const currentBlock = blockFromIndex(state.levelIndex);
    const trainedPCs = trainedSet(currentSet);
    const oobPCs = currentOOBs(currentSet);
    const octaves = currentOctaves();
    const oobRate = (typeof OOB_RATE !== 'undefined') ? OOB_RATE : 0.25;
    
    for (let i = 0; i < n; i++) {
      // Determine if this trial is OOB
      const isOOB = seededRandom() < oobRate;
      
      // Choose pitch class
      let pc;
      if (isOOB && oobPCs.length > 0) {
        pc = oobPCs[Math.floor(seededRandom() * oobPCs.length)];
      } else {
        pc = trainedPCs[Math.floor(seededRandom() * trainedPCs.length)];
      }
      
      // Choose octave
      const octave = octaves[Math.floor(seededRandom() * octaves.length)];
      const note = `${pc}${octave}`;
      
      // Synthesize correctness: 80% for in-bounds, 40% for OOB
      const correctnessRate = isOOB ? 0.4 : 0.8;
      const correct = seededRandom() < correctnessRate;
      
      // Generate fake guess (for realism, but not used in correctness calculation)
      let guess;
      if (isOOB) {
        guess = seededRandom() < 0.5 ? 'OOB' : trainedPCs[Math.floor(seededRandom() * trainedPCs.length)];
      } else {
        guess = correct ? pc : trainedPCs[Math.floor(seededRandom() * trainedPCs.length)];
      }
      
      // Create trial object matching the structure used by recordTrial
      const trial = {
        note: note,
        pc: pc,
        guess: guess,
        correct: correct,
        timeout: false,
        oob: isOOB,
        set: currentSet,
        block: currentBlock,
        time: Date.now()
      };
      
      // Push directly to state.trials without calling recordTrial
      state.trials.push(trial);
    }
    
    // Save at the end
    save();
    
    // Return number of trials added
    return n;
  } catch (e) {
    console.error('qaSimBlock error:', e);
    return 0;
  }
};

// 4) window.qaAnalyzeDetune(): analyzes detune mode distribution in recent trials
window.qaAnalyzeDetune = function(last = 200) {
  try {
    const trials = state.trials || [];
    const recentTrials = trials.slice(-last);
    
    const inBounds = recentTrials.filter(t => !t.oob);
    const oobTrials = recentTrials.filter(t => t.oob);
    
    // Count modes for in-bounds trials
    const modeCounts = {
      anchor: 0,
      probe: 0,
      jitter: 0,
      other: 0
    };
    
    inBounds.forEach(t => {
      const mode = t.detuneMode;
      if (mode in modeCounts) {
        modeCounts[mode]++;
      } else {
        modeCounts.other++;
      }
    });
    
    // Calculate percentages
    const totalInBounds = inBounds.length;
    const modePercentages = {};
    Object.keys(modeCounts).forEach(mode => {
      modePercentages[mode] = totalInBounds > 0 ? (modeCounts[mode] / totalInBounds * 100).toFixed(1) : 0;
    });
    
    // Analyze detune cents distribution
    const centsDistribution = {
      zero: 0,
      positive: 0,
      negative: 0
    };
    
    inBounds.forEach(t => {
      const cents = t.detuneCents || 0;
      if (cents === 0) {
        centsDistribution.zero++;
      } else if (cents > 0) {
        centsDistribution.positive++;
      } else {
        centsDistribution.negative++;
      }
    });
    
    const analysis = {
      totalTrials: recentTrials.length,
      inBoundsTrials: totalInBounds,
      oobTrials: oobTrials.length,
      modeCounts: modeCounts,
      modePercentages: modePercentages,
      centsDistribution: centsDistribution,
      sampleTrials: {
        inBounds: inBounds.slice(-10),  // Last 10 in-bounds
        oob: oobTrials.slice(-5)        // Last 5 OOB
      }
    };
    
    // Validate OOB trials have correct detune settings
    const oobIssues = oobTrials.filter(t => 
      t.detuneCents !== 0 || t.detuneMode !== 'oob'
    );
    
    if (oobIssues.length > 0) {
      analysis.oobIssues = oobIssues;
    }
    
    return analysis;
  } catch (e) {
    console.error('qaAnalyzeDetune error:', e);
    return { error: e.message };
  }
};

/* ------------------ INIT ------------------ */
window.addEventListener('load', wireOnce);
window.addEventListener('resize', ()=>{ try{ drawChart(); }catch(_){ }});
</script>
</body>
</html>
