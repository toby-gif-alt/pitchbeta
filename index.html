<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üéµ Absolute Pitch Trainer</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root { --bg:#0f172a; --card:#1e293b; --muted:#334155; --good:#16a34a; --bad:#dc2626; --text:#e5e7eb; --accent:#fbbf24; --neutral:#94a3b8; --muted2:#2a3a54; }
  *{box-sizing:border-box}
  body{font-family:'Fredoka',sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px}
  .card{max-width:1060px;margin:auto;background:var(--card);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.15)}
  h1,h2,h3{margin:0 0 8px}
  button{margin:6px;padding:10px 16px;border-radius:12px;border:none;cursor:pointer;font-size:14px;background:var(--muted);color:var(--text);transition:transform .06s ease, filter .12s ease, background .12s ease, border-color .12s ease}
  button:hover{transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  button:disabled{opacity:.55; cursor:not-allowed; background:var(--muted2); border:1.5px dashed var(--muted)}
  input,select{padding:10px 12px;border-radius:12px;border:1px solid var(--muted);background:var(--card);color:var(--text)}
  select{appearance:none;background-image:linear-gradient(45deg,transparent 50%,var(--text) 50%),linear-gradient(135deg,var(--text) 50%,transparent 50%),linear-gradient(to right,transparent,transparent);
         background-position:calc(100% - 20px) 16px, calc(100% - 14px) 16px, 100% 0; background-size:6px 6px,6px 6px, 2.5em 2.5em; background-repeat:no-repeat}
  label{opacity:.9}
  .screen{display:none}
  .pill{display:inline-flex;align-items:center;background:var(--muted);padding:8px 12px;border-radius:16px;font-size:13px;margin:6px;white-space:nowrap}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .note-pad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
  .note{min-height:64px;font-size:18px;border-radius:14px}
  .note.inert{background:var(--muted2) !important; border:1.5px dashed var(--muted); cursor:not-allowed}
  .wide{grid-column:1 / -1}
  #barStatus{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  #barControls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  #feedbackOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;pointer-events:none}
  #feedbackBox{min-width:240px;text-align:center;padding:16px 18px;border-radius:14px;font-weight:700;font-size:20px;box-shadow:0 20px 60px rgba(0,0,0,.35);transform:scale(.9);opacity:0;transition:transform .15s,opacity .15s}
  #feedbackOverlay.show #feedbackBox{transform:scale(1.05);opacity:1}
  #shepardOverlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:60}
  #shepardBox{background:var(--card);border:1px solid var(--muted);padding:20px 24px;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);text-align:center}
  #bootError{display:none;position:fixed;left:12px;right:12px;bottom:12px;background:var(--bad);color:var(--text);padding:10px 12px;border-radius:10px;box-shadow:0 4px 18px rgba(0,0,0,.35);z-index:9999;font:13px/1.35 system-ui,sans-serif;white-space:pre-wrap}

  /* Flappy */
  #flappyModal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:50}
  #flappyCanvas{background:var(--card);width:320px;height:480px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);cursor:pointer;-webkit-tap-highlight-color:transparent;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;outline:none}

  input[type="range"].disabled{opacity:.4;filter:grayscale(1)}

  /* Suggestion banner */
  #suggestBanner{display:none;margin:8px 0 4px;padding:10px 12px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted);color:var(--text);align-items:center;gap:10px}
  #suggestBanner button{margin:0 4px;padding:8px 12px;border-radius:10px;font-size:13px}
  #btnRestartSet{background:var(--good)}
  #btnDismissSuggest{background:var(--muted)}

  /* Modals */
  #strictModal,#welcomeModal,#newPitchModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,.55);pointer-events:auto}
  #strictBox,#welcomeBox,#newPitchBox{width:min(760px,92vw);background:var(--card);border:1px solid var(--muted);border-radius:16px;padding:18px 20px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
  #strictBox h3,#welcomeBox h2,#newPitchBox h2{margin:0 0 8px}
  #strictBtns,#welcomeBtns,#newPitchBtns{display:flex;gap:10px;justify-content:flex-end;margin-top:12px}
  #btnStrictResume{background:var(--good)}
  #btnStrictMenu{background:var(--muted)}
  #welcomeBtns button{background:var(--muted)}
  #btnHearNewPitch{background:var(--accent);color:var(--bg);font-weight:700}
  #btnContinueTraining{background:var(--good)}
  #tutorialWrap{background:var(--card);border:1px solid var(--muted);border-radius:12px;padding:12px;margin:10px 0}

  /* Progress (charts) */
  #progressCard{margin-top:14px}
  #progressControls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  #progressLegend{display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9}
  .legendDot{width:12px;height:12px;border-radius:50%}

  /* Tutorial pager */
  .tPage{display:none}
  .tPage.active{display:block}
  #tutorialNav{display:flex;gap:8px;justify-content:space-between;margin-top:10px}
  #tBack{visibility:hidden}

  /* Special exercise strip */
  #specialBar{display:none;align-items:center;justify-content:space-between;background:var(--muted2);border:1px solid var(--muted);color:var(--text);padding:8px 12px;border-radius:10px;margin-bottom:10px}

  /* Scope picker CTA styling */
  .scopeWrap{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted)}
  .scopeWrap:hover{box-shadow:0 0 0 2px rgba(251,191,36,.25) inset}
  .scopeSelect{background:var(--card);border:1.5px solid var(--muted);border-radius:10px;padding:8px 36px 8px 10px;font-weight:600}
  .scopeSelect:focus{outline:none; box-shadow:0 0 0 2px var(--accent)}
  .scopeBtn{background:var(--accent);color:var(--bg);font-weight:700}
</style>
</head>
<body>
  <!-- Start -->
  <div class="card screen" id="startScreen">
    <h1>Welcome!</h1>
    <p>Enter your name to begin:</p>
    <input id="userNameInput" placeholder="Your name" />
    <button id="startBtn">Start ‚ñ∂</button>
  </div>

  <!-- Welcome / Tutorial -->
  <div id="welcomeModal" aria-modal="true" role="dialog">
    <div id="welcomeBox" class="card">
      <h2>üìò How this program works</h2>
      <div id="tutorialWrap">
        <div class="tPage active" id="tPage1">
          <h3>üéØ Goal</h3>
          <p>Learn to recognize the <strong>12 pitches</strong> by ear (C, C#/Db, D, D#/Eb, E, F, F#/Gb, G, G#/Ab, A, A#/Bb, B). You start with a single pitch and add more.</p>
          <ul>
            <li><strong>Unlock order (study):</strong> alternate semitones around F: <strong>F, E, F#/Gb, Eb, G, D, Ab, Db, A, C, Bb, B</strong>.</li>
            <li>Training uses <strong>sets</strong> (how many pitches you‚Äôre learning) and <strong>blocks</strong> (24 per set).</li>
            <li><strong>RT (reaction time)</strong> = max time to answer; it increases slightly with set size.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage2">
          <h3>‚è± Daily session</h3>
          <ul>
            <li>Train for <strong>five 6-minute blocks</strong> with 1-minute breaks between each block.</li>
            <li>Do this <strong>once a day, about 5-6 times a week</strong> for best results.</li>
            <li>Complete all <strong>five blocks in one go</strong> - don't split throughout the day.</li>
            <li>Menus, Flappy, and the 20-s <strong>Shepard tone</strong> don‚Äôt count toward training time.</li>
            <li>Blocks <strong>1‚Äì20</strong> with feedback; <strong>21‚Äì24</strong> are tests (no feedback).</li>
          </ul>
        </div>
        <div class="tPage" id="tPage3">
          <h3>üéπ Octaves (per study)</h3>
          <ul>
            <li>Training tones span <strong>three octaves</strong> and are randomized within blocks.</li>
            <li><strong>Piano/Sine/Guitar:</strong> C3‚ÄìB5</li>
            <li>This encourages learning the <em>chroma</em> (pitch class), not just pitch height.</li>
            <li>Tone length: <strong>800 ms</strong>.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage4">
          <h3>üß™ Special exercises (Block 15)</h3>
          <ul>
            <li>When you‚Äôre learning <strong>‚â• 5 pitches</strong>, Block 15 becomes specials:</li>
            <li><strong>Exercise A</strong>: 12 trials with feedback ‚Äî <em>Target (pitch)</em> vs <em>Other (¬±2 semitones)</em>.</li>
            <li><strong>Exercise B</strong>: 22 trials without feedback ‚Äî same task.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage5">
          <h3>üê§ Flappy breaks</h3>
          <ul>
            <li>Break mini-game; each flap makes a flappy sound during breaks.</li>
            <li>Timer stays paused until you press <strong>Play</strong> again.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage6">
          <h3>üé§ Cold and Warm Recall</h3>
          <ul>
            <li><strong>Cold recall:</strong> Before starting training, sing the 12 pitches (C, C#, D, D#, E, F, F#, G, G#, A, A#, B) to test your memory.</li>
            <li><strong>Warm recall:</strong> After completing training, sing the same 12 pitches again to compare improvement.</li>
            <li>Both use your voice input - no need for perfect pitch, just sing what you think each note sounds like.</li>
            <li>Cold recall is <strong>required before training</strong> - warm recall is <strong>optional after completion</strong> via the menu button.</li>
            <li>These help track your progress and reinforce learning through vocal memory.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage7">
          <h3>üìä Assessment Test</h3>
          <ul>
            <li><strong>Purpose:</strong> Measure your absolute pitch ability with 20 random pitches across different audio types.</li>
            <li><strong>When to take:</strong> At the start and end of your 8-week program, or weekly to track progress.</li>
            <li><strong>Features:</strong> No feedback during test, results saved to tracker for progress monitoring.</li>
            <li>View your assessment history and progress in the <strong>Track</strong> section from the main menu.</li>
          </ul>
        </div>
      </div>
      <div id="welcomeBtns">
        <div id="tutorialNav" style="width:100%">
          <button id="tBack">‚óÄ Back</button>
          <div style="flex:1"></div>
          <button id="tNext">Next ‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Menu -->
  <div class="card screen" id="menuScreen">
    <h1 id="greeting">Absolute Pitch Trainer</h1>
    <div class="row">
      <span class="pill" id="capInfo">Left: 30:00</span>
      <span class="pill" id="weekPill">This week: 0 hrs 0 mins</span>
      <span class="pill" id="lockoutPill" style="display:none">üîí Locked</span>
    </div>
    <div class="row">
      <button id="menuStart">‚ñ∂ Start Training</button>
      <button id="startAssessment">üìä Assessment Test</button>
      <button id="viewTracker">üìä Track</button>
      <button id="startWarmRecall">üî• Warm Recall</button>
      <button id="playFlappy">üê§ Flappy (lockout only)</button>
      <button id="resetLockout">‚ö° Reset lockout/timer</button>
      <button id="menuReset">‚ü≤ Reset (factory)</button>
    </div>

    <!-- Scope looks obviously changeable now -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Current scope:</span>
        <select id="setSizeSelect" class="scopeSelect"></select>
        <button id="applySetBtn" class="scopeBtn">Change‚Ä¶</button>
      </div>
    </div>
    
    <!-- Audio Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Audio type:</span>
        <select id="audioTypeSelect" class="scopeSelect">
          <option value="piano">Piano (C3-B5)</option>
          <option value="sine">Sine Wave (C3-B5)</option>
          <option value="guitar">Guitar (C3-B5)</option>
        </select>
        <button id="applyAudioBtn" class="scopeBtn">Change</button>
      </div>
    </div>
    
    <!-- Variety Mode Toggle -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Variety Mode (80/20 timbre mix):</span>
        <select id="varietyModeSelect" class="scopeSelect">
          <option value="single">Off (Single Timbre)</option>
          <option value="variety">On (80/20 Mix)</option>
        </select>
        <button id="applyVarietyModeBtn" class="scopeBtn">Change</button>
        <button id="varietyModeHelp" class="scopeBtn" style="background:var(--muted);font-size:12px;padding:6px 8px">?</button>
      </div>
    </div>
    
    <!-- Dev Variety Mode Toggle (hidden by default) -->
    <div class="row" id="devVarietyRow" style="margin-top:8px;gap:12px;display:none">
      <div class="scopeWrap">
        <span style="opacity:.9">Dev: Force Variety Now:</span>
        <select id="forceVarietySelect" class="scopeSelect">
          <option value="off">Off (Normal)</option>
          <option value="on">On (Force Variety)</option>
        </select>
        <button id="applyForceVarietyBtn" class="scopeBtn">Change</button>
      </div>
    </div>
    
    <!-- Theme Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Theme:</span>
        <select id="themeSelect" class="scopeSelect">
          <option value="default">Dark Ocean</option>
          <option value="beach">Beach Sunset</option>
          <option value="jungle">Jungle Canopy</option>
          <option value="sky">Cloud Nine</option>
          <option value="desert">Desert Oasis</option>
          <option value="neon">Neon Nights</option>
          <option value="forest">Mystic Forest</option>
        </select>
        <button id="applyThemeBtn" class="scopeBtn">Change</button>
      </div>
    </div>



    <!-- Recall History -->
    <div class="card" id="recallCard" style="margin-top:14px">
      <h3>üéØ Recall History</h3>
      <div style="margin-bottom:8px">
        <button id="btnExportRecall" style="background:var(--accent);color:var(--bg);font-weight:700;margin-right:8px">üìÑ Export Recall CSV</button>
        <span style="opacity:0.7;font-size:13px">Today's cold/warm pitch recall results</span>
      </div>
      <div id="recallHistoryToday" style="border:1px solid var(--muted);border-radius:12px;padding:12px;background:var(--card);min-height:80px">
        <p id="recallHistoryEmpty" style="opacity:0.7;text-align:center;margin:20px 0">No recall data for today</p>
      </div>
    </div>

    <!-- Progress -->
    <div class="card" id="progressCard" style="margin-top:14px">
      <h3>üìà Progress</h3>
      <div id="progressControls">
        <label for="pitchSelect">Pitch:</label>
        <select id="pitchSelect" style="padding-right:28px"></select>
        <label for="granularitySelect">View:</label>
        <select id="granularitySelect" style="padding-right:28px">
          <option value="WEEKLY" selected>Weekly (Day 1 ‚Üí 7)</option>
          <option value="OVERALL">Overall (Week 1 ‚Üí 8)</option>
        </select>
        <div id="progressLegend">
          <span class="legendDot" style="background:var(--good)"></span> <span id="legGood">Correct %</span>
          <span class="legendDot" style="background:var(--bad);margin-left:12px)"></span> <span id="legBad">Incorrect %</span>
          <span class="legendDot" style="background:var(--neutral);margin-left:12px)"></span> <span id="legTrend">No-trial day</span>
        </div>
      </div>
      <canvas id="progressCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
  </div>

  <!-- Assessment Tracker Screen -->
  <div class="card screen" id="trackerScreen">
    <h1>üìä Assessment Tracker</h1>
    <div class="row">
      <span class="pill" id="trackerCount">0 assessments</span>
      <button id="btnBackMenuTracker">‚Ü© Menu</button>
    </div>
    
    <div style="margin:20px 0">
      <div id="trackerLegend" style="display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9;margin-bottom:12px">
        <span class="legendDot" style="background:var(--good)"></span> <span>Exact Correct %</span>
        <span class="legendDot" style="background:var(--accent);margin-left:12px"></span> <span>Within ¬±1 semitone %</span>
      </div>
      <canvas id="trackerCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
    
    <div id="trackerDetails" style="margin-top:16px">
      <h3>Assessment History</h3>
      <div id="trackerHistory" style="max-height:200px;overflow-y:auto;border:1px solid var(--muted);border-radius:12px;padding:12px;background:var(--card)">
        <p style="opacity:0.7;text-align:center">No assessments completed yet</p>
      </div>
    </div>
  </div>

  <!-- Trainer -->
  <div class="card screen" id="trainerScreen">
    <div id="specialBar" class="row">
      <span id="specialText">Special Exercise</span>
      <span class="pill" id="specialCount">0 / 0</span>
    </div>

    <div id="suggestBanner" class="row">
      <span>Struggling in the test phase. Restart this pitch set?</span>
      <div style="margin-left:auto"></div>
      <button id="btnRestartSet">Restart set</button>
      <button id="btnDismissSuggest">Dismiss</button>
    </div>

    <div id="barStatus">
      <span class="pill" id="blockHUD">0/20</span>
      <span class="pill" id="setInfo">Set 1 / 12</span>
      <span class="pill" id="blockInfo">Block 1 / 24</span>
      <span class="pill" id="accInfo">Acc 0% (req 20%)</span>
      <span class="pill" id="autoInfo">Auto-next: Off</span>
      <span class="pill" id="delayInfo">RT limit: 1183ms ‚Ä¢ Delay: 1000ms</span>
      <span class="pill" id="blockTimeInfo">TimeBlock 1/5 00:00/06:00</span>
      <span class="pill" id="timerInfo">Block 1/5</span>
      <span class="pill" id="oobStatusPill">OOB 15%</span>
    </div>
    <div id="barControls">
      <button id="btnPlay">‚ñ∂ Play</button>
      <button id="btnPause">‚è∏ Pause</button>
      <button id="btnToggleAuto">‚èØ Toggle Auto-next</button>
      <input id="delaySlider" type="range" min="0" max="2000" step="50" value="1000" style="width:220px">
      <button id="btnBackMenu">‚Ü© Menu</button>
    </div>

    <!-- Note pad -->
    <div class="note-pad" id="notePad"></div>
    <div class="note-pad" style="margin-top:6px">
      <button class="note wide" id="btnOOB" type="button">Out of Bounds</button>
    </div>

    <!-- Binary pad for specials -->
    <div class="note-pad" id="binaryPad" style="display:none">
      <button class="note" id="btnTarget" type="button">Target</button>
      <button class="note" id="btnOther" type="button">Other (OOB)</button>
    </div>

    <p style="opacity:.75;margin-top:8px">800 ms tone ‚Ä¢ RT limit adapts with set size ‚Ä¢ 24 blocks per set ‚Ä¢ Octaves randomized (C3‚ÄìB5)</p>
  </div>

  <!-- Assessment Screen -->
  <div id="assessmentScreen" class="screen">
    <div class="card">
      <h2>üìä Assessment Test</h2>
      <div class="row">
        <span class="pill" id="assessmentProgress">Trial 0 / 20</span>
        <button id="btnBackMenuAssessment">‚Ü© Menu</button>
      </div>
      
      <div style="text-align:center;margin:20px 0">
        <span id="assessmentPrompt" class="pill">Press Start to begin assessment</span>
        <div style="margin-top:12px">
          <button id="btnStartAssessment">‚ñ∂ Start Assessment</button>
        </div>
      </div>
      
      <!-- Note pad for assessment -->
      <div class="note-pad" id="assessmentPad"></div>
      
      <div id="assessmentResults" style="display:none;text-align:center;margin-top:20px">
        <h3>Assessment Results</h3>
        <div id="assessmentStats" style="margin:16px 0"></div>
        <button id="btnRetryAssessment">Try Again</button>
        <button id="btnBackMenuFromResults">Back to Menu</button>
      </div>
      
      <p style="opacity:.75;margin-top:8px">20 random pitches using random audio types ‚Ä¢ No feedback during test</p>
    </div>
  </div>

  <!-- Feedback -->
  <div id="feedbackOverlay"><div id="feedbackBox"></div></div>

  <!-- Shepard overlay -->
  <div id="shepardOverlay">
    <div id="shepardBox">
      <h3>üîá Memory reset</h3>
      <p>Playing a 20-second Shepard tone‚Ä¶</p>
      <p id="shepardCountdown">20</p>
    </div>
  </div>

  <!-- Flappy -->
  <div id="flappyModal">
    <div class="card" style="text-align:center">
      <div style="position: relative;">
        <h3>üê§ Flappy Break</h3>
        <!-- E) Sound toggle checkbox at top-right -->
        <label id="flappySoundToggleLabel" style="position: absolute; top: 0; right: 0; display: flex; align-items: center; font-size: 13px; opacity: 0.9; cursor: pointer;">
          <input type="checkbox" id="flappySoundCheckbox" style="margin-right: 6px;">
          Mute Flappy sound
        </label>
      </div>
      <canvas id="flappyCanvas" width="320" height="480"></canvas>
      <div style="margin-top:8px">
        <button id="flappySoundToggle" style="margin-right:8px">üîä Sound On</button>
        <button id="flappyClose">Close</button>
      </div>
      <p id="flappyScore">Score: 0 ‚Ä¢ Best: 0</p>
      <p style="opacity:.8;font-size:12px">Tap/click (or Space) to flap. First tap starts ‚Äî each flap makes a flappy sound during breaks or plays a pitch during rewards.</p>
    </div>
  </div>

  <!-- Assessment Warning Modal -->
  <div id="assessmentWarningModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Test</h2>
      <p><strong>Timing Recommendations:</strong></p>
      <ul style="text-align:left;margin:16px 0">
        <li>Take this test at the <strong>start of your 8-week training program</strong></li>
        <li>Take it again at the <strong>end of the 8 weeks</strong> to track improvement</li>
        <li>Optionally take it <strong>weekly</strong> to monitor progress</li>
      </ul>
      <p style="opacity:0.8">This test uses 20 random pitches across different audio types without feedback to assess your current absolute pitch ability.</p>
      <div style="margin-top:20px">
        <button id="btnProceedAssessment" style="background:var(--good);margin:0 8px">Continue to Test</button>
        <button id="btnCancelAssessment" style="background:var(--muted);margin:0 8px">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Assessment Results Modal -->
  <div id="assessmentResultsModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Complete!</h2>
      <div id="modalAssessmentStats" style="margin:20px 0;font-size:18px"></div>
      <p style="opacity:0.8;margin:16px 0">Your results have been saved to the tracker.</p>
      <div style="margin-top:20px">
        <button id="btnRetakeAssessmentModal" style="background:var(--good);margin:0 8px">Try Again</button>
        <button id="btnBackMenuModal" style="background:var(--muted);margin:0 8px">Back to Menu</button>
      </div>
    </div>
  </div>

  <!-- Cold Recall Modal -->
  <div id="coldRecallModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:80">
    <div class="card" style="max-width:600px;margin:20px;text-align:center">
      <h2>üßä Cold Recall</h2>
      <p style="opacity:0.8;margin:16px 0">Hum the following notes <em>before</em> training begins. This tests your baseline pitch recognition.</p>
      <div id="coldRecallNotes" style="margin:20px 0">
        <!-- Notes will be populated dynamically -->
      </div>
      <div style="margin-top:20px">
        <button id="btnColdRecallComplete" style="background:var(--good);margin:0 8px;display:none">Start Training</button>
      </div>
    </div>
  </div>

  <!-- Warm Recall Modal -->
  <div id="warmRecallModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:80">
    <div class="card" style="max-width:600px;margin:20px;text-align:center">
      <h2>üî• Warm Recall</h2>
      <p style="opacity:0.8;margin:16px 0">Great job! Now hum the same notes <em>after</em> your training session to see improvement.</p>
      <div id="warmRecallNotes" style="margin:20px 0">
        <!-- Notes will be populated dynamically -->
      </div>
      <div style="margin-top:20px">
        <button id="btnWarmRecallComplete" style="background:var(--good);margin:0 8px;display:none">Finish Session</button>
      </div>
    </div>
  </div>

  <!-- Strict session modal -->
  <div id="strictModal" aria-modal="true" role="dialog">
    <div id="strictBox" class="card">
      <h3>‚ö†Ô∏è Don‚Äôt break your session</h3>
      <p>Training is meant to be one strict 30-minute session without interruption. Please finish, then wait until tomorrow.</p>
      <div id="strictBtns">
        <button id="btnStrictResume">Resume Training</button>
        <button id="btnStrictMenu">Go to Menu</button>
      </div>
    </div>
  </div>

  <!-- New Pitch Introduction Modal -->
  <div id="newPitchModal" aria-modal="true" role="dialog">
    <div id="newPitchBox" class="card">
      <h2>üéâ Well Done!</h2>
      <p id="newPitchMessage">Now you are learning: <strong id="newPitchName">F</strong></p>
      <div id="newPitchBtns">
        <button id="btnHearNewPitch">üîä Hear It</button>
        <button id="btnContinueTraining">Continue</button>
      </div>
    </div>
  </div>

  <div id="bootError"></div>

<script src="./detectors/pitch.js"></script>
<script>
/* ------------------ CONSTANTS ------------------ */
const AUDIO_PIANO='./audio';
const AUDIO_GUITAR='./Guitar';
const AUDIO_TYPES = {PIANO: 'piano', SINE: 'sine', GUITAR: 'guitar'};

/* ------------------ RECALL CONSTANTS ------------------ */
// MIDI pitch class base values (octave 4)
const MIDI_PC_BASE = {
  A: 69, Bb: 70, B: 71, C: 72, Db: 73, D: 74, 
  Eb: 75, E: 76, F: 77, Gb: 78, G: 79, Ab: 80
};

// Audio sampling rate for recall system
const RECALL_SAMPLE_RATE = 44100;

// Timbre ranges for direct sample usage (no octave remapping)
const TIMBRE_RANGE = {
  sine: [3, 5],    // synth
  piano: [3, 5],   // use piano assets directly
  guitar: [3, 5]   // existing wav programmatic set
};

// Piano sample map: sampleMap.piano[PC][octave] = AudioBuffer
const sampleMap = {
  piano: {}
};

// Expose sampleMap to global scope for debugging
window.sampleMap = sampleMap;

// Asset reporting for debugging
window.assetsReport = {
  piano: { present: [], missing: [] }
};

// Theme definitions
const THEMES = {
  default: {
    name: 'Dark Ocean',
    bg: '#0f172a',
    card: '#1e293b', 
    muted: '#334155',
    muted2: '#2a3a54',
    text: '#e5e7eb',
    good: '#16a34a',
    bad: '#dc2626',
    accent: '#fbbf24',
    neutral: '#94a3b8'
  },
  beach: {
    name: 'Beach Sunset',
    bg: '#0f2027',
    card: '#2c5aa0',
    muted: '#44749d',
    muted2: '#5a86ba',
    text: '#fff8dc',
    good: '#ff7f50',
    bad: '#dc143c',
    accent: '#ffa500',
    neutral: '#87ceeb'
  },
  jungle: {
    name: 'Jungle Canopy', 
    bg: '#1a2f1a',
    card: '#2d4a2d',
    muted: '#456545',
    muted2: '#3a5a3a',
    text: '#e8f5e8',
    good: '#32cd32',
    bad: '#cd5c5c',
    accent: '#adff2f',
    neutral: '#9acd32'
  },
  sky: {
    name: 'Cloud Nine',
    bg: '#e6f2ff',
    card: '#ffffff',
    muted: '#b8d4f0',
    muted2: '#a3c9ea',
    text: '#1e3a8a',
    good: '#10b981',
    bad: '#ef4444',
    accent: '#3b82f6',
    neutral: '#6b7280'
  },
  desert: {
    name: 'Desert Oasis',
    bg: '#2d1810',
    card: '#8b4513',
    muted: '#cd853f',
    muted2: '#a0522d',
    text: '#faebd7',
    good: '#daa520',
    bad: '#b22222',
    accent: '#ff8c00',
    neutral: '#d2b48c'
  },
  neon: {
    name: 'Neon Nights',
    bg: '#0a0a0f',
    card: '#1a1a2e',
    muted: '#16213e',
    muted2: '#0f172a',
    text: '#00ffff',
    good: '#00ff00',
    bad: '#ff1493',
    accent: '#ff00ff',
    neutral: '#9370db'
  },
  forest: {
    name: 'Mystic Forest',
    bg: '#0d1421',
    card: '#1e3a3a',
    muted: '#2f5a5a',
    muted2: '#1a3030',
    text: '#f0fff0',
    good: '#228b22',
    bad: '#dc143c',
    accent: '#ffd700',
    neutral: '#8fbc8f'
  }
};
const PC=["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
const PC_LABEL={ C:"C", Db:"C#/Db", D:"D", Eb:"D#/Eb", E:"E", F:"F", Gb:"F#/Gb", G:"G", Ab:"G#/Ab", A:"A", Bb:"A#/Bb", B:"B" };
const UNLOCK_ORDER = ["F","E","Gb","Eb","G","D","Ab","Db","A","C","Bb","B"];

/* ------------------ PITCH CLASS CANONICALIZER ------------------ */
function normalizePc(x) {
  if (!x) return null;
  x = String(x).trim();
  
  // Handle special case: Out of Bounds
  if (x.toUpperCase() === 'OOB' || x.toLowerCase() === 'out of bounds') return 'OOB';
  
  // Normalize common inputs
  x = x.replace(/\s+/g,'').replace(/‚ô≠/g,'b').toUpperCase();
  // Map sharps to flats (we store flats)
  const sharpToFlat = { 'A#':'Bb','C#':'Db','D#':'Eb','F#':'Gb','G#':'Ab' };
  if (sharpToFlat[x]) x = sharpToFlat[x];
  // Uppercase first letter, keep 'b' as lowercase
  if (/^[A-G]B$/.test(x)) x = x[0] + 'b';
  // Validate
  const CANON = ['A','Bb','B','C','Db','D','Eb','E','F','Gb','G','Ab'];
  return CANON.includes(x) ? x : null;
}

// Extract pitch class from note string (e.g., "Eb4" ‚Üí "Eb")
function pcFromNote(note) {
  if (!note) return null;
  const noteStr = String(note).trim();
  // Match pitch class at start: letter optionally followed by 'b' or '#'
  const match = noteStr.match(/^([A-G][b#]?)/);
  if (!match) return null;
  return normalizePc(match[1]);
}

const LEVELS_PER_SET=24, SETS=12, LEVELS_TOTAL=SETS*LEVELS_PER_SET;
const TONE_MS=800;
const THRESH_24=[0.20,0.25,0.30,0.35,0.40,0.45,0.50,0.55,0.60,0.60,0.65,0.70,0.75,0.78,0.80,0.83,0.85,0.88,0.90,0.90,0.90,0.90,0.90,0.90];
function blockHasFeedback(block){ return block<=20; }
function rtWindowForSet(n){const a=1183,b=2028;return Math.round(a+(n-1)*(b-a)/11);}
const OOB_RATE=0.25;
const SESS_DAILY_MS=30*60*1000;
const BLOCK_DURATION_MS=6*60*1000;
const BREAK_DURATION_MS=60*1000;
const WEEKLY_TARGET_MS=2*3600*1000;
const LOCKOUT_MS=60*60*1000;
const LATENCY_CUSHION_MS=100;

/* ------------------ DAILY SESSION CONSTANTS ------------------ */
const DAILY_BLOCK_COUNT = 5;
const DAILY_BLOCK_DURATION_MS = 6 * 60 * 1000; // 6 minutes
const DAILY_BREAK_DURATION_MS = 60 * 1000; // 60 seconds
const DAILY_SESSION_TOTAL_MS = DAILY_BLOCK_COUNT * DAILY_BLOCK_DURATION_MS; // 30 minutes

// QA mode constants (when ?qa=1 in URL)
const QA_BLOCK_DURATION_MS = 30 * 1000; // 30 seconds
const QA_BREAK_DURATION_MS = 10 * 1000; // 10 seconds

/* ------------------ JITTER SYSTEM CONSTANTS ------------------ */
const JITTER_LEVELS = {
  0: { // JL0 (onboarding)
    jitterMin: 3, jitterMax: 8,
    probeRate: 0.02, 
    anchorRate: 0.10
  },
  1: { // JL1 (early)  
    jitterMin: 5, jitterMax: 10,
    probeRate: 0.05,
    anchorRate: 0.08
  },
  2: { // JL2 (mid)
    jitterMin: 5, jitterMax: 15,
    probeRate: 0.08,
    anchorRate: 0.05
  },
  3: { // JL3 (mature)
    jitterMin: 5, jitterMax: 15,
    probeRate: 0.11,
    anchorRate: 0.05
  }
};

/* ------------------ THEME SYSTEM ------------------ */
function applyTheme(themeName) {
  const theme = THEMES[themeName] || THEMES.default;
  const root = document.documentElement;
  
  root.style.setProperty('--bg', theme.bg);
  root.style.setProperty('--card', theme.card);
  root.style.setProperty('--muted', theme.muted);
  root.style.setProperty('--muted2', theme.muted2);
  root.style.setProperty('--text', theme.text);
  root.style.setProperty('--good', theme.good);
  root.style.setProperty('--bad', theme.bad);
  root.style.setProperty('--accent', theme.accent);
  root.style.setProperty('--neutral', theme.neutral);
}

/* ------------------ AUDIO RECORDING AND PITCH DETECTION ------------------ */
let recallAudioContext = null;
let recallAnalyser = null;
let recallMicrophone = null;
let recallDataArray = null;

// Initialize audio recording system
async function initRecallAudio() {
  try {
    // Request microphone access
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: { 
        sampleRate: RECALL_SAMPLE_RATE,
        channelCount: 1,
        echoCancellation: false,
        noiseSuppression: false 
      } 
    });
    
    // Create audio context and analyser
    recallAudioContext = new (window.AudioContext || window.webkitAudioContext)();
    recallAnalyser = recallAudioContext.createAnalyser();
    recallMicrophone = recallAudioContext.createMediaStreamSource(stream);
    
    // Configure analyser for pitch detection
    recallAnalyser.fftSize = 4096;
    recallAnalyser.smoothingTimeConstant = 0.8;
    recallMicrophone.connect(recallAnalyser);
    
    // Create data array for frequency analysis
    recallDataArray = new Uint8Array(recallAnalyser.frequencyBinCount);
    
    return true;
  } catch (error) {
    console.error('Failed to initialize recall audio:', error);
    return false;
  }
}

// Convert Hz to MIDI number
function hzToMidi(hz) {
  return 69 + 12 * Math.log2(hz / 440);
}

// Get fundamental frequency using autocorrelation
function getFundamentalFrequency() {
  if (!recallAnalyser || !recallDataArray) return null;
  
  // Get time domain data for autocorrelation
  const bufferSize = recallAnalyser.fftSize;
  const timeData = new Float32Array(bufferSize);
  recallAnalyser.getFloatTimeDomainData(timeData);
  
  // Simple autocorrelation-based pitch detection
  const sampleRate = recallAudioContext.sampleRate;
  const minPeriod = Math.floor(sampleRate / 800); // ~800 Hz max
  const maxPeriod = Math.floor(sampleRate / 80);  // ~80 Hz min
  
  let bestPeriod = 0;
  let bestCorrelation = 0;
  
  // Find the period with highest autocorrelation
  for (let period = minPeriod; period <= maxPeriod; period++) {
    let correlation = 0;
    for (let i = 0; i < bufferSize - period; i++) {
      correlation += timeData[i] * timeData[i + period];
    }
    
    if (correlation > bestCorrelation) {
      bestCorrelation = correlation;
      bestPeriod = period;
    }
  }
  
  // Return frequency if correlation is strong enough
  if (bestCorrelation > 0.01 && bestPeriod > 0) {
    return sampleRate / bestPeriod;
  }
  
  return null;
}

// Record audio for specified duration and collect pitch data
async function recordPitchData(durationMs) {
  if (!recallAudioContext || !recallAnalyser) {
    throw new Error('Audio system not initialized');
  }
  
  const frames = [];
  const startTime = Date.now();
  const endTime = startTime + durationMs;
  
  return new Promise((resolve) => {
    function collectFrame() {
      const now = Date.now();
      if (now >= endTime) {
        resolve(frames);
        return;
      }
      
      const hz = getFundamentalFrequency();
      if (hz && hz > 80 && hz < 800) { // Valid vocal range
        frames.push({
          t: now - startTime,
          hz: hz
        });
      }
      
      // Continue collecting at ~60fps
      setTimeout(collectFrame, 16);
    }
    
    collectFrame();
  });
}

// Calculate nearest MIDI number for a given pitch class
function getNearestMidiForPC(midiValue, pitchClass) {
  const baseMidi = MIDI_PC_BASE[pitchClass];
  if (!baseMidi) return null;
  
  // Find the nearest octave for this pitch class
  const octaveOffset = Math.round((midiValue - baseMidi) / 12) * 12;
  return baseMidi + octaveOffset;
}

// Analyze recorded frames and compute statistics
function analyzeRecallTake(frames, targetPC) {
  if (!frames || frames.length === 0) {
    return {
      medianCents: null,
      sdCents: null,
      verdict: 'no-signal',
      nearestMidi: null,
      framesCount: 0
    };
  }
  
  // Convert Hz to MIDI and calculate cents offset from nearest target
  const centsList = [];
  let nearestMidi = null;
  
  for (const frame of frames) {
    const midiValue = hzToMidi(frame.hz);
    const targetMidi = getNearestMidiForPC(midiValue, targetPC);
    
    if (targetMidi !== null) {
      const cents = 100 * (midiValue - targetMidi);
      centsList.push(cents);
      
      if (nearestMidi === null) {
        nearestMidi = targetMidi;
      }
    }
  }
  
  if (centsList.length === 0) {
    return {
      medianCents: null,
      sdCents: null,
      verdict: 'no-signal',
      nearestMidi: null,
      framesCount: frames.length
    };
  }
  
  // Calculate median
  const sorted = [...centsList].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  const medianCents = sorted.length % 2 === 0 
    ? (sorted[mid - 1] + sorted[mid]) / 2 
    : sorted[mid];
  
  // Calculate standard deviation
  const mean = centsList.reduce((sum, c) => sum + c, 0) / centsList.length;
  const variance = centsList.reduce((sum, c) => sum + Math.pow(c - mean, 2), 0) / centsList.length;
  const sdCents = Math.sqrt(variance);
  
  // Determine verdict
  let verdict;
  if (Math.abs(medianCents) <= 10 && sdCents <= 15) {
    verdict = 'on-target';
  } else if (Math.abs(medianCents) <= 30) {
    verdict = 'close';
  } else {
    verdict = 'off';
  }
  
  return {
    medianCents: Math.round(medianCents * 10) / 10, // Round to 1 decimal
    sdCents: Math.round(sdCents * 10) / 10,
    verdict,
    nearestMidi,
    framesCount: frames.length
  };
}
function byId(id){ return document.getElementById(id); }
function safe(id, fn){ const el=byId(id); if(el) try{ fn(el); }catch(e){report(e);} }
function showFlex(id){ safe(id, el=> el.style.display='flex'); }
function showBlock(id){ safe(id, el=> el.style.display='block'); }
function hide(id){ safe(id, el=> el.style.display='none'); }
function text(id, v){ safe(id, el=> el.textContent=v); }
function report(err){ const el=byId('bootError'); if(!el) return; el.style.display='block'; el.textContent = '‚ö†Ô∏è Script error: ' + (err && err.message ? err.message : String(err)); if(err && err.stack){ el.textContent += '\n' + err.stack; } }

let state;
try{
  state = JSON.parse(localStorage.getItem('apTrainer')||'null') || {
    userName:null,
    levelIndex:1,
    levelTrials:0, levelCorrect:0,
    shepardDoneFor:-1,
    sessions:[], trials:[],
    startDate:null, lockoutUntil:null, capResetAt:null,
    testFailStreak:0, suggestShownSet:null,
    lastSeen:null, flappyHighScore:0,
    thisWeekIdx:0, thisWeekMs:0,
    levelFailCounts:{},
    specialRanForLevel:null,
    audioType: AUDIO_TYPES.PIANO,
    assessmentScores: [],
    theme: 'default',
    flappySoundEnabled: true,
    flappyMuted: false,
    currentBlock: 1,
    blockStartTime: null,
    inBreak: false,
    breakStartTime: null,
    totalBlocks: 25,
    timeblock: {
      activeMs: 0,
      running: false,
      startedAt: null,
      breaksCompletedToday: 0,
      breakActive: false,
      breakEndsAt: null
    },
    oobController: {
      targetOobPct: 15,
      lastAdaptTimeBlock: 0,
      last60InBounds: [],
      recentOobTrials: [],
      healthCheckActive: false,
      healthCheckEndTimeBlock: 0,
      globalTimeBlockIndex: 0,
      oobSeries: []
    },
    trialOpen: false,
    toneStartMs: null,
    jitter: {
      levelByPc: {},
      statsByPc: {}
    },
    session: {
      startedAt: null,        // timestamp when session started
      elapsedMs: 0,          // total elapsed time in current session
      blocksDone: 0,         // number of complete blocks (0..5)
      blockElapsedMs: 0,     // elapsed time in current block (0..360000)
      inBreak: false,        // currently in break mode
      breakRemainingMs: 0    // time remaining in current break (0..60000)
    },
    daily: {
      date: getTodayDateString(), // YYYY-MM-DD format
      minutesCompleted: 0,        // total minutes completed today (0..30)
      completedAt: null           // timestamp when 30 min reached, null if not complete
    },
    timbre: {
      chosen: AUDIO_TYPES.PIANO,  // 'piano' | 'guitar' | 'sine' - from main menu
      mode: 'single',             // 'single' | 'variety' - user-controlled; default 'single' on fresh install
      recommendFromDate: null,    // set on first training day = date + 14 days (YYYY-MM-DD)
      currentProportions: { chosen: 1.0, alt: 0.0 }, // single: {1,0}; variety: {0.8,0.2}
      altPool: [AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR], // excludes chosen
      rotationIndex: 0,           // advances daily; altOfDay = altPool[rotationIndex % altPool.length]
      perPcStats: {},             // [pc]: { [timbre]: { last40:[], acc:0..1, medianCents, sdCents } }
      rescue: {},                 // [pc]: { [timbre]: { active:boolean, untilBlock:number } }
      history: []                 // log decisions & rescues
    },
    warmRecallPending: false      // flag to show warm recall when returning to menu after 30min completion
  };
} catch(e){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, shepardDoneFor:-1, sessions:[], trials:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null, audioType: AUDIO_TYPES.PIANO, currentBlock: 1, blockStartTime: null, inBreak: false, breakStartTime: null, totalBlocks: 25, timeblock: { activeMs: 0, running: false, startedAt: null, breaksCompletedToday: 0, breakActive: false, breakEndsAt: null }, oobController: { targetOobPct: 15, lastAdaptTimeBlock: 0, last60InBounds: [], recentOobTrials: [], healthCheckActive: false, healthCheckEndTimeBlock: 0, globalTimeBlockIndex: 0, oobSeries: [] }, inBoundsLast60: [], trainingBlockIndex: 1, trainingBlockTrials: 0, currentBlockOctaveCount: {3: 0, 4: 0, 5: 0}, oobHealthCheckActive: false, oobHealthCheckEndBlock: 0, oob: { targetPct: 0.15, streak: 0, blockTarget: 0, plan: [], planOctaveMix: [], currentBlockIndex: 0, currentTrialInBlock: 0 }, trialOpen: false, toneStartMs: null };
}
// Migration for audioType
if (!state.audioType) {
  state.audioType = AUDIO_TYPES.PIANO;
  save();
}
// Migration for block tracking
if (typeof state.currentBlock === 'undefined') {
  state.currentBlock = 1;
  state.blockStartTime = null;
  state.inBreak = false;
  state.breakStartTime = null;
  state.totalBlocks = 25;
  save();
}
// Migration for assessmentScores
if (!state.assessmentScores) {
  state.assessmentScores = [];
  save();
}
// Migration for theme
if (!state.theme) {
  state.theme = 'default';
  save();
}
// Migration for flappyMuted
if (state.flappyMuted === undefined) {
  state.flappyMuted = false;
  save();
}
// Migration for timeblock system
if (!state.timeblock) {
  state.timeblock = {
    activeMs: 0,
    running: false,
    startedAt: null,
    breaksCompletedToday: 0,
    breakActive: false,
    breakEndsAt: null
  };
  save();
}
// Normalize timeblock state on load
normalizeTimeBlockState();
// Migration for oobController
if (!state.oobController) {
  state.oobController = {
    targetOobPct: 15,
    lastAdaptTimeBlock: 0,
    last60InBounds: [],
    recentOobTrials: [],
    healthCheckActive: false,
    healthCheckEndTimeBlock: 0,
    globalTimeBlockIndex: 0,
    oobSeries: []
  };
  save();
}

// Migration for new OOB adaptation system
if (!state.oobController.last60InBounds) {
  state.oobController.last60InBounds = [];
  save();
}
if (!state.oobController.recentOobTrials) {
  state.oobController.recentOobTrials = [];
  save();
}
if (typeof state.oobController.healthCheckActive === 'undefined') {
  state.oobController.healthCheckActive = false;
  state.oobController.healthCheckEndBlock = 0;
  save();
}
if (!state.oobController.oobSeries) {
  state.oobController.oobSeries = [];
  save();
}
// Migration for new adaptive OOB state
if (typeof state.oobTargetPct === 'undefined') {
  state.oobTargetPct = 0.15;  // Convert from percentage to decimal
  state.oobStreak = 0;
  state.inBoundsLast60 = [];
  state.trainingBlockIndex = Math.floor((state.levelIndex - 1) / 1) + 1;  // Current training block
  state.trainingBlockTrials = state.levelTrials || 0;
  state.currentBlockOctaveCount = {3: 0, 4: 0, 5: 0};
  state.oobHealthCheckActive = false;
  state.oobHealthCheckEndBlock = 0;
  save();
}

// Migration for new OOB pre-planning state structure
if (!state.oob) {
  state.oob = {
    targetPct: state.oobTargetPct || 0.15,  // Current adaptive target
    streak: state.oobStreak || 0,           // Consecutive OOB trials scheduled
    blockTarget: 0,                        // Frozen target for current block
    plan: [],                              // Array of 20 booleans for current block
    planOctaveMix: [],                     // Pre-computed octaves for planned OOB slots
    currentBlockIndex: 0,                  // Track which block we're in
    currentTrialInBlock: 0                 // Track which trial in current block (0-19)
  };
  // Clean up old state variables
  delete state.oobTargetPct;
  delete state.oobStreak;
  save();
}

// Migration for trial input locking properties
if (typeof state.trialOpen === 'undefined') {
  state.trialOpen = false;
  state.toneStartMs = null;
  save();
}

// Migration for current trial state (new grading system)
if (!state.current) {
  state.current = null;  // Will be set when trial starts
  save();
}

// Migration for jitter system
if (!state.jitter) {
  state.jitter = {
    levelByPc: {},
    statsByPc: {}
  };
  save();
}

// Migration for recall system
if (!state.recall) {
  state.recall = {}; // Format: state.recall[YYYY-MM-DD] = { cold: [...], warm: [...] }
  save();
}

// 4) Initialize review arrays for warm review pager
if (!state.recall.review) {
  state.recall.review = [];
}
if (typeof state.recall.reviewIndex === 'undefined') {
  state.recall.reviewIndex = 0;
}

// Migration for confusion tracking
if (!state.confusionMatrix || !state.perfStats || typeof state.lastInBoundsPc === 'undefined') {
  // Initialize confusion tracking structures
  state.confusionMatrix = {};
  for (const truePc of PC) {
    state.confusionMatrix[truePc] = {};
    for (const guessPc of PC) {
      state.confusionMatrix[truePc][guessPc] = 0;
    }
  }
  
  state.perfStats = {};
  for (const pc of PC) {
    state.perfStats[pc] = {
      last40InBounds: [],
      last40Acc: 0,
      meanRT: 0,
      totalSeen: 0
    };
  }
  
  state.lastInBoundsPc = null;
  save();
}

// Migration for atomic grading system
if (!state.meta) {
  state.meta = {
    trialSeq: 0  // Integer incrementing for each trial
  };
  save();
}

if (!state.grade) {
  state.grade = {
    lastTrialId: 0,
    inProgress: false
  };
  save();
}

// Initialize confusion scheduler state for frozen block weights
if (!state.conf) {
  state.conf = {
    blockWeights: {},           // Frozen weights for current 20-trial block
    topPairAtBlockStart: null,  // Top confusion pair computed at block start
    prevPc: null,               // Previous PC for anti-streak tracking
    runLen: 0,                  // Current run length for anti-streak
    oobPct: 15                  // OOB percentage (default 15)
  };
  save();
}

// Migration for new OOB percentage in conf
if (typeof state.conf.oobPct === 'undefined') {
  state.conf.oobPct = 15;
  save();
}

// Initialize counters for block system
if (!state.counters) {
  state.counters = {
    trialInBlock: 0,            // 0-19, current trial position in block
    blockIndex: 0               // Incrementing block counter
  };
  save();
}

// Migration for octave policy system
if (!state.oct) {
  state.oct = {
    allowed: [3,4,5],
    center: 4,
    baselineMix: {3:0.05, 4:0.90, 5:0.05},   // default start = 90/10 (5%+5%)
    currentMix:  {3:0.05, 4:0.90, 5:0.05},
    setCounter:  0,                           // how many 24-in-bounds "sets" we've completed
    inBoundsSinceSetStart: [],                // array of in-bounds trials since current set start
    history: [],                              // log of decisions
    perNoteOverrides: {}                      // per-note octave overrides for weak pitches
  };
  save();
}

// Migration for new daily session system
if (!state.session) {
  state.session = {
    startedAt: null,        // timestamp when session started
    elapsedMs: 0,          // total elapsed time in current session
    blocksDone: 0,         // number of complete blocks (0..5)
    blockElapsedMs: 0,     // elapsed time in current block (0..360000)
    inBreak: false,        // currently in break mode
    breakRemainingMs: 0    // time remaining in current break (0..60000)
  };
  save();
}

if (!state.daily) {
  state.daily = {
    date: getTodayDateString(), // YYYY-MM-DD format
    minutesCompleted: 0,        // total minutes completed today (0..30)
    completedAt: null           // timestamp when 30 min reached, null if not complete
  };
  save();
}

// Migration for timbre variety system
if (!state.timbre) {
  state.timbre = {
    chosen: state.audioType || AUDIO_TYPES.PIANO, // migrate existing audioType
    mode: 'single',
    recommendFromDate: null,    // set on first training day = date + 14 days
    currentProportions: { chosen: 1.0, alt: 0.0 },
    altPool: [AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR].filter(t => t !== (state.audioType || AUDIO_TYPES.PIANO)),
    rotationIndex: 0,
    perPcStats: {},
    rescue: {},
    history: []
  };
  save();
}

// Migrate old structure to new structure
if (state.timbre && !state.timbre.hasOwnProperty('recommendFromDate')) {
  // Update existing timbre state to match new requirements
  const oldVarietyStartDate = state.timbre.varietyStartDate;
  state.timbre.recommendFromDate = oldVarietyStartDate; // migrate old field
  
  // Remove old fields
  delete state.timbre.enabled;
  delete state.timbre.varietyStartDate; 
  delete state.timbre.today;
  
  // Ensure current proportions are correct
  if (state.timbre.mode === 'variety') {
    state.timbre.currentProportions = { chosen: 0.8, alt: 0.2 };
  } else {
    state.timbre.currentProportions = { chosen: 1.0, alt: 0.0 };
  }
  
  save();
}

// Migration for warmRecallPending flag
if (typeof state.warmRecallPending === 'undefined') {
  state.warmRecallPending = false;
  save();
}

// Reset daily progress if date has changed (date rollover)
if (state.daily && state.daily.date !== getTodayDateString()) {
  state.daily = {
    date: getTodayDateString(),
    minutesCompleted: 0,
    completedAt: null
  };
  // Reset session state on date rollover
  state.session = {
    startedAt: null,
    elapsedMs: 0,
    blocksDone: 0,
    blockElapsedMs: 0,
    inBreak: false,
    breakRemainingMs: 0
  };
  // Update timbre today field and rotation
  if (state.timbre) {
    state.timbre.today = getTodayDateString();
    // Advance rotation index for variety mode
    if (state.timbre.mode === 'variety') {
      state.timbre.rotationIndex = (state.timbre.rotationIndex + 1) % state.timbre.altPool.length;
    }
  }
  save();
}

// Apply theme on load
applyTheme(state.theme);
function save(){ try{ localStorage.setItem('apTrainer', JSON.stringify(state)); }catch(e){ report(e); } }
window.state = state;

/* ------------------ TIME HELPERS ------------------ */
function fmtMMSS(ms){ const s=Math.max(0,Math.floor(ms/1000)); const m=Math.floor(s/60); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
function fmtHMM(ms){ const s=Math.max(0,Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h}h ${String(m).padStart(2,'0')}m`; }
function fmtHrsMins(ms){ let s=Math.max(0, Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h} hr${h===1?'':'s'} ${m} min${m===1?'':'s'}`; }
function dateAtMidnight(ts){ const d=new Date(ts); d.setHours(0,0,0,0); return d.getTime(); }
function todayKey(ts){ return dateAtMidnight(ts||Date.now()); }
function weekIndex(ts){ const base=ts||Date.now(); if(!state.startDate) return 0; return Math.floor((base-state.startDate)/(7*24*60*60*1000)); }
function currentWeekIdx(){ return weekIndex(Date.now()); }
function weekStartTs(){ if(!state.startDate) return todayKey(Date.now()); const idx=currentWeekIdx(); const base=dateAtMidnight(state.startDate); return base + idx*7*86400000; }

/* ------------------ TIMBRE VARIETY SYSTEM ------------------ */

function initTimbreVarietySystem() {
  if (!state.startDate) return; // No training started yet
  
  // Set recommend date if not already set (first training day + 14 days)
  if (!state.timbre.recommendFromDate) {
    const startDate = new Date(state.startDate);
    startDate.setDate(startDate.getDate() + 14);
    state.timbre.recommendFromDate = startDate.toISOString().split('T')[0]; // YYYY-MM-DD format
    save();
  }
  
  // Update rotation index based on days since recommend date
  updateTimbreRotation();
  
  // Update mode based on user setting and current proportions
  updateTimbreMode();
  
  // Update alt pool when chosen timbre changes
  updateAltPool();
}

function updateTimbreRotation() {
  if (!state.timbre.recommendFromDate) return;
  
  const today = new Date(getTodayDateString());
  const recommendDate = new Date(state.timbre.recommendFromDate);
  const daysDiff = Math.max(0, Math.floor((today - recommendDate) / (24 * 60 * 60 * 1000)));
  
  // Update rotation index based on day difference
  state.timbre.rotationIndex = daysDiff;
}

function updateTimbreMode() {
  // Set proportions based on current mode (user-controlled)
  if (state.timbre.mode === 'variety') {
    state.timbre.currentProportions = { chosen: 0.8, alt: 0.2 };
  } else {
    state.timbre.currentProportions = { chosen: 1.0, alt: 0.0 };
  }
}

function updateAltPool() {
  const allTypes = [AUDIO_TYPES.PIANO, AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR];
  state.timbre.altPool = allTypes.filter(t => t !== state.timbre.chosen);
  
  // If empty pool, rebuild from all types excluding chosen
  if (state.timbre.altPool.length === 0) {
    state.timbre.altPool = ['sine', 'piano', 'guitar'].filter(t => t !== state.timbre.chosen);
  }
}

function processTimbreRescuesAtBlockBoundary(blockIndex) {
  if (!state.timbre || !state.timbre.perPcStats) return;
  
  const trainedPCs = trainedSet(setFromIndex(state.levelIndex));
  const allTimbres = ['piano', 'sine', 'guitar'];
  
  // Check each (PC, timbre) combination for rescue start/end
  for (const pc of trainedPCs) {
    for (const timbre of allTimbres) {
      const stats = state.timbre.perPcStats[pc]?.[timbre];
      if (!stats || stats.last40.length < 10) continue; // Need at least 10 trials
      
      if (!state.timbre.rescue[pc]) {
        state.timbre.rescue[pc] = {};
      }
      
      const rescue = state.timbre.rescue[pc][timbre] || { active: false, untilBlock: 0 };
      
      // Check if rescue should start
      const needsRescue = stats.acc < 0.75 || Math.abs(stats.medianCents) > 25;
      
      if (needsRescue && !rescue.active) {
        // Start rescue
        rescue.active = true;
        rescue.untilBlock = blockIndex + 1; // Active for next 1 full block
        state.timbre.rescue[pc][timbre] = rescue;
        
        // Log rescue start
        state.timbre.history.push({
          ts: Date.now(),
          blockIndex: blockIndex,
          pc,
          timbre,
          event: 'rescue-start',
          acc: Math.round(stats.acc * 1000) / 1000,
          median: Math.round(stats.medianCents * 10) / 10,
          sd: Math.round(stats.sdCents * 10) / 10
        });
        
        console.log(`üîÑ Rescue started for ${pc}/${timbre}: acc=${stats.acc.toFixed(3)}, median=${stats.medianCents.toFixed(1)}¬¢`);
      } else if (rescue.active) {
        // Check if rescue should end
        const rescueCanEnd = stats.acc >= 0.80 && Math.abs(stats.medianCents) <= 20;
        
        if (rescueCanEnd || blockIndex > rescue.untilBlock) {
          // End rescue
          rescue.active = false;
          state.timbre.rescue[pc][timbre] = rescue;
          
          // Log rescue end
          const endEvent = rescueCanEnd ? 'rescue-end' : 'rescue-timeout';
          state.timbre.history.push({
            ts: Date.now(),
            blockIndex: blockIndex,
            pc,
            timbre,
            event: endEvent,
            acc: Math.round(stats.acc * 1000) / 1000,
            median: Math.round(stats.medianCents * 10) / 10,
            sd: Math.round(stats.sdCents * 10) / 10
          });
          
          console.log(`‚úÖ Rescue ended for ${pc}/${timbre}: acc=${stats.acc.toFixed(3)}, median=${stats.medianCents.toFixed(1)}¬¢`);
        }
      }
    }
  }
}

function findActiveRescueForPc(pc) {
  if (!state.timbre.rescue[pc]) return null;
  
  const currentBlock = blockFromIndex(state.levelIndex);
  
  // Check all timbres for this PC
  for (const timbre of Object.keys(state.timbre.rescue[pc])) {
    const rescue = state.timbre.rescue[pc][timbre];
    if (rescue.active && currentBlock <= rescue.untilBlock) {
      return { timbre, rescue };
    }
  }
  
  return null;
}

function selectTimbreForTrial(pc) {
  // Initialize if needed
  initTimbreVarietySystem();
  
  const chosen = state.timbre.chosen;
  
  // Check if a rescue is active for this PC
  const activeRescue = findActiveRescueForPc(pc);
  if (activeRescue) {
    // During rescue: 50% weakTimbre / 50% chosen, others get 0%
    const weakTimbre = activeRescue.timbre;
    return Math.random() < 0.5 ? weakTimbre : chosen;
  }
  
  // Calculate altOfDay using rotation index
  const altOfDay = state.timbre.altPool.length > 0 ? 
    state.timbre.altPool[state.timbre.rotationIndex % state.timbre.altPool.length] : 
    chosen; // fallback if no alt pool
  
  // If mode === 'single' ‚Üí return chosen
  if (state.timbre.mode === 'single') {
    return chosen;
  }
  
  // If mode === 'variety' ‚Üí sample from { chosen:0.8, alt:0.2 }
  if (state.timbre.mode === 'variety') {
    const useAlt = Math.random() < state.timbre.currentProportions.alt;
    return useAlt ? altOfDay : chosen;
  }
  
  // Fallback to chosen
  return chosen;
}

function updateTimbreStats(pc, timbre, correct, detuneCents) {
  if (!state.timbre.perPcStats[pc]) {
    state.timbre.perPcStats[pc] = {};
  }
  if (!state.timbre.perPcStats[pc][timbre]) {
    state.timbre.perPcStats[pc][timbre] = {
      last40: [],
      acc: 0,
      medianCents: 0,
      sdCents: 0
    };
  }
  
  const stats = state.timbre.perPcStats[pc][timbre];
  
  // Add to last40 (keep only last 40 trials)
  stats.last40.push({ correct, detuneCents: detuneCents || 0 });
  if (stats.last40.length > 40) {
    stats.last40.shift();
  }
  
  // Update accuracy
  if (stats.last40.length > 0) {
    stats.acc = stats.last40.filter(t => t.correct).length / stats.last40.length;
  }
  
  // Update median and SD of detune cents
  if (stats.last40.length > 0) {
    const cents = stats.last40.map(t => t.detuneCents).sort((a, b) => a - b);
    stats.medianCents = cents[Math.floor(cents.length / 2)];
    const mean = cents.reduce((a, b) => a + b, 0) / cents.length;
    const variance = cents.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / cents.length;
    stats.sdCents = Math.sqrt(variance);
  }
  
  // Check if rescue needed
  checkTimbreRescue(pc, timbre);
}

function checkTimbreRescue(pc, timbre) {
  const stats = state.timbre.perPcStats[pc]?.[timbre];
  if (!stats || stats.last40.length < 10) return; // Need at least 10 trials
  
  const needsRescue = stats.acc < 0.75 || Math.abs(stats.medianCents) > 25;
  
  if (!state.timbre.rescue[pc]) {
    state.timbre.rescue[pc] = {};
  }
  
  const rescue = state.timbre.rescue[pc][timbre] || { active: false, untilBlock: 0 };
  
  if (needsRescue && !rescue.active) {
    // Start rescue
    rescue.active = true;
    rescue.untilBlock = (state.currentBlock || 1) + 1; // Next 1 block
    state.timbre.rescue[pc][timbre] = rescue;
    
    // Log rescue start
    state.timbre.history.push({
      ts: Date.now(),
      blockIndex: state.currentBlock || 1,
      pc,
      timbre,
      event: 'rescue-start',
      acc: stats.acc,
      median: stats.medianCents
    });
    
    save();
  } else if (rescue.active && stats.acc >= 0.80 && Math.abs(stats.medianCents) <= 20) {
    // End rescue
    rescue.active = false;
    state.timbre.rescue[pc][timbre] = rescue;
    
    // Log rescue end
    state.timbre.history.push({
      ts: Date.now(),
      blockIndex: state.currentBlock || 1,
      pc,
      timbre,
      event: 'rescue-end',
      acc: stats.acc,
      median: stats.medianCents
    });
    
    save();
  }
}

function logTimbreBlockEnd() {
  // Collect active rescues
  const activeRescues = [];
  if (state.timbre.rescue) {
    const currentBlock = blockFromIndex(state.levelIndex);
    for (const pc of Object.keys(state.timbre.rescue)) {
      for (const timbre of Object.keys(state.timbre.rescue[pc])) {
        const rescue = state.timbre.rescue[pc][timbre];
        if (rescue.active && currentBlock <= rescue.untilBlock) {
          activeRescues.push({ pc, timbre, untilBlock: rescue.untilBlock });
        }
      }
    }
  }
  
  // Log block summary
  const altTimbre = state.timbre.altPool.length > 0 ? 
    state.timbre.altPool[state.timbre.rotationIndex % state.timbre.altPool.length] : null;
  
  state.timbre.history.push({
    ts: Date.now(),
    blockIndex: blockFromIndex(state.levelIndex),
    mode: state.timbre.mode,
    chosen: state.timbre.chosen,
    altOfDay: altTimbre,
    proportions: { ...state.timbre.currentProportions },
    activeRescues: activeRescues
  });
  
  save();
}

function updateVarietyModeUI() {
  const selectEl = byId('varietyModeSelect');
  const devRowEl = byId('devVarietyRow');
  
  if (selectEl) {
    selectEl.value = state.timbre?.mode || 'single';
  }
  
  // Show dev row if needed (for testing)
  if (devRowEl && state.timbre?.forceVariety) {
    devRowEl.style.display = 'flex';
  } else if (devRowEl) {
    devRowEl.style.display = 'none';
  }
}

/* ------------------ DAILY SESSION HELPERS ------------------ */
function isQAMode() {
  return new URLSearchParams(window.location.search).get('qa') === '1';
}

function getCurrentBlockDuration() {
  return isQAMode() ? QA_BLOCK_DURATION_MS : DAILY_BLOCK_DURATION_MS;
}

function getCurrentBreakDuration() {
  return isQAMode() ? QA_BREAK_DURATION_MS : DAILY_BREAK_DURATION_MS;
}

function getTodayDateString() {
  return new Date().toLocaleDateString('en-CA'); // YYYY-MM-DD format in local time
}

/* ------------------ DAILY SESSION MANAGEMENT ------------------ */
let sessionTimer = null;

function isDailyLocked() {
  const today = getTodayDateString();
  return state.daily && state.daily.date === today && state.daily.completedAt !== null;
}

function startDailySession() {
  // Check if already completed today
  if (isDailyLocked()) {
    alert('Training completed for today. Come back tomorrow!');
    return false;
  }
  
  // Reset session if starting fresh
  if (!state.session.startedAt) {
    state.session = {
      startedAt: Date.now(),
      elapsedMs: 0,
      blocksDone: 0,
      blockElapsedMs: 0,
      inBreak: false,
      breakRemainingMs: 0
    };
  }
  
  // Start the unified ticker instead of separate session timer
  startUnifiedTicker();
  
  save();
  updateSessionUI();
  return true;
}

/* ------------------ UNIFIED TIMER SYSTEM ------------------ */
// 3) Single source of truth for timers + UI sync  
let unifiedTickerId = null;

function startUnifiedTicker() {
  if (unifiedTickerId) {
    clearInterval(unifiedTickerId);
  }
  
  // Single 1Hz ticker that updates all UI timer labels
  unifiedTickerId = setInterval(updateAllTimerUI, 1000);
}

function stopUnifiedTicker() {
  if (unifiedTickerId) {
    clearInterval(unifiedTickerId);
    unifiedTickerId = null;
  }
}

function updateAllTimerUI() {
  // Update session timers if active
  if (state.session && state.session.startedAt) {
    updateSessionUI();
  }
  
  // Update menu timer to reflect remaining time = 30 - (minutesCompleted + elapsedMs/60000)
  updateMenuTimer();
  
  // Update trainer timer if on trainer screen
  if (sessionActive) {
    updateTrainerTimer();
  }
  
  // Handle daily session progression
  if (sessionActive && !paused && !state.session.inBreak) {
    // Update session elapsed time
    const elapsed = state.session.elapsedMs + 1000;
    const blockElapsed = state.session.blockElapsedMs + 1000;
    
    if (blockElapsed >= getCurrentBlockDuration()) {
      // Block complete
      completeDailyBlock();
    } else {
      state.session.elapsedMs = elapsed;
      state.session.blockElapsedMs = blockElapsed;
      
      // Update daily progress
      state.daily.minutesCompleted = Math.floor(elapsed / 60000);
      if (state.daily.minutesCompleted >= 30 && !state.daily.completedAt) {
        state.daily.completedAt = Date.now();
      }
    }
    
    save();
  }
  
  // Handle break countdowns
  if (state.session && state.session.inBreak && state.session.breakRemainingMs > 0) {
    state.session.breakRemainingMs = Math.max(0, state.session.breakRemainingMs - 1000);
    if (state.session.breakRemainingMs === 0) {
      endDailyBreak();
    }
    save();
  }
}

function updateMenuTimer() {
  const capInfo = byId('capInfo');
  if (!capInfo) return;
  
  if (isDailyLocked()) {
    capInfo.textContent = 'Training finished for today';
    capInfo.style.background = 'var(--good)';
  } else {
    // Check if training has started today
    const hasStartedToday = state.session && state.session.startedAt && 
                           state.daily && state.daily.date === getTodayDateString();
    
    if (!hasStartedToday) {
      capInfo.textContent = 'Training not started yet';
      capInfo.style.background = '';
    } else {
      // Show completed blocks instead of time countdown
      const blocksCompleted = state.timeblock?.breaksCompletedToday || 0;
      capInfo.textContent = `Training blocks: ${blocksCompleted}/5 completed`;
      capInfo.style.background = '';
    }
  }
}

function updateTrainerTimer() {
  if (!state.session || !state.session.startedAt) return;
  
  const timerInfo = byId('timerInfo');
  if (timerInfo) {
    // Show only block progress, no 30-minute countdown
    const blocksCompleted = state.timeblock?.breaksCompletedToday || 0;
    const currentBlock = blocksCompleted + 1;
    
    if (currentBlock > 5) {
      timerInfo.textContent = 'Training complete!';
      // Trigger session end
      endSessionWithWarmRecall();
    } else {
      timerInfo.textContent = `Block ${currentBlock}/5`;
    }
  }
}

function updateDailySession() {
  if (!state.session.startedAt) return;
  
  const now = Date.now();
  
  if (state.session.inBreak) {
    // Count down break time (continues even if paused)
    if (state.session.breakRemainingMs > 0) {
      state.session.breakRemainingMs = Math.max(0, state.session.breakRemainingMs - 100);
      if (state.session.breakRemainingMs === 0) {
        endDailyBreak();
      } else {
        // Update break message during countdown
        updateDailyBreakMessage();
      }
    }
  } else if (sessionActive && !paused) {
    // Count up training time only when not paused and session is active
    const blockDuration = getCurrentBlockDuration();
    const elapsed = state.session.blockElapsedMs + 100;
    
    if (elapsed >= blockDuration) {
      // Block completed
      completeDailyBlock();
    } else {
      state.session.blockElapsedMs = elapsed;
      state.session.elapsedMs += 100;
    }
  }
  
  updateSessionUI();
}

function completeDailyBlock() {
  state.session.blocksDone++;
  state.session.blockElapsedMs = 0;
  
  // Add to daily minutes completed (convert from ms)
  const blockMinutes = getCurrentBlockDuration() / (60 * 1000);
  state.daily.minutesCompleted = Math.min(30, (state.daily.minutesCompleted || 0) + blockMinutes);
  
  if (state.session.blocksDone >= DAILY_BLOCK_COUNT) {
    // Session complete!
    completeDailySession();
  } else {
    // Start break
    startDailyBreak();
  }
  
  save();
}

function startDailyBreak() {
  state.session.inBreak = true;
  state.session.breakRemainingMs = getCurrentBreakDuration();
  
  // Open flappy modal with countdown
  openFlappyModalForDailyBreak();
  
  save();
}

function endDailyBreak() {
  state.session.inBreak = false;
  state.session.breakRemainingMs = 0;
  
  // Close flappy modal
  closeDailyBreakModal();
  
  save();
}

function completeDailySession() {
  // Session fully complete - 30 minutes done
  state.daily.completedAt = Date.now();
  state.daily.minutesCompleted = 30;
  
  // Stop session timer
  if (sessionTimer) {
    clearInterval(sessionTimer);
    sessionTimer = null;
  }
  
  // Show congratulations
  showDailyCompleteBanner();
  
  save();
}

function stopDailySession() {
  if (sessionTimer) {
    clearInterval(sessionTimer);
    sessionTimer = null;
  }
}

function resetDailySession() {
  stopDailySession();
  
  state.session = {
    startedAt: null,
    elapsedMs: 0,
    blocksDone: 0,
    blockElapsedMs: 0,
    inBreak: false,
    breakRemainingMs: 0
  };
  
  save();
  updateSessionUI();
}

/* ------------------ DAILY SESSION UI ------------------ */
function updateSessionUI() {
  // Update timer display in trainer header
  updateTrainerSessionDisplay();
  
  // Update menu display
  updateMenuSessionDisplay();
  
  // Update lockout status
  updateLockoutUI();
}

function updateTrainerSessionDisplay() {
  // Update the blockTimeInfo pill to show session progress
  const blockTimeInfo = byId('blockTimeInfo');
  if (!blockTimeInfo) return;
  
  if (!state.session.startedAt) {
    blockTimeInfo.textContent = 'Press Play to start session';
    return;
  }
  
  const blockNum = state.session.blocksDone + 1;
  const blockTime = fmtMMSS(state.session.blockElapsedMs);
  const blockTarget = fmtMMSS(getCurrentBlockDuration());
  
  if (state.session.inBreak) {
    const breakTime = fmtMMSS(state.session.breakRemainingMs);
    blockTimeInfo.textContent = `Block ${blockNum}/5 - Break: ${breakTime}`;
  } else {
    blockTimeInfo.textContent = `Block ${blockNum}/5 ${blockTime}/${blockTarget}`;
  }
}

function updateMenuSessionDisplay() {
  // Update the capInfo pill to show daily progress
  const capInfo = byId('capInfo');
  if (!capInfo) return;
  
  if (isDailyLocked()) {
    capInfo.textContent = 'üéâ Daily goal achieved!';
    capInfo.style.background = 'var(--good)';
  } else {
    // Include current session elapsed time like updateMenuTimer() does
    const minutesCompleted = state.daily.minutesCompleted || 0;
    const currentElapsedMs = (state.session && state.session.startedAt) ? state.session.elapsedMs : 0;
    const currentMinutes = Math.floor(currentElapsedMs / 60000);
    const totalMinutes = minutesCompleted + currentMinutes;
    const remaining = Math.max(0, 30 - totalMinutes);
    
    capInfo.textContent = `Left: ${remaining}:00 of 30:00`;
    capInfo.style.background = '';
  }
}

function updateLockoutUI() {
  const lockoutPill = byId('lockoutPill');
  const menuStart = byId('menuStart');
  
  if (isDailyLocked()) {
    // Show lockout status
    if (lockoutPill) {
      lockoutPill.textContent = 'Come back tomorrow';
      lockoutPill.style.display = 'inline-flex';
    }
    
    // Disable training button
    if (menuStart) {
      menuStart.disabled = true;
      menuStart.textContent = 'üîí Training Complete';
    }
  } else {
    // Hide lockout status
    if (lockoutPill) {
      lockoutPill.style.display = 'none';
    }
    
    // Enable training button
    if (menuStart) {
      menuStart.disabled = false;
      menuStart.textContent = '‚ñ∂ Start Training';
    }
  }
}

/* ------------------ DAILY SESSION MODALS ------------------ */
function openFlappyModalForDailyBreak() {
  // Reuse existing flappy modal but add daily break messaging
  openFlappyModal();
  
  // Add break countdown message
  const flappyModal = byId('flappyModal');
  if (flappyModal) {
    let breakMessage = flappyModal.querySelector('#dailyBreakMessage');
    if (!breakMessage) {
      breakMessage = document.createElement('p');
      breakMessage.id = 'dailyBreakMessage';
      breakMessage.style.cssText = 'margin: 8px 0; font-weight: 600; color: var(--accent);';
      const flappyCard = flappyModal.querySelector('.card');
      if (flappyCard) {
        flappyCard.insertBefore(breakMessage, flappyCard.querySelector('canvas'));
      }
    }
    
    // Disable manual close during break
    const closeBtn = byId('flappyClose');
    if (closeBtn) {
      closeBtn.style.display = 'none';
    }
    
    // Update message with remaining time (this will be called repeatedly by updateDailySession)
    updateDailyBreakMessage();
  }
}

function updateDailyBreakMessage() {
  const breakMessage = byId('dailyBreakMessage');
  if (breakMessage && state.session.inBreak) {
    const remaining = fmtMMSS(state.session.breakRemainingMs);
    const blockNum = state.session.blocksDone + 1;
    breakMessage.textContent = `Block ${state.session.blocksDone} complete! Break: ${remaining} remaining`;
  }
}

function closeDailyBreakModal() {
  const flappyModal = byId('flappyModal');
  if (flappyModal && flappyModal.style.display === 'flex') {
    closeFlappy();
  }
  
  // Remove break message
  const breakMessage = byId('dailyBreakMessage');
  if (breakMessage) {
    breakMessage.remove();
  }
  
  // Re-enable close button
  const closeBtn = byId('flappyClose');
  if (closeBtn) {
    closeBtn.style.display = 'inline-block';
  }
}

function showDailyCompleteBanner() {
  // Create and show congratulations banner
  let banner = byId('dailyCompleteBanner');
  if (!banner) {
    banner = document.createElement('div');
    banner.id = 'dailyCompleteBanner';
    banner.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--good);
      color: white;
      padding: 24px 32px;
      border-radius: 16px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
      z-index: 1000;
      animation: bounceIn 0.6s ease-out;
    `;
    
    banner.innerHTML = `
      <div style="font-size: 48px; margin-bottom: 16px;">üéâ</div>
      <div style="font-size: 24px; margin-bottom: 8px;">Congratulations!</div>
      <div style="margin-bottom: 16px;">30 minutes completed ‚Äî see you tomorrow!</div>
      <button id="dismissBanner" style="
        background: rgba(255,255,255,0.2);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
      ">Continue</button>
    `;
    
    document.body.appendChild(banner);
    
    // Add click handler for dismiss button
    const dismissBtn = byId('dismissBanner');
    if (dismissBtn) {
      dismissBtn.onclick = () => {
        banner.remove();
        showScreen('menuScreen');
        updateSessionUI();
      };
    }
  }
  
  banner.style.display = 'block';
}

/* ------------------ DURATION ------------------ */
function activeDuration(session){
  const endAt = session.end ?? Date.now();
  let total = Math.max(0, endAt - session.start);
  for(const p of (session.pauses||[])){
    const pe = p.end ?? Date.now();
    const ps = p.start ?? session.start;
    const a = Math.max(session.start, ps);
    const b = Math.min(endAt, pe);
    if(b > a) total -= (b - a);
  }
  return Math.max(0, total);
}

/* ------------------ FLAGS/TIMERS ------------------ */
let sessionActive=false, paused=false;
let rtTimer=null, autoTimer=null, tickId=null, timeblockTickId=null, breakModalTimer=null;
function stopAllTimers(){ 
  if(tickId){ clearInterval(tickId); tickId=null; } 
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; } 
  if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; } 
  if(timeblockTickId){ cancelAnimationFrame(timeblockTickId); timeblockTickId=null; } 
  if(breakModalTimer){ clearInterval(breakModalTimer); breakModalTimer=null; }
  // Stop unified ticker
  stopUnifiedTicker();
}

/* one-shot suppression so strict modal doesn't appear right after specials */
let suppressStrictOnce=false;

/* ------------------ TIMEBLOCK SYSTEM ------------------ */
// A) TimeBlock state & ticking (count only during active training)
// Add/normalize state.timeblock structure
function normalizeTimeBlockState() {
  state.timeblock = {
    activeMs: state.timeblock?.activeMs || 0,  // counts ONLY when training is active AND NOT on break
    running: !!state.timeblock?.running,
    startedAt: state.timeblock?.startedAt || null,  // performance.now() of last resume
    breaksCompletedToday: state.timeblock?.breaksCompletedToday || 0, // 0..4
    breakActive: !!state.timeblock?.breakActive,
    breakEndsAt: state.timeblock?.breakEndsAt || null
  };
}

// Tick function (requestAnimationFrame):
function tickTimeBlock(now = performance.now()) {
  if (!state.timeblock) return;
  const tb = state.timeblock;
  if (tb.running && !tb.breakActive) {
    if (tb.startedAt == null) tb.startedAt = now;
    const dt = Math.max(0, now - tb.startedAt);
    tb.activeMs += dt;
    tb.startedAt = now;
    if (tb.activeMs >= 6*60*1000) beginTimeBlockBreak();
  }
  renderTrainerHeaderTimeBlock(); // uses tb.activeMs
  requestAnimationFrame(tickTimeBlock);
}

function startTimeBlockTimer() {
  if (!state.timeblock.running) {
    state.timeblock.running = true;
    state.timeblock.startedAt = performance.now();
    save();
  }
  // Start the loop once on trainer mount:
  requestAnimationFrame(tickTimeBlock);
}

function pauseTimeBlockTimer() {
  if (state.timeblock.running) {
    // Update one final time before pausing
    if (state.timeblock.startedAt) {
      const now = performance.now();
      state.timeblock.activeMs += now - state.timeblock.startedAt;
    }
    state.timeblock.running = false;
    save();
  }
}

// Keep legacy functions for compatibility
function timeblockTick() {
  return tickTimeBlock();
}

function updateTimeBlockMs() {
  if (state.timeblock.running && state.timeblock.startedAt) {
    const now = performance.now();
    state.timeblock.activeMs += now - state.timeblock.startedAt;
    state.timeblock.startedAt = now;
  }
}

// B) Begin/End break logic (modal stays up for full 60s)
function beginTimeBlockBreak() {
  const tb = state.timeblock;
  tb.running = false;
  tb.breakActive = true;
  tb.breakEndsAt = Date.now() + 60_000;
  showFlappyModal({ countdown: tb.breakEndsAt }); // open modal; show 60s countdown; inputs in trainer disabled
  
  // Start break modal timer that checks every 250ms
  if (breakModalTimer) clearInterval(breakModalTimer);
  breakModalTimer = setInterval(() => {
    maybeCloseBreakModal();
  }, 250);
  
  // Log TimeBlock completion
  logTimeBlockOobData({ 
    event: 'timeblock_completed',
    timeBlockIndex: state.timeblock.breaksCompletedToday + 1
  });
  
  save();
  
  // Pause training
  if (sessionActive && !paused) {
    pauseStart('timeblock-break');
  }
  
  openFlappyModalForTimeBlockBreak();
}

function showFlappyModal(options = {}) {
  openFlappyModal();
  if (options.countdown) {
    updateTimeBlockBreakUI();
  }
}

function endTimeBlockBreak() {
  state.timeblock.activeMs = 0;
  state.timeblock.breakActive = false;
  state.timeblock.breakEndsAt = null;
  state.timeblock.breaksCompletedToday++;
  
  if (state.timeblock.breaksCompletedToday >= 5) {
    endDayAndLockout();
  } else {
    // Resume training:
    state.timeblock.running = true; 
    state.timeblock.startedAt = performance.now();
  }
  
  save();
}

function endDayAndLockout() {
  // Set lockout until next calendar day (midnight)
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0); // Set to midnight
  
  state.lockoutUntil = tomorrow.getTime();
  state.capResetAt = state.lockoutUntil;
  
  // Reset TimeBlock system for next day
  state.timeblock = {
    activeMs: 0,
    running: false,
    startedAt: null,
    breaksCompletedToday: 0,
    breakActive: false,
    breakEndsAt: null
  };
  
  save();
  endSession(true);
}

function completeDayWithoutLockout() {
  // Mark daily session as complete without triggering lockout
  // This allows user to return to menu and see completion status
  if (!state.daily.completedAt) {
    state.daily.completedAt = Date.now();
  }
  
  // Reset TimeBlock system for next day  
  state.timeblock = {
    activeMs: 0,
    running: false,
    startedAt: null,
    breaksCompletedToday: 0,
    breakActive: false,
    breakEndsAt: null
  };
  
  save();
  endSession(false); // false = don't show lockout alert
}

function openFlappyModalForTimeBlockBreak() {
  openFlappyModal();
  updateTimeBlockBreakUI();
}

function updateTimeBlockBreakUI() {
  if (!state.timeblock.breakActive || !state.timeblock.breakEndsAt) return;
  
  const now = Date.now();
  const remaining = Math.max(0, state.timeblock.breakEndsAt - now);
  
  // At exactly breakEndsAt, close the modal immediately (do NOT wait for the current flappy round to end).
  if (remaining <= 0) {
    // Break time is up - close modal and end break
    const flappyModal = byId('flappyModal');
    if (flappyModal && flappyModal.style.display === 'flex') {
      closeFlappy();
    }
    endTimeBlockBreakAndCloseModal();
    return;
  }
  
  // Always keep modal open until Date.now() >= breakEndsAt.
  // If the player loses early, the modal STAYS open with the countdown still visible
  const flappyModal = byId('flappyModal');
  if (flappyModal && flappyModal.style.display === 'flex') {
    let breakMessage = flappyModal.querySelector('#timeBlockBreakMessage');
    if (!breakMessage) {
      breakMessage = document.createElement('p');
      breakMessage.id = 'timeBlockBreakMessage';
      breakMessage.style.cssText = 'margin: 8px 0; font-weight: 600; color: var(--accent);';
      const flappyCard = flappyModal.querySelector('.card');
      if (flappyCard) {
        flappyCard.insertBefore(breakMessage, flappyCard.querySelector('canvas'));
      }
    }
    breakMessage.textContent = `TimeBlock break: ${fmtMMSS(remaining)} remaining`;
    
    // Show "Play again" option if game is not running and no crash overlay is shown
    const crashOverlay = flappyModal.querySelector('#flappyCrashOverlay');
    if (!running && !crashOverlay) {
      let playAgainBtn = flappyModal.querySelector('#playAgainBtn');
      if (!playAgainBtn) {
        playAgainBtn = document.createElement('button');
        playAgainBtn.id = 'playAgainBtn';
        playAgainBtn.textContent = 'Play again';
        playAgainBtn.style.cssText = 'margin-right: 8px;';
        const closeBtn = flappyModal.querySelector('#flappyClose');
        if (closeBtn && closeBtn.parentNode) {
          closeBtn.parentNode.insertBefore(playAgainBtn, closeBtn);
        }
        playAgainBtn.onclick = () => {
          running = true;
          resetFlappy();
          flappyRAF = requestAnimationFrame(step);
        };
      }
    } else if (running) {
      // Remove play again button if game is running
      const playAgainBtn = flappyModal.querySelector('#playAgainBtn');
      if (playAgainBtn) playAgainBtn.remove();
    }
  }
}

// C) Header display (do not reset on menu)
function renderTrainerHeaderTimeBlock() {
  // Calculate i = Math.min(5, (state.timeblock?.breaksCompletedToday || 0) + (state.timeblock?.breakActive ? 1 : 1));
  // i is 1..5 for the current/next TimeBlock being worked on
  const breaksCompleted = state.timeblock?.breaksCompletedToday || 0;
  const i = Math.min(5, breaksCompleted + 1);
  
  // Show "TimeBlock i/5  mm:ss / 06:00"
  // Compute mm:ss from state.timeblock.activeMs (clamp to 0..360000).
  const activeMs = Math.max(0, Math.min(360000, state.timeblock?.activeMs || 0));
  const mmss = fmtMMSS(activeMs);
  
  text('blockTimeInfo', `TimeBlock ${i}/5  ${mmss} / 06:00`);
}

// F) Fix missing logger reference
function logTimeBlockOobData(payload = {}) {
  window.qa = window.qa || {}; 
  qa.timeBlocks = qa.timeBlocks || [];
  qa.timeBlocks.push({
    date: new Date().toISOString(),
    breaksCompletedToday: state.timeblock?.breaksCompletedToday ?? null,
    activeMs: state.timeblock?.activeMs ?? null,
    oobTarget: state.oob?.blockTarget ?? state.oob?.targetPct ?? null,
    event: 'timeblock_completed',
    timeBlockIndex: (state.timeblock?.breaksCompletedToday || 0) + 1,
    ...payload
  });
}

/* Removed updateTimeBlockDisplay - now using renderTrainerHeaderTimeBlock */

function endTimeBlockBreakAndCloseModal() {
  endTimeBlockBreak();
  
  // Close Flappy modal if open
  const flappyModal = byId('flappyModal');
  if (flappyModal && flappyModal.style.display === 'flex') {
    closeFlappy();
  }
  
  // Resume training if session is active
  if (sessionActive && paused) {
    pauseEnd();
    safe('btnPause', el=> el.textContent='‚è∏ Pause');
    text('promptPill','TimeBlock break over ‚Äî press Play to continue');
  }
}

// B) Countdown governs closure, not game state
function maybeCloseBreakModal() {
  if (!state.timeblock.breakActive || !state.timeblock.breakEndsAt) return;
  
  if (Date.now() >= state.timeblock.breakEndsAt) {
    // Stop the break modal timer
    if (breakModalTimer) {
      clearInterval(breakModalTimer);
      breakModalTimer = null;
    }
    
    // Hard close regardless of current game state
    closeFlappyModal();
    // end break
    state.timeblock.breakActive = false;
    state.timeblock.activeMs = 0;
    state.timeblock.breaksCompletedToday++;
    // resume training if <5 TimeBlocks; otherwise end day/lockout
    if (state.timeblock.breaksCompletedToday < 5) {
      state.timeblock.running = true;
      state.timeblock.startedAt = performance.now();
    } else {
      endDayAndLockout();
    }
    save();
    
    // Resume training if session is active
    if (sessionActive && paused) {
      pauseEnd();
      safe('btnPause', el=> el.textContent='‚è∏ Pause');
      text('promptPill','TimeBlock break over ‚Äî press Play to continue');
    }
  }
}

function closeFlappyModal() {
  running = false; 
  cancelAnimationFrame(flappyRAF); 
  byId('flappyModal').style.display = 'none'; 
  detachFlappyControls();
  
  if (score > (state.flappyHighScore || 0)) { 
    state.flappyHighScore = score; 
    save(); 
  }
  
  // Remove break message if it exists
  const breakMessage = byId('timeBlockBreakMessage');
  if (breakMessage) breakMessage.remove();
  
  // Remove crash overlay if it exists
  const crashOverlay = byId('flappyCrashOverlay');
  if (crashOverlay) crashOverlay.remove();
}

/* ------------------ SANITY ------------------ */
function sealDanglingSession(){
  try{
    const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
    if(!rec) return;
    if(rec.end == null){
      const now = Date.now();
      if(rec.pauses && rec.pauses.length){
        const last = rec.pauses[rec.pauses.length-1];
        if(last && !last.end) last.end = now;
      }
      rec.end = now; save();
    }
  }catch(e){ report(e); }
}

/* ------------------ UI ------------------ */
function showScreen(id){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  if(id === 'menuScreen'){
    sessionActive=false; paused=false;
    // C) On leaving Trainer (menu etc): pause the tick (set running=false) but DO NOT reset activeMs.
    pauseTimeBlockTimer();
    stopAllTimers(); sealDanglingSession(); updateCapsUI();
    
    // Keep unified ticker running for menu timer updates (fix for Issue 2)
    startUnifiedTicker();
    
    try{ populatePitchSelect(); drawChart(); }catch(_){}
    
    // Check if warm recall should be shown automatically
    checkAndShowWarmRecall();
  } else if(id !== 'trainerScreen'){
    if(sessionActive && !paused){ 
      pauseStart('nav-away'); 
      pauseTimeBlockTimer();
    }
  }
  const el = byId(id); if(el) el.style.display='block';
}
function ensureWeekRoll(){ const wi=currentWeekIdx(); if(state.thisWeekIdx!==wi){ state.thisWeekIdx=wi; state.thisWeekMs=0; save(); } }
function isLocked(){ return state.lockoutUntil && Date.now() < state.lockoutUntil; }
function updateCapsUI(){
  ensureWeekRoll();
  
  // Update daily session UI (new system)
  updateSessionUI();
  
  // Legacy system (keep for compatibility)
  const left = Math.max(0, SESS_DAILY_MS - msUsedQuota());
  // Don't override capInfo if daily session system is active
  if (!state.session || !state.session.startedAt) {
    text('capInfo', `Left: ${fmtMMSS(left)}`);
  }
  
  const usedW = state.thisWeekMs || 0;
  const wp = byId('weekPill');
  if(wp){
    wp.textContent = `This week: ${fmtHrsMins(usedW)}`;
    let color = '#dc2626';
    if(usedW >= 1*3600000 && usedW < 2*3600000) color = 'var(--text)';
    else if(usedW >= 2*3600000 && usedW < 3*3600000) color = '#16a34a';
    else if(usedW >= 3*3600000) color = '#fbbf24';
    wp.style.color = color;
    wp.title = `Target: ${fmtHMM(WEEKLY_TARGET_MS)}`;
  }
  
  // Legacy lockout (keep for compatibility)
  const locked = isLocked();
  const lp = byId('lockoutPill');
  if(lp && !isDailyLocked()){
    if(locked){ lp.style.display='inline-flex'; lp.textContent = `üîí Locked (${fmtHMM(state.lockoutUntil - Date.now())} left)`; }
    else lp.style.display='none';
  }
  
  const pf = byId('playFlappy'); if(pf) pf.disabled = !(locked || isDailyLocked());
  
  // Update warm recall button state
  const wr = byId('startWarmRecall'); 
  if(wr) {
    const hasCompleted30Min = state.daily && state.daily.completedAt;
    const todayKey = getTodayDateString();
    const hasWarmRecallToday = state.recall && state.recall[todayKey] && state.recall[todayKey].warm && state.recall[todayKey].warm.length > 0;
    
    wr.disabled = !hasCompleted30Min || hasWarmRecallToday;
    
    if (!hasCompleted30Min) {
      wr.title = 'Complete a 30-minute training session first';
    } else if (hasWarmRecallToday) {
      wr.title = 'Already completed warm recall for today';
    } else {
      wr.title = 'Test your pitch recognition after training';
    }
  }
  
  // Update recall display when in menu screen
  try { updateRecallDisplay(); } catch(_) {}
}
function setFromIndex(i){return Math.floor((i-1)/LEVELS_PER_SET)+1;}
function blockFromIndex(i){return ((i-1)%LEVELS_PER_SET)+1;}
function thresholdForIndex(i){return THRESH_24[blockFromIndex(i)-1];}
function trainedSet(k){ return UNLOCK_ORDER.slice(0,k); }

// B) Helper function to pick OOB PC with health check consideration
function pickOobPc(trained) {
  const set = setFromIndex(state.levelIndex);
  const oobCandidates = currentOOBs(set);
  
  if (oobCandidates.length === 0) {
    console.warn('pickOobPc: No OOB candidates available');
    return null;
  }
  
  // If health check is active, prefer far-chroma OOB (avoid ¬±1 semitone of any trained pitch)
  if (state.oobController.healthCheckActive) {
    const farChromaOobs = oobCandidates.filter(oobPc => {
      return !isNearTrainedPitch(oobPc, trained, 1); // Not within ¬±1 semitone
    });
    
    if (farChromaOobs.length > 0) {
      console.log(`Health check: using far-chroma OOB from ${farChromaOobs.length} candidates`);
      return farChromaOobs[Math.floor(Math.random() * farChromaOobs.length)];
    }
    
    console.log('Health check: no far-chroma OOB available, using any OOB');
  }
  
  return oobCandidates[Math.floor(Math.random() * oobCandidates.length)];
}

// Helper function to check if OOB PC is within N semitones of any trained pitch
function isNearTrainedPitch(oobPc, trainedPcs, semitones) {
  const oobIndex = PC2I[oobPc];
  if (oobIndex === undefined) return false;
  
  for (const trainedPc of trainedPcs) {
    const trainedIndex = PC2I[trainedPc];
    if (trainedIndex === undefined) continue;
    
    // Calculate chromatic distance (shortest path around circle of fifths)
    const distance = Math.min(
      Math.abs(oobIndex - trainedIndex),
      12 - Math.abs(oobIndex - trainedIndex)
    );
    
    if (distance <= semitones) {
      return true; // Within N semitones
    }
  }
  
  return false; // Not near any trained pitch
}

// A) Source of truth for trained set - implements getTrainedPCs() requirement
function getTrainedPCs() {
  // Preferred: state.training.activeSet if non-empty (array of canonical flats)
  if (Array.isArray(state?.training?.activeSet) && state.training.activeSet.length > 0) {
    return [...state.training.activeSet];
  }

  // Else: read enabled .note-btn elements and use el.dataset.pc (canonical flats)
  const els = Array.from(document.querySelectorAll('.note-btn:not([aria-disabled="true"])'));
  const pcs = els.map(el => el.dataset.pc).filter(Boolean);
  if (pcs.length > 0) {
    return Array.from(new Set(pcs)); // Return unique array
  }

  // Never return [] if any note buttons are enabled - use level-based fallback
  const set = setFromIndex(state.levelIndex);
  const fallbackPcs = trainedSet(set);
  return fallbackPcs.length > 0 ? fallbackPcs : ['C']; // Ultimate fallback to ensure non-empty
}

/* ------------------ AUDIO ------------------ */
let ACTX=null; const BUF_CACHE=new Map();
let FLAPPY_AUDIO_BUFFER = null; // E) Preload flappy audio buffer

function getCtx(){ if(!ACTX){ ACTX=new (window.AudioContext||window.webkitAudioContext)(); } return ACTX; }
async function resumeCtx(){ try{ const ctx=getCtx(); if(ctx.state==='suspended') await ctx.resume(); }catch(e){ report(e); } }
async function loadBuffer(url){ if(BUF_CACHE.has(url)) return BUF_CACHE.get(url); const res=await fetch(url); if(!res.ok) throw new Error('Missing audio '+url); const arr=await res.arrayBuffer(); const buf=await getCtx().decodeAudioData(arr); BUF_CACHE.set(url,buf); return buf; }
async function closeAudio(){ try{ if(ACTX){ await ACTX.close(); } }catch(_){} finally{ ACTX=null; BUF_CACHE.clear(); FLAPPY_AUDIO_BUFFER=null; } }

// E) Preload flappy audio once on app init
async function preloadFlappyAudio() {
  try {
    await resumeCtx();
    FLAPPY_AUDIO_BUFFER = await loadBuffer('./audio/flappy.mp3');
  } catch (e) {
    console.warn('Could not preload flappy audio:', e);
  }
}

// E) Flappy sound function
function playFlappySound() {
  if (state.flappyMuted) return;
  
  try {
    const ctx = getCtx();
    if (FLAPPY_AUDIO_BUFFER) {
      const src = ctx.createBufferSource();
      src.buffer = FLAPPY_AUDIO_BUFFER;
      const g = ctx.createGain(); 
      g.gain.value = 0.5; // Reasonable volume
      src.connect(g).connect(ctx.destination);
      src.start();
    }
  } catch (e) {
    console.warn('Could not play flappy sound:', e);
  }
}

// Piano URL resolution function as specified in requirements
function resolvePianoUrl(pc, octave) {
  // Canonical flat pitch class names (A, Bb, B, C, Db, D, Eb, E, F, Gb, G, Ab)
  const noteKey = `${pc}${octave}`;
  
  // Try in order as specified:
  // a) `audio/${pc}${octave}.mp3` - the repo's real location
  const primaryPath = `./audio/${noteKey}.mp3`;
  
  // b) If pc has a sharp enharmonic: `audio/${sharp}${octave}.mp3`
  const flatToSharp = { 
    'Bb': 'A#', 'Db': 'C#', 'Eb': 'D#', 
    'Gb': 'F#', 'Ab': 'G#' 
  };
  const sharpPath = flatToSharp[pc] ? `./audio/${flatToSharp[pc]}${octave}.mp3` : null;
  
  // c) Optional fallback: `audio/piano/${pc}${octave}.mp3`
  const pianoFallback = `./audio/piano/${noteKey}.mp3`;
  
  // d) Optional fallback: sharp in `audio/piano/` as well
  const pianoSharpFallback = flatToSharp[pc] ? `./audio/piano/${flatToSharp[pc]}${octave}.mp3` : null;
  
  return {
    primaryPath,
    sharpPath,
    pianoFallback,
    pianoSharpFallback,
    noteKey
  };
}

// Piano sample initialization and validation
async function initializePianoSamples() {
  const canonicalPCs = ["A","Bb","B","C","Db","D","Eb","E","F","Gb","G","Ab"];
  const [minOctave, maxOctave] = TIMBRE_RANGE.piano; // [3, 5]
  const octaves = [];
  for (let o = minOctave; o <= maxOctave; o++) {
    octaves.push(o);
  } // Now octaves = [3, 4, 5]
  
  // Initialize sample map structure
  for (const pc of canonicalPCs) {
    sampleMap.piano[pc] = {};
  }
  
  // Clear asset report
  window.assetsReport.piano = { present: [], missing: [] };
  
  const loadPromises = [];
  
  for (const pc of canonicalPCs) {
    for (const octave of octaves) {
      const loadPromise = (async () => {
        try {
          const { primaryPath, sharpPath, pianoFallback, pianoSharpFallback, noteKey } = resolvePianoUrl(pc, octave);
          let buffer = null;
          let loadedPath = null;
          
          // Try paths in order as specified
          const pathsToTry = [
            primaryPath,
            ...(sharpPath ? [sharpPath] : []),
            pianoFallback,
            ...(pianoSharpFallback ? [pianoSharpFallback] : [])
          ];
          
          for (const path of pathsToTry) {
            try {
              buffer = await loadBuffer(path);
              loadedPath = path;
              break;
            } catch (e) {
              // Continue to next path
            }
          }
          
          if (buffer && loadedPath) {
            sampleMap.piano[pc][octave] = buffer;
            // Store canonical name like "Eb4.mp3" in present list
            window.assetsReport.piano.present.push(`${noteKey}.mp3`);
          } else {
            // Log ONE warning as specified
            console.warn(`Missing piano sample: ${noteKey}.mp3`);
            window.assetsReport.piano.missing.push(`${noteKey}.mp3`);
          }
        } catch (e) {
          console.error(`Failed to load piano sample ${pc}${octave}:`, e);
        }
      })();
      
      loadPromises.push(loadPromise);
    }
  }
  
  // Wait for all samples to load
  await Promise.all(loadPromises);
  
  // Log summary
  if (window.assetsReport.piano.missing.length > 0) {
    console.warn(`Piano samples missing: ${window.assetsReport.piano.missing.join(', ')}`);
  }
  
  console.log(`Piano samples loaded: ${window.assetsReport.piano.present.length} present, ${window.assetsReport.piano.missing.length} missing`);
}

/* Guitar sample mapping - available samples and their pitches */
const GUITAR_SAMPLES = {
  'E2': 'E2.wav', 'A2': 'A2.wav', 'D3': 'D3.wav', 
  'G3': 'G3.wav', 'B3': 'B3.wav', 'E4': 'E4.wav', 'A4': 'A4.wav'
};

/* Find closest guitar sample for pitch shifting */
function findClosestGuitarSample(targetNote) {
  const m=/^([A-G](?:b)?)(\d)$/.exec(targetNote);
  const pc=m?m[1]:'A', o=m?+m[2]:4;
  const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
  const targetSemis=(idx[pc]??9)+(o-4)*12;
  
  let bestSample = 'E2';
  let bestDistance = 999;
  
  for (const sampleNote of Object.keys(GUITAR_SAMPLES)) {
    const sm=/^([A-G](?:b)?)(\d)$/.exec(sampleNote);
    const spc=sm?sm[1]:'E', so=sm?+sm[2]:2;
    const sampleSemis=(idx[spc]??4)+(so-4)*12;
    const distance = Math.abs(targetSemis - sampleSemis);
    if (distance < bestDistance) {
      bestDistance = distance;
      bestSample = sampleNote;
    }
  }
  
  return { sample: bestSample, semitones: targetSemis - ((idx[bestSample.match(/^([A-G](?:b)?)/)[1]]??4)+((+bestSample.match(/(\d)$/)[1])-4)*12) };
}

/* Always play a tone (sample -> oscillator -> fallback) */
async function playSample(note, detuneCents = 0, timbreOverride = null){
  // Capture tone start timing for reaction time calculation
  state.toneStartMs = performance.now();
  state.trialOpen = true;
  
  // Determine which timbre to use
  const timbre = timbreOverride || state.audioType;
  
  try{
    await resumeCtx();
    const ctx = getCtx();
    
    // Calculate detune multiplier
    const detuneMultiplier = Math.pow(2, detuneCents / 1200);
    
    // Handle different audio types
    if (timbre === AUDIO_TYPES.PIANO) {
      try {
        // Parse note to get PC and octave
        const m = /^([A-G](?:b)?)(\d)$/.exec(note);
        if (!m) throw new Error(`Invalid note format: ${note}`);
        
        const pc = m[1];
        const octave = parseInt(m[2]);
        
        // Clamp octave to TIMBRE_RANGE for piano
        const clampedOctave = Math.max(TIMBRE_RANGE.piano[0], Math.min(TIMBRE_RANGE.piano[1], octave));
        
        // Use direct sample from sample map (no octave remapping)
        const buffer = sampleMap.piano[pc] && sampleMap.piano[pc][clampedOctave];
        
        if (buffer) {
          const src = ctx.createBufferSource();
          src.buffer = buffer;
          
          // Apply fine detune only (no coarse octave transposition)
          if (src.detune) {
            src.detune.value = detuneCents;
          } else {
            src.playbackRate.value = detuneMultiplier;
          }
          
          const g = ctx.createGain(); 
          g.gain.value = 1;
          src.connect(g).connect(ctx.destination);
          const t = ctx.currentTime;
          src.start(t); 
          src.stop(t + TONE_MS/1000);
          return;
        } else {
          console.warn(`No piano sample found for ${pc}${clampedOctave}, falling back to sine`);
        }
      } catch(e) {
        console.warn('Piano sample playback failed:', e);
      }
    } else if (timbre === AUDIO_TYPES.GUITAR) {
      try{
        const {sample, semitones} = findClosestGuitarSample(note);
        const url = `${AUDIO_GUITAR}/${GUITAR_SAMPLES[sample]}`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply both pitch shifting and detune
        const pitchRatio = Math.pow(2, semitones / 12);
        const combinedRatio = pitchRatio * detuneMultiplier;
        
        if (src.detune) {
          src.playbackRate.value = pitchRatio;
          src.detune.value = detuneCents;
        } else {
          src.playbackRate.value = combinedRatio;
        }
        
        // Guitar samples are louder, so reduce gain
        const g = ctx.createGain(); 
        g.gain.value = 0.7; // Reduce guitar volume
        
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        src.start(t); src.stop(t + TONE_MS/1000 / pitchRatio);
        return;
      }catch(e){
        // Log missing file warning once per file
        const logKey = `missing_${timbre}_${note}`;
        if (!window.missingFileWarnings) window.missingFileWarnings = new Set();
        if (!window.missingFileWarnings.has(logKey)) {
          console.warn(`Missing ${timbre} file for ${note}, falling back to sine`);
          window.missingFileWarnings.add(logKey);
        }
      }
    } else if (timbre === AUDIO_TYPES.SINE) {
      // Skip to sine wave generation
    } else {
      // Default to piano, fallback to sine
      try{
        const url = `${AUDIO_PIANO}/${note}.mp3`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply detune using detune property if available, otherwise playbackRate
        if (src.detune) {
          src.detune.value = detuneCents;
        } else {
          src.playbackRate.value = detuneMultiplier;
        }
        
        const g = ctx.createGain(); g.gain.value = 1;
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        src.start(t); src.stop(t + TONE_MS/1000);
        return;
      }catch(e){
        // Log missing file warning once per file
        const logKey = `missing_${timbre}_${note}`;
        if (!window.missingFileWarnings) window.missingFileWarnings = new Set();
        if (!window.missingFileWarnings.has(logKey)) {
          console.warn(`Missing ${timbre} file for ${note}, falling back to sine`);
          window.missingFileWarnings.add(logKey);
        }
      }
    }
    
    // Fallback to sine wave
    const m=/^([A-G](?:b)?)(\d)$/.exec(note);
    const pc=m?m[1]:'A', o=m?+m[2]:4;
    const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
    const semis=(idx[pc]??9)+(o-4)*12;
    const baseFreq=440*Math.pow(2,(semis-9)/12);
    const detunedFreq = baseFreq * detuneMultiplier;
    
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type='sine'; osc.frequency.value=detunedFreq;
    const t0 = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.25, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + TONE_MS/1000);
    osc.connect(g).connect(ctx.destination);
    osc.start(t0); osc.stop(t0 + TONE_MS/1000);
  }catch(e){
    try{
      const ctx=getCtx(); const osc=ctx.createOscillator(); const g=ctx.createGain();
      osc.type='sine'; osc.frequency.value=440 * detuneMultiplier;
      const t0=ctx.currentTime; g.gain.setValueAtTime(0.0001,t0); g.gain.linearRampToValueAtTime(0.2,t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t0+0.3);
      osc.connect(g).connect(ctx.destination); osc.start(t0); osc.stop(t0+0.3);
    }catch(_){}
  }
}

/* Flappy sound for Flappy Bird lockout */
/* Removed - now using playFlappySound() defined in AUDIO section */

/* ------------------ Shepard (pauses) ------------------ */
let shepRunning=false;
async function playShepard20s(){
  const wasActive = sessionActive && !paused;
  if(wasActive) pauseStart('shepard');
  await resumeCtx();
  const overlay=byId('shepardOverlay'), counterEl=byId('shepardCountdown');
  if(!overlay||!counterEl) return;
  overlay.style.display='flex'; shepRunning=true;
  const ctx=getCtx(); const oscillators=[]; const partials=8, base=55, dur=20; const now=ctx.currentTime;
  for(let i=0;i<partials;i++){
    const osc=ctx.createOscillator(); const g=ctx.createGain(); const f=base*Math.pow(2,i);
    osc.type='sine'; osc.frequency.setValueAtTime(f, now); osc.frequency.exponentialRampToValueAtTime(f/2, now+dur);
    const amp=Math.exp(-Math.pow((i-(partials-1)/2)/2,2)); g.gain.setValueAtTime(0.05*amp, now);
    osc.connect(g).connect(ctx.destination); oscillators.push(osc);
  }
  oscillators.forEach(o=>o.start(now)); oscillators.forEach(o=>o.stop(now+dur));
  let left=20; counterEl.textContent=left;
  const id=setInterval(()=>{ left--; counterEl.textContent=left; if(left<=0) clearInterval(id); },1000);
  await new Promise(r=>setTimeout(r,dur*1000));
  overlay.style.display='none'; shepRunning=false;
  if(wasActive){ pauseEnd(); safe('btnPause', el=> el.textContent='‚è∏ Pause'); }
}

/* ------------------ PITCH DETECTION SYSTEM ------------------ */
let micStream = null;
let pitchDetector = null;
let recordingActive = false;

// YIN pitch detection algorithm
class YINPitchDetector {
  constructor(sampleRate = 44100, bufferSize = 2048) {
    this.sampleRate = sampleRate;
    this.bufferSize = bufferSize;
    this.threshold = 0.1;
    this.probabilityThreshold = 0.1;
  }
  
  // Autocorrelation method for pitch detection
  autocorrelate(buffer) {
    const SIZE = buffer.length;
    const rms = Math.sqrt(buffer.reduce((sum, val) => sum + val * val, 0) / SIZE);
    
    if (rms < 0.01) return -1; // Not enough signal
    
    let r1 = 0, r2 = SIZE - 1;
    for (let i = 0; i < SIZE / 2; i++) {
      if (Math.abs(buffer[i]) < 0.2) r1 = i;
      else break;
    }
    for (let i = 1; i < SIZE / 2; i++) {
      if (Math.abs(buffer[SIZE - i]) < 0.2) r2 = SIZE - i;
      else break;
    }
    
    const trimmedBuffer = buffer.slice(r1, r2);
    const correlations = new Array(trimmedBuffer.length);
    
    for (let i = 0; i < trimmedBuffer.length; i++) {
      let correlation = 0;
      for (let j = 0; j < trimmedBuffer.length - i; j++) {
        correlation += Math.abs((trimmedBuffer[j]) - (trimmedBuffer[i + j]));
      }
      correlations[i] = correlation;
    }
    
    let d = 0;
    while (correlations[d] > correlations[d + 1]) d++;
    
    let maxval = -1, maxpos = -1;
    for (let i = d; i < trimmedBuffer.length; i++) {
      if (correlations[i] > maxval) {
        maxval = correlations[i];
        maxpos = i;
      }
    }
    
    let T0 = maxpos;
    
    // Parabolic interpolation
    const x1 = correlations[T0 - 1], x2 = correlations[T0], x3 = correlations[T0 + 1];
    const a = (x1 - 2 * x2 + x3) / 2;
    const b = (x3 - x1) / 2;
    if (a) T0 = T0 - b / (2 * a);
    
    return this.sampleRate / T0;
  }
  
  // Convert frequency to MIDI note number
  frequencyToMidi(frequency) {
    return 69 + 12 * Math.log2(frequency / 440);
  }
  
  // Convert frequency to cents deviation from nearest equal temperament note
  frequencyToCents(frequency, targetFrequency) {
    return Math.round(1200 * Math.log2(frequency / targetFrequency));
  }
  
  // Get the frequency of a note (e.g., "A4" -> 440Hz)
  noteToFrequency(noteName) {
    const noteRegex = /^([A-G][b#]?)(\d+)$/;
    const match = noteName.match(noteRegex);
    if (!match) return 440; // Default A4
    
    const [, pitchClass, octaveStr] = match;
    const octave = parseInt(octaveStr);
    
    // Map pitch classes to semitone offsets from C
    const pcToSemitones = {
      'C': 0, 'Db': 1, 'C#': 1, 'D': 2, 'Eb': 3, 'D#': 3, 'E': 4,
      'F': 5, 'Gb': 6, 'F#': 6, 'G': 7, 'Ab': 8, 'G#': 8, 'A': 9, 'Bb': 10, 'A#': 10, 'B': 11
    };
    
    const semitones = pcToSemitones[pitchClass] || 0;
    const midiNote = (octave + 1) * 12 + semitones;
    
    // Convert MIDI note to frequency (A4 = 69, 440 Hz)
    return 440 * Math.pow(2, (midiNote - 69) / 12);
  }
}

// Initialize microphone access
async function initMicrophone() {
  if (micStream) return micStream;
  
  try {
    micStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        sampleRate: 44100,
        channelCount: 1,
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      } 
    });
    return micStream;
  } catch (error) {
    console.error('Microphone access denied:', error);
    throw new Error('Microphone access is required for pitch recall. Please allow microphone access and try again.');
  }
}

// Clean up microphone resources
function closeMicrophone() {
  if (micStream) {
    micStream.getTracks().forEach(track => track.stop());
    micStream = null;
  }
  if (pitchDetector) {
    pitchDetector = null;
  }
  recordingActive = false;
}

/* ------------------ RECALL SYSTEM ------------------ */

// Get today's date key for recall storage
function getTodayKey() {
  const today = new Date();
  return today.toISOString().split('T')[0]; // YYYY-MM-DD format
}

// Get trained pitch classes for current session
function getTrainedPCs() {
  const setSize = setFromIndex(state.levelIndex);
  return trainedSet(setSize);
}

// Randomly select 2-3 notes from trained set (no repeats)
function selectRecallNotes() {
  const trained = getTrainedPCs();
  const count = Math.min(3, Math.max(2, trained.length)); // 2-3 notes, but not more than available
  
  const selected = [];
  const available = [...trained];
  
  for (let i = 0; i < count && available.length > 0; i++) {
    const randomIndex = Math.floor(Math.random() * available.length);
    selected.push(available.splice(randomIndex, 1)[0]);
  }
  
  return selected;
}

// Analyze pitch recording and compute verdict
function analyzeRecording(frequencies, targetNote) {
  if (frequencies.length === 0) {
    return {
      medianHz: 0,
      medianCents: 0,
      sdCents: 0,
      verdict: 'Off',
      validSamples: 0,
      nearestMidi: null
    };
  }
  
  // Filter out invalid frequencies (too low/high)
  const validFreqs = frequencies.filter(f => f > 80 && f < 2000);
  if (validFreqs.length === 0) {
    return {
      medianHz: 0,
      medianCents: 0,
      sdCents: 0,
      verdict: 'Off',
      validSamples: 0,
      nearestMidi: null
    };
  }
  
  // Calculate median frequency
  const sortedFreqs = [...validFreqs].sort((a, b) => a - b);
  const medianHz = sortedFreqs.length % 2 === 0 
    ? (sortedFreqs[sortedFreqs.length / 2 - 1] + sortedFreqs[sortedFreqs.length / 2]) / 2
    : sortedFreqs[Math.floor(sortedFreqs.length / 2)];
  
  // Convert to MIDI for nearest octave calculation
  const medianMidi = hzToMidi(medianHz);
  
  // Find nearest target pitch class across all octaves
  const baseMidi = MIDI_PC_BASE[targetNote];
  if (!baseMidi) {
    console.error('Unknown pitch class:', targetNote);
    return {
      medianHz: Math.round(medianHz * 10) / 10,
      medianCents: 0,
      sdCents: 0,
      verdict: 'Off',
      validSamples: validFreqs.length,
      nearestMidi: null
    };
  }
  
  // Calculate nearest target MIDI number for this pitch class
  const nearestMidi = baseMidi + 12 * Math.round((medianMidi - baseMidi) / 12);
  
  // Convert all frequencies to cents relative to nearest target
  const centsArray = validFreqs.map(f => {
    const midiValue = hzToMidi(f);
    const nearestTarget = baseMidi + 12 * Math.round((midiValue - baseMidi) / 12);
    return 100 * (midiValue - nearestTarget);
  });
  
  // Calculate median and SD of cents
  const sortedCents = [...centsArray].sort((a, b) => a - b);
  const medianCents = sortedCents.length % 2 === 0 
    ? (sortedCents[sortedCents.length / 2 - 1] + sortedCents[sortedCents.length / 2]) / 2
    : sortedCents[Math.floor(sortedCents.length / 2)];
    
  const meanCents = centsArray.reduce((a, b) => a + b, 0) / centsArray.length;
  const variance = centsArray.reduce((a, b) => a + Math.pow(b - meanCents, 2), 0) / centsArray.length;
  const sdCents = Math.sqrt(variance);
  
  // Determine verdict based on thresholds (as per requirements)
  let verdict;
  if (Math.abs(medianCents) <= 10 && sdCents <= 15) {
    verdict = 'On target';
  } else if (Math.abs(medianCents) <= 30) {
    verdict = 'Close';
  } else {
    verdict = 'Off';
  }
  
  return {
    medianHz: Math.round(medianHz * 10) / 10,
    medianCents: Math.round(medianCents * 10) / 10,
    sdCents: Math.round(sdCents * 10) / 10,
    verdict,
    validSamples: validFreqs.length,
    nearestMidi: nearestMidi
  };
}

// Create a "Hold to Hum" button for recording
function createHumButton(targetPc, onComplete) {
  const container = document.createElement('div');
  container.style.cssText = 'margin: 16px 0; text-align: center;';
  
  const noteLabel = document.createElement('h4');
  noteLabel.textContent = PC_LABEL[targetPc] || targetPc;
  noteLabel.style.cssText = 'margin: 8px 0; color: var(--accent); font-size: 18px;';
  
  const button = document.createElement('button');
  button.textContent = 'üé§ Hold to Hum';
  button.style.cssText = `
    padding: 16px 24px;
    font-size: 16px;
    background: var(--accent);
    color: var(--bg);
    border-radius: 12px;
    border: none;
    cursor: pointer;
    margin: 8px;
    min-width: 160px;
    font-weight: 600;
  `;
  
  const display = document.createElement('div');
  display.style.cssText = 'margin: 8px 0; font-size: 14px; min-height: 40px;';
  display.innerHTML = '<span style="opacity: 0.7;">Press and hold to record ~2 seconds</span>';
  
  const result = document.createElement('div');
  result.style.cssText = 'margin: 8px 0; font-size: 14px; min-height: 30px;';
  
  let recording = false;
  let recordingStart = 0;
  let frequencies = [];
  let audioContext = null;
  let analyser = null;
  let microphone = null;
  
  const startRecording = async () => {
    if (recording) return;
    
    try {
      recording = true;
      frequencies = [];
      recordingStart = performance.now();
      
      button.textContent = 'üî¥ Recording...';
      button.style.background = 'var(--bad)';
      display.innerHTML = '<span style="color: var(--accent); font-weight: 600;">Recording... keep humming</span>';
      result.innerHTML = '';
      
      // AudioWorklet mic pipeline
      const ctx = (window.audioCtx ||= new (window.AudioContext||window.webkitAudioContext)());
      await ctx.resume(); // must be after a user gesture
      
      if (!ctx.audioWorklet) {
        console.warn('AudioWorklet not supported; falling back to ScriptProcessor');
        // Fallback: use existing ScriptProcessor path
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false, noiseSuppression: false, autoGainControl: false,
            channelCount: 1
          }
        });
        const source = ctx.createMediaStreamSource(stream);
        const N = 2048;
        const proc = ctx.createScriptProcessor(N, 1, 1);
        source.connect(proc);
        const sink = ctx.createGain(); sink.gain.value = 0; proc.connect(sink); sink.connect(ctx.destination);
        
        state.recall = state.recall || {};
        state.recall.backend = 'script';
        state.recall.detector = window.detectors.createPitchDetector({ method:'yin', sampleRate: ctx.sampleRate });
        
        let frames = [];
        proc.onaudioprocess = (e) => {
          if (!recording) return;
          const ch0 = e.inputBuffer.getChannelData(0);
          frames.push(new Float32Array(ch0));
        };
        state.recall.frames = frames;
      } else {
        await ctx.audioWorklet.addModule('worklets/recall-capture-processor.js');
        const node = new AudioWorkletNode(ctx, 'recall-capture');
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { 
            echoCancellation: false, 
            noiseSuppression: false, 
            autoGainControl: false, 
            channelCount: 1 
          }
        });
        const src = ctx.createMediaStreamSource(stream);
        src.connect(node); // node does not need to connect to destination
        
        state.recall = state.recall || {};
        state.recall.backend = 'worklet';
        state.recall.frames = []; // store last session frames
        state.recall.framesCount = 0;
        node.port.onmessage = (e) => {
          if (!recording) return;
          // e.data is a transferred Float32Array
          state.recall.frames.push(e.data);
          state.recall.framesCount = (state.recall.framesCount || 0) + 1;
        };
        state.recall.workletNode = node;
      }

      // Create detector once
      state.recall.detector = window.detectors.createPitchDetector({ method:'yin', sampleRate: ctx.sampleRate });
      
      // Start/Stop capture per prompt: start
      state.recall.frames = []; 
      state.recall.framesCount = 0; 
      state.recall.capturing = true;
      
      // Start pitch detection loop
      const detectPitch = () => {
        if (!recording) return;
        
        const elapsed = performance.now() - recordingStart;
        
        if (state.recall.frames.length > 0) {
          const latestFrame = state.recall.frames[state.recall.frames.length - 1];
          const hz = state?.recall?.detector?.getPitch(latestFrame) || null;
          
          if (hz && hz > 80 && hz < 800) {
            frequencies.push(hz);
            const targetHz = pitchDetector.noteToFrequency(targetPc + '4');
            const cents = pitchDetector.frequencyToCents(hz, targetHz);
            display.innerHTML = `
              <div style="color: var(--good);">
                <strong>${Math.round(hz)} Hz</strong> 
                <span style="margin-left: 16px;">${cents > 0 ? '+' : ''}${cents}¬¢</span>
              </div>
            `;
          }
        }
        
        if (elapsed < 2500) { // Record for ~2.5 seconds max
          requestAnimationFrame(detectPitch);
        } else {
          stopRecording();
        }
      };
      
      requestAnimationFrame(detectPitch);
      
    } catch (error) {
      console.error('Recording failed:', error);
      display.innerHTML = `<span style="color: var(--bad);">Error: ${error.message}</span>`;
      recording = false;
      button.textContent = 'üé§ Hold to Hum';
      button.style.background = 'var(--accent)';
    }
  };
  
  const stopRecording = () => {
    if (!recording) return;
    
    recording = false;
    
    // Stop capture per prompt: stop
    state.recall.capturing = false; 
    const frames = (state.recall && state.recall.frames) ? state.recall.frames.slice() : [];
    
    if (microphone) {
      microphone.disconnect();
      microphone = null;
    }
    
    button.textContent = 'üé§ Hold to Hum';
    button.style.background = 'var(--muted)';
    button.disabled = true;
    
    // Analyze recording
    const analysis = analyzeRecording(frequencies, targetPc);
    
    // Display results
    const verdictColor = 
      analysis.verdict === 'On target' ? 'var(--good)' :
      analysis.verdict === 'Close' ? 'var(--accent)' : 'var(--bad)';
    
    result.innerHTML = `
      <div style="color: ${verdictColor}; font-weight: 600; font-size: 16px; margin-bottom: 4px;">
        ${analysis.verdict}
      </div>
      <div style="opacity: 0.8; font-size: 13px;">
        Median: ${analysis.medianCents}¬¢ off ‚Ä¢ SD: ${analysis.sdCents}¬¢ ‚Ä¢ ${analysis.validSamples} samples
      </div>
    `;
    
    display.innerHTML = `<span style="opacity: 0.7;">Recording complete</span>`;
    
    // Store result and callback
    const recallData = {
      pc: targetPc,
      medianCents: analysis.medianCents,
      sdCents: analysis.sdCents,
      verdict: analysis.verdict,
      timestamp: Date.now(),
      validSamples: analysis.validSamples
    };
    
    // Call completion callback after a short delay
    setTimeout(() => onComplete(recallData), 1000);
  };
  
  // Mouse/touch event handlers
  button.addEventListener('mousedown', startRecording);
  button.addEventListener('mouseup', stopRecording);
  button.addEventListener('mouseleave', stopRecording);
  
  button.addEventListener('touchstart', (e) => {
    e.preventDefault();
    startRecording();
  });
  button.addEventListener('touchend', (e) => {
    e.preventDefault();
    stopRecording();
  });
  
  container.appendChild(noteLabel);
  container.appendChild(button);
  container.appendChild(display);
  container.appendChild(result);
  
  return container;
}

// Enhanced recall session system for sequential capture -> review flow
let currentRecallSession = null;

// Initialize a new recall session
function initializeRecallSession(type) {
  const selectedNotes = selectRecallNotes();
  
  currentRecallSession = {
    type: type, // 'cold' or 'warm'
    date: getTodayKey(),
    prompts: selectedNotes.map(pc => ({ pc })),
    takes: [], // Will store completed recordings
    currentIndex: 0, // Current prompt index
    phase: 'capture' // 'capture' or 'review'
  };
  
  return currentRecallSession;
}

// Save recall data to state (updated for new format)
function saveRecallData(type, data) {
  const todayKey = getTodayKey();
  if (!state.recall[todayKey]) {
    state.recall[todayKey] = { cold: [], warm: [] };
  }
  
  state.recall[todayKey][type].push({
    pc: data.pc,
    targetMidi: MIDI_PC_BASE[data.pc],
    nearestOct: data.nearestMidi,
    medianCents: data.medianCents,
    sdCents: data.sdCents,
    verdict: data.verdict.toLowerCase().replace(/\s+/g, '-'), // 'on-target', 'close', 'off'
    framesCount: data.validSamples,
    timestamp: data.timestamp || Date.now()
  });
  
  save();
}

// Show cold recall modal with sequential flow
function showColdRecall() {
  initializeRecallSession('cold');
  const modal = byId('coldRecallModal');
  modal.style.display = 'flex';
  renderRecallCapturePhase();
}

// Check if warm recall should be shown automatically when returning to menu
function checkAndShowWarmRecall() {
  // Automatic warm recall disabled - user must press button manually
  // This prevents interruptions when just accessing the menu
}

// Show warm recall modal with sequential flow  
function showWarmRecall() {
  initializeRecallSession('warm');
  const modal = byId('warmRecallModal');
  modal.style.display = 'flex';
  renderRecallCapturePhase();
}

// Start warm recall from menu button - check if allowed
function startWarmRecallFromMenu() {
  // Check if user has completed 30 minutes today
  if (!state.daily || !state.daily.completedAt) {
    alert('Warm recall is only available after completing a 30-minute training session.');
    return;
  }
  
  // Check if warm recall has already been done today
  const todayKey = getTodayDateString();
  if (state.recall && state.recall[todayKey] && state.recall[todayKey].warm && state.recall[todayKey].warm.length > 0) {
    alert('You have already completed warm recall for today.');
    return;
  }
  
  // All checks passed, show warm recall
  showWarmRecall();
}

// Render the capture phase UI
function renderRecallCapturePhase() {
  if (!currentRecallSession) return;
  
  const modalId = currentRecallSession.type === 'cold' ? 'coldRecallModal' : 'warmRecallModal';
  const modal = byId(modalId);
  const notesContainer = byId(currentRecallSession.type + 'RecallNotes');
  const completeButton = byId(currentRecallSession.type === 'cold' ? 'btnColdRecallComplete' : 'btnWarmRecallComplete');
  
  if (!notesContainer || !completeButton) return;
  
  // Clear container only if needed (prevents unnecessary flashing)
  if (notesContainer.children.length !== currentRecallSession.prompts.length) {
    notesContainer.innerHTML = '';
  }
  
  completeButton.style.display = 'none';
  
  // Create capture UI for each prompt
  currentRecallSession.prompts.forEach((prompt, index) => {
    const isActive = index === currentRecallSession.currentIndex;
    const isCompleted = index < currentRecallSession.currentIndex;
    const isFuture = index > currentRecallSession.currentIndex;
    
    // Find existing div or create new one
    let noteDiv = notesContainer.children[index];
    if (!noteDiv) {
      noteDiv = document.createElement('div');
      noteDiv.style.cssText = `
        margin: 12px 0;
        padding: 16px;
        border: 2px solid var(--muted);
        border-radius: 12px;
        text-align: center;
        background: var(--card);
        transition: all 0.3s ease;
      `;
      notesContainer.appendChild(noteDiv);
    }
    
    // Update styling based on state
    if (isCompleted) {
      noteDiv.style.borderColor = 'var(--good)';
      noteDiv.style.opacity = '0.8';
      noteDiv.style.background = 'var(--card)';
      noteDiv.style.color = 'var(--text)';
    } else if (isActive) {
      noteDiv.style.borderColor = 'var(--accent)';
      noteDiv.style.background = 'var(--accent)';
      noteDiv.style.color = 'var(--bg)';
      noteDiv.style.opacity = '1';
    } else {
      noteDiv.style.borderColor = 'var(--muted)';
      noteDiv.style.background = 'var(--card)';
      noteDiv.style.color = 'var(--text)';
      noteDiv.style.opacity = '0.6';
    }
    
    // Clear and populate content
    noteDiv.innerHTML = '';
    
    const titleEl = document.createElement('h3');
    titleEl.style.margin = '0 0 12px 0';
    titleEl.textContent = `Hum ${pcLabel(prompt.pc)}`;
    noteDiv.appendChild(titleEl);
    
    if (isCompleted) {
      const checkEl = document.createElement('div');
      checkEl.textContent = '‚úì Recorded';
      checkEl.style.cssText = 'font-weight: 600; color: var(--good);';
      noteDiv.appendChild(checkEl);
    } else if (isActive) {
      const humButton = createSequentialHumButton(prompt.pc, index);
      noteDiv.appendChild(humButton);
    } else {
      const waitEl = document.createElement('div');
      waitEl.textContent = 'Wait...';
      waitEl.style.cssText = 'opacity: 0.6; font-style: italic;';
      noteDiv.appendChild(waitEl);
    }
  });
  
  // Show review button if all captures complete
  if (currentRecallSession.currentIndex >= currentRecallSession.prompts.length) {
    completeButton.style.display = 'inline-block';
    completeButton.textContent = 'Review Results';
  }
}

// Create a hum button for sequential capture
function createSequentialHumButton(targetPc, index) {
  const button = document.createElement('button');
  button.textContent = 'Hold to Hum';
  button.style.cssText = `
    padding: 12px 24px;
    font-size: 16px;
    background: var(--bg);
    color: var(--accent);
    border-radius: 12px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    min-width: 140px;
  `;
  
  let recording = false;
  let frequencies = [];
  let audioContext = null;
  let analyser = null;
  let microphone = null;
  
  const startRecording = async () => {
    if (recording) return;
    
    recording = true;
    frequencies = [];
    
    button.textContent = 'Recording...';
    button.style.background = 'var(--bad)';
    
    try {
      // AudioWorklet mic pipeline
      const ctx = (window.audioCtx ||= new (window.AudioContext||window.webkitAudioContext)());
      await ctx.resume(); // must be after a user gesture
      
      if (!ctx.audioWorklet) {
        console.warn('AudioWorklet not supported; falling back to ScriptProcessor');
        // Fallback: use existing ScriptProcessor path
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false, noiseSuppression: false, autoGainControl: false,
            channelCount: 1
          }
        });
        const source = ctx.createMediaStreamSource(stream);
        const N = 2048;
        const proc = ctx.createScriptProcessor(N, 1, 1);
        source.connect(proc);
        const sink = ctx.createGain(); sink.gain.value = 0; proc.connect(sink); sink.connect(ctx.destination);
        
        state.recall = state.recall || {};
        state.recall.backend = 'script';
        state.recall.detector = window.detectors.createPitchDetector({ method:'yin', sampleRate: ctx.sampleRate });
        
        let frames = [];
        proc.onaudioprocess = (e) => {
          if (!recording) return;
          const ch0 = e.inputBuffer.getChannelData(0);
          frames.push(new Float32Array(ch0));
        };
        state.recall.frames = frames;
      } else {
        await ctx.audioWorklet.addModule('worklets/recall-capture-processor.js');
        const node = new AudioWorkletNode(ctx, 'recall-capture');
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { 
            echoCancellation: false, 
            noiseSuppression: false, 
            autoGainControl: false, 
            channelCount: 1 
          }
        });
        const src = ctx.createMediaStreamSource(stream);
        src.connect(node); // node does not need to connect to destination
        
        state.recall = state.recall || {};
        state.recall.backend = 'worklet';
        state.recall.frames = []; // store last session frames
        state.recall.framesCount = 0;
        node.port.onmessage = (e) => {
          if (!recording) return;
          // e.data is a transferred Float32Array
          state.recall.frames.push(e.data);
          state.recall.framesCount = (state.recall.framesCount || 0) + 1;
        };
        state.recall.workletNode = node;
      }

      // Create detector once
      state.recall.detector = window.detectors.createPitchDetector({ method:'yin', sampleRate: ctx.sampleRate });
      
      // Start/Stop capture per prompt: start
      state.recall.frames = []; 
      state.recall.framesCount = 0; 
      state.recall.capturing = true;
      
      const recordingStart = Date.now();
      
      const detectPitch = () => {
        if (!recording) return;
        
        const elapsed = Date.now() - recordingStart;
        
        if (state.recall.frames.length > 0) {
          const latestFrame = state.recall.frames[state.recall.frames.length - 1];
          const hz = state?.recall?.detector?.getPitch(latestFrame) || null;
          
          if (hz && hz > 80 && hz < 800) {
            frequencies.push(hz);
          }
        }
        
        if (elapsed < 2000) { // Record for 2 seconds
          requestAnimationFrame(detectPitch);
        } else {
          stopRecording();
        }
      };
      
      requestAnimationFrame(detectPitch);
      
    } catch (error) {
      console.error('Recording failed:', error);
      button.textContent = 'Error - Try Again';
      button.style.background = 'var(--bad)';
      recording = false;
    }
  };
  
  const stopRecording = () => {
    if (!recording) return;
    
    recording = false;
    
    // Show "Processing..." feedback immediately
    button.textContent = 'Processing...';
    button.style.background = 'var(--muted)';
    button.disabled = true;
    
    // Stop capture per prompt: stop
    state.recall.capturing = false; 
    const frames = (state.recall && state.recall.frames) ? state.recall.frames.slice() : [];
    
    if (microphone) {
      microphone.disconnect();
      microphone = null;
    }
    
    // Analyze recording
    const analysis = analyzeRecording(frequencies, targetPc);
    
    // Store the take
    currentRecallSession.takes.push({
      pc: targetPc,
      medianHz: analysis.medianHz,
      medianCents: analysis.medianCents,
      sdCents: analysis.sdCents,
      verdict: analysis.verdict,
      nearestMidi: analysis.nearestMidi,
      validSamples: analysis.validSamples,
      timestamp: Date.now()
    });
    
    // Show completion feedback for a moment before transitioning
    button.textContent = '‚úì Recorded';
    button.style.background = 'var(--good)';
    
    // Smooth transition to next prompt after brief delay
    setTimeout(() => {
      // Move to next prompt
      currentRecallSession.currentIndex++;
      
      // Re-render UI
      renderRecallCapturePhase();
    }, 800); // 800ms delay to show completion feedback
  };
  
  button.onmousedown = (e) => {
    e.preventDefault();
    if (!button.disabled) startRecording();
  };
  button.onmouseup = (e) => {
    e.preventDefault();
    if (recording) stopRecording();
  };
  button.onmouseleave = (e) => {
    e.preventDefault();
    if (recording) stopRecording();
  };
  button.ontouchstart = (e) => { 
    e.preventDefault(); 
    if (!button.disabled) startRecording(); 
  };
  button.ontouchend = (e) => { 
    e.preventDefault(); 
    if (recording) stopRecording(); 
  };
  
  return button;
}

// Start the review phase
function startRecallReview() {
  if (!currentRecallSession || currentRecallSession.takes.length === 0) return;
  
  currentRecallSession.phase = 'review';
  currentRecallSession.reviewIndex = 0;
  
  // 4) Keep persistent review state in state.recall as specified
  if (!state.recall.review) {
    state.recall.review = [];
  }
  if (typeof state.recall.reviewIndex === 'undefined') {
    state.recall.reviewIndex = 0;
  }
  
  // Update persistent state with current session takes
  state.recall.review = [...currentRecallSession.takes];
  state.recall.reviewIndex = 0;
  
  // Save all results to state
  for (const take of currentRecallSession.takes) {
    saveRecallData(currentRecallSession.type, take);
  }
  
  renderRecallReviewPhase();
}

// 4) Improved review navigation using persistent state  
function updateRecallReviewUI(item, i, total) {
  // Update the UI elements that show current position and content
  const positionEl = document.querySelector('.recall-review-position');
  if (positionEl) {
    positionEl.textContent = `Result ${i + 1} of ${total}`;
  }
  
  // Update the main content area
  const contentEl = document.querySelector('.recall-review-content');
  if (contentEl && item) {
    contentEl.innerHTML = generateRecallReviewContent(item);
  }
  
  // Update button states
  const prevBtn = byId('btnRecallPrev');
  const nextBtn = byId('btnRecallNext');
  
  if (prevBtn) {
    prevBtn.disabled = (i === 0);
  }
  
  if (nextBtn) {
    nextBtn.textContent = (i < total - 1) ? 'Next ‚ñ∂' : 'Done';
  }
}

// Render the review phase carousel
function renderRecallReviewPhase() {
  if (!currentRecallSession || currentRecallSession.phase !== 'review') return;
  
  const modalId = currentRecallSession.type === 'cold' ? 'coldRecallModal' : 'warmRecallModal';
  const modal = byId(modalId);
  
  if (!modal) return;
  
  // Use persistent state for navigation
  const reviewItems = state.recall.review || currentRecallSession.takes;
  const reviewIndex = state.recall.reviewIndex !== undefined ? state.recall.reviewIndex : currentRecallSession.reviewIndex;
  const currentTake = reviewItems[reviewIndex];
  
  if (!currentTake) return;
  
  // Generate review content
  const reviewContent = generateRecallReviewContent(currentTake);
  
  // Replace modal content with review UI
  modal.innerHTML = `
    <div class="card" style="max-width:600px;margin:20px;text-align:center">
      <h2>${currentRecallSession.type === 'cold' ? 'üßä Cold' : 'üî• Warm'} Recall - Review</h2>
      <div style="margin:20px 0">
        <div class="pill recall-review-position" style="margin-bottom:16px">
          Result ${reviewIndex + 1} of ${reviewItems.length}
        </div>
        <div class="recall-review-content" style="background:var(--muted2);border-radius:12px;padding:20px;margin:16px 0">
          ${reviewContent}
        </div>
      </div>
      <div style="display:flex;justify-content:space-between;gap:12px">
        <button id="btnRecallPrev" style="background:var(--muted)" 
          ${reviewIndex === 0 ? 'disabled' : ''}>‚óÄ Back</button>
        <div style="flex:1"></div>
        <button id="btnRecallNext" style="background:var(--good)">
          ${reviewIndex < reviewItems.length - 1 ? 'Next ‚ñ∂' : 'Done'}
        </button>
      </div>
    </div>
  `;
  
  // 4) Wire Next/Back buttons to increment/decrement reviewIndex and call updateRecallReviewUI
  safe('btnRecallPrev', el => el.onclick = () => {
    if (state.recall.reviewIndex > 0) {
      state.recall.reviewIndex--;
      currentRecallSession.reviewIndex = state.recall.reviewIndex; // Keep in sync
      const item = reviewItems[state.recall.reviewIndex];
      updateRecallReviewUI(item, state.recall.reviewIndex, reviewItems.length);
      renderRecallReviewPhase(); // Re-render for complete update
    }
  });
  
  safe('btnRecallNext', el => el.onclick = () => {
    if (state.recall.reviewIndex < reviewItems.length - 1) {
      state.recall.reviewIndex++;
      currentRecallSession.reviewIndex = state.recall.reviewIndex; // Keep in sync
      const item = reviewItems[state.recall.reviewIndex];
      updateRecallReviewUI(item, state.recall.reviewIndex, reviewItems.length);
      renderRecallReviewPhase(); // Re-render for complete update
    } else {
      finishRecallReview();
    }
  });
}

// Generate review content with three-note gauge
function generateRecallReviewContent(take) {
  if (!take.nearestMidi || take.medianCents === null) {
    return `
      <h3>Target: ${pcLabel(take.pc)}</h3>
      <p style="color:var(--bad)">No clear pitch detected</p>
      <p style="opacity:0.7">${take.validSamples || 0} audio samples recorded</p>
    `;
  }
  
  // Determine TARGET midi: target = base + 12*nearestOct
  const target = take.nearestMidi;
  const lower = target - 1; // lower semitone
  const upper = target + 1; // upper semitone
  
  // Convert all three to canonical labels with octaves (flats)
  const lowerLabel = midiToNoteLabel(lower);
  const targetLabel = midiToNoteLabel(target); 
  const upperLabel = midiToNoteLabel(upper);
  
  // Gauge domain: [-100¬¢, 0¬¢, +100¬¢] (center = TARGET). Needle at medianCents.
  const gaugePos = Math.max(0, Math.min(100, (take.medianCents + 100) / 2)); // Convert -100 to +100 range to 0-100%
  
  // Color by verdict:
  // - green: |median| ‚â§ 10¬¢ AND SD ‚â§ 15¬¢
  // - yellow: |median| ‚â§ 30¬¢ 
  // - red: otherwise
  let verdictColor;
  if (Math.abs(take.medianCents) <= 10 && take.sdCents <= 15) {
    verdictColor = 'var(--good)'; // green
  } else if (Math.abs(take.medianCents) <= 30) {
    verdictColor = 'var(--accent)'; // yellow
  } else {
    verdictColor = 'var(--bad)'; // red
  }
  
  // Format cents with sign - numeric "+12¬¢ sharp" or "‚àí18¬¢ flat"
  const centsStr = take.medianCents > 0 ? `+${Math.round(take.medianCents)}¬¢ sharp` : 
                   take.medianCents < 0 ? `${Math.round(take.medianCents)}¬¢ flat` :
                   `${Math.round(take.medianCents)}¬¢ on pitch`;
  
  return `
    <h3>Target: ${pcLabel(take.pc)}</h3>
    <div style="margin:24px 0">
      <!-- Three-note gauge labels -->
      <div style="display:flex;justify-content:space-between;margin-bottom:12px;font-size:16px;font-weight:600">
        <span style="opacity:0.8">${lowerLabel}</span>
        <span style="color:var(--accent);font-size:18px">${targetLabel}</span>
        <span style="opacity:0.8">${upperLabel}</span>
      </div>
      
      <!-- Gauge with needle -->
      <div style="position:relative;height:24px;background:linear-gradient(to right, var(--muted) 0%, var(--muted2) 50%, var(--muted) 100%);border-radius:12px;overflow:hidden;border:1px solid var(--muted)">
        <!-- Center line for TARGET -->
        <div style="position:absolute;left:50%;top:0;bottom:0;width:2px;background:var(--accent);opacity:0.6;transform:translateX(-50%)"></div>
        <!-- Needle at medianCents position -->
        <div style="position:absolute;left:${gaugePos}%;top:0;bottom:0;width:4px;background:${verdictColor};transform:translateX(-50%);border-radius:2px;box-shadow:0 0 4px rgba(0,0,0,0.3)"></div>
      </div>
      
      <!-- Scale markers -->
      <div style="display:flex;justify-content:space-between;margin-top:4px;font-size:12px;opacity:0.6">
        <span>-100¬¢</span>
        <span>0¬¢</span>
        <span>+100¬¢</span>
      </div>
    </div>
    
    <!-- Results -->
    <div style="margin:20px 0">
      <div style="font-size:20px;font-weight:600;color:${verdictColor};margin-bottom:8px">${centsStr}</div>
      <div style="opacity:0.7;font-size:14px">
        Stability: ${Math.round(take.sdCents)}¬¢ SD ‚Ä¢ ${take.validSamples || 0} samples
      </div>
    </div>
  `;
}

// Convert MIDI number to note label with octave
function midiToNoteLabel(midi) {
  const noteNames = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
  const octave = Math.floor(midi / 12) - 1;
  const noteIndex = Math.round(midi) % 12;
  return `${noteNames[noteIndex]}${octave}`;
}

// Finish recall review and continue workflow
function finishRecallReview() {
  if (!currentRecallSession) return;
  
  // Update display
  updateRecallDisplay();
  
  // Close modal and continue
  if (currentRecallSession.type === 'cold') {
    closeColdRecall();
    // After cold recall, continue to training with proper handoff
    startTraining();
  } else {
    closeWarmRecall();  
    // After warm recall, complete day without lockout and return to menu
    completeDayWithoutLockout();
    showScreen('menuScreen');
  }
  
  currentRecallSession = null;
}

// Close recall modals with proper audio cleanup
function closeColdRecall() {
  byId('coldRecallModal').style.display = 'none';
  
  // 2) Stop capture, disconnect worklet/script nodes, stop mic tracks, clear flags
  stopRecallCapture();
  closeMicrophone();
  
  // Resume AudioContext if needed (in case it was suspended)
  if (recallAudioContext && recallAudioContext.state === 'suspended') {
    recallAudioContext.resume().catch(err => {
      console.warn('Failed to resume recallAudioContext:', err);
    });
  }
  
  // Guard: never leave recall.capturing true
  if (state.recall && typeof state.recall.capturing !== 'undefined') {
    state.recall.capturing = false;
  }
  
  currentRecallSession = null;
}

function closeWarmRecall() {
  byId('warmRecallModal').style.display = 'none';  
  
  // 2) Stop capture, disconnect worklet/script nodes, stop mic tracks, clear flags
  stopRecallCapture();
  closeMicrophone();
  
  // Resume AudioContext if needed
  if (recallAudioContext && recallAudioContext.state === 'suspended') {
    recallAudioContext.resume().catch(err => {
      console.warn('Failed to resume recallAudioContext:', err);
    });
  }
  
  // Guard: never leave recall.capturing true
  if (state.recall && typeof state.recall.capturing !== 'undefined') {
    state.recall.capturing = false;
  }
  
  currentRecallSession = null;
}

// 2) Single entry point for starting training after recall
function startTraining() {
  // Show trainer screen
  showScreen('trainerScreen');
  
  // Ensure session timers are running (initialize if needed)
  if (!state.session.startedAt) {
    // Initialize session state
    state.session.startedAt = Date.now();
    state.session.elapsedMs = 0;
    state.session.blocksDone = 0;
    state.session.blockElapsedMs = 0;
    state.session.inBreak = false;
    state.session.breakRemainingMs = 0;
  }
  
  if (!sessionActive) {
    if (!state.startDate) state.startDate = Date.now();
    ensureWeekRoll();
    sessionActive = true;
    paused = false;
    
    // Create new session record
    (state.sessions || []).push({
      start: Date.now(),
      end: null,
      pauses: [],
      completed: false
    });
    
    // Start daily session system
    if (!startDailySession()) {
      showScreen('menuScreen');
      return;
    }
    
    // Keep legacy timeblock system for compatibility
    if (!state.timeblock.breakActive) {
      if (state.timeblock.running) {
        state.timeblock.startedAt = performance.now();
      }
      startTimeBlockTimer();
    }
  }
  
  // Initialize UI components (fix for missing buttons after cold recall)
  state.lastSeen = Date.now(); save();
  updateCapsUI(); updateLevelUI(); paintNotes();
  updateBlockHUD();
  
  // Schedule the first trial
  scheduleNextTrial();
  save();
}

// Helper function to stop recall capture and clean up audio worklets
function stopRecallCapture() {
  // Stop any active audio worklets or processing
  if (recallAudioContext) {
    try {
      // Disconnect all nodes to clean up the audio graph
      if (recallMicrophone) {
        recallMicrophone.disconnect();
      }
      if (recallAnalyser) {
        recallAnalyser.disconnect();
      }
    } catch (err) {
      console.warn('Error disconnecting recall audio nodes:', err);
    }
  }
}

// Update recall display in dashboard
function updateRecallDisplay() {
  const todayKey = getTodayKey();
  const recallData = state.recall[todayKey];
  const container = byId('recallHistoryToday');
  const emptyMsg = byId('recallHistoryEmpty');
  
  if (!recallData || (recallData.cold.length === 0 && recallData.warm.length === 0)) {
    if (emptyMsg) emptyMsg.style.display = 'block';
    return;
  }
  
  if (emptyMsg) emptyMsg.style.display = 'none';
  
  let html = '<div style="display: grid; gap: 12px;">';
  
  if (recallData.cold && recallData.cold.length > 0) {
    html += '<div><h4 style="margin: 0 0 8px 0; color: var(--accent);">üßä Cold Recall</h4>';
    recallData.cold.forEach(r => {
      const verdictColor = getVerdictColor(r.verdict);
      const centsStr = r.medianCents !== null && r.medianCents !== undefined ? 
        (r.medianCents > 0 ? `+${r.medianCents}¬¢` : `${r.medianCents}¬¢`) : 'N/A';
      
      html += `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; margin: 4px 0; background: var(--muted2); border-radius: 8px;">
          <span style="font-weight: 600;">${pcLabel(r.pc)}</span>
          <span style="color: ${verdictColor};">${formatVerdict(r.verdict)}</span>
          <span style="opacity: 0.7; font-size: 12px;">${centsStr}</span>
        </div>
      `;
    });
    html += '</div>';
  }
  
  if (recallData.warm && recallData.warm.length > 0) {
    html += '<div><h4 style="margin: 0 0 8px 0; color: var(--accent);">üî• Warm Recall</h4>';
    recallData.warm.forEach(r => {
      const verdictColor = getVerdictColor(r.verdict);
      const centsStr = r.medianCents !== null && r.medianCents !== undefined ? 
        (r.medianCents > 0 ? `+${r.medianCents}¬¢` : `${r.medianCents}¬¢`) : 'N/A';
      
      html += `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; margin: 4px 0; background: var(--muted2); border-radius: 8px;">
          <span style="font-weight: 600;">${pcLabel(r.pc)}</span>
          <span style="color: ${verdictColor};">${formatVerdict(r.verdict)}</span>
          <span style="opacity: 0.7; font-size: 12px;">${centsStr}</span>
        </div>
      `;
    });
    html += '</div>';
  }
  
  html += '</div>';
  container.innerHTML = html;
}

// Helper function to get verdict color
function getVerdictColor(verdict) {
  const normalized = formatVerdict(verdict);
  return normalized === 'On Target' ? 'var(--good)' :
         normalized === 'Close' ? 'var(--accent)' : 'var(--bad)';
}

// Helper function to format verdict text
function formatVerdict(verdict) {
  if (!verdict) return 'Unknown';
  // Convert from stored format (on-target, close, off) to display format
  const verdictMap = {
    'on-target': 'On Target',
    'close': 'Close', 
    'off': 'Off',
    'On target': 'On Target', // Handle existing format
    'Close': 'Close',
    'Off': 'Off'
  };
  return verdictMap[verdict] || verdict;
}

// Export recall data as CSV (updated for new format)
function exportRecallCSV() {
  const csvRows = ['date,type,pc,targetMidi,nearestOct,medianCents,sdCents,verdict,framesCount'];
  
  Object.keys(state.recall).sort().forEach(date => {
    const dayData = state.recall[date];
    
    if (dayData.cold) {
      dayData.cold.forEach(r => {
        csvRows.push(`${date},cold,${r.pc},${r.targetMidi || ''},${r.nearestOct || ''},${r.medianCents || ''},${r.sdCents || ''},${r.verdict || ''},${r.framesCount || ''}`);
      });
    }
    
    if (dayData.warm) {
      dayData.warm.forEach(r => {
        csvRows.push(`${date},warm,${r.pc},${r.targetMidi || ''},${r.nearestOct || ''},${r.medianCents || ''},${r.sdCents || ''},${r.verdict || ''},${r.framesCount || ''}`);
      });
    }
  });
  
  if (csvRows.length <= 1) {
    alert('No recall data to export.');
    return;
  }
  
  const csvContent = csvRows.join('\n');
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `pitch-recall-${getTodayKey()}.csv`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

/* ------------------ TRAINING FLOW ------------------ */
let autoNext=false, delayMs=1000;
let currentNote=null, truePc=null, isOOBTrial=false;
let firstRtBonusMs=0, inFlightTrial=false;
let suggestedRestartFlag=false;

// Jitter system globals for current trial
let currentDetuneCents=0, currentDetuneMode='jitter', currentJlLevel=null;

/* Specials runtime */
let special=null; // {mode:'A'|'B', targetPc:'F', total:12|22, done:0, withFeedback:true, correct:0}

/* Assessment runtime */
let assessmentActive=false, assessmentTrials=[], assessmentCurrentTrial=0;

const PC2I={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
function currentOOBs(setSize){
  if(setSize>=12) return [];
  const learned = trainedSet(setSize).map(n=>PC2I[n]).sort((a,b)=>a-b);
  const low=learned[0], high=learned[learned.length-1];
  const up1=(high+1)%12, up2=(high+2)%12, dn1=(low+11)%12, dn2=(low+10)%12;
  const out=[];
  if(!learned.includes(up1)) out.push(PC[up1]);
  if(!learned.includes(up2) && !learned.includes(up1)) out.push(PC[up2]);
  if(!learned.includes(dn1)) out.push(PC[dn1]);
  if(!learned.includes(dn2) && !learned.includes(dn1)) out.push(PC[dn2]);
  return out;
}
function getPlusMinusTwoSemitones(targetPc){
  const targetIndex = PC2I[targetPc];
  if (targetIndex === undefined) return [targetPc]; // fallback
  
  const pitches = [];
  for (let offset = -2; offset <= 2; offset++) {
    const index = (targetIndex + offset + 12) % 12;
    pitches.push(PC[index]);
  }
  return pitches;
}
function currentOctaves(){ 
  // Clamp generated octaves to 3‚Äì5 (inclusive). Remove any use of 6.
  return [3,4,5]; // Both Guitar and Piano use C3-B5
}
function rand(a){ return a[Math.floor(Math.random()*a.length)]; }
function pcLabel(pc){ return PC_LABEL[pc] || pc; }

/* ------------------ NEW OOB ADAPTATION SYSTEM (3-Block Based) ------------------ */

// Main OOB controller function - called after each graded trial
function updateOobController(trial) {
  // Update rolling windows
  if (!trial.oob && !trial.timeout && trial.guess !== null) {
    // Add to last 60 in-bounds trials
    state.oobController.last60InBounds.push({
      correct: trial.correct,
      time: trial.time
    });
    // Keep only last 60
    if (state.oobController.last60InBounds.length > 60) {
      state.oobController.last60InBounds.shift();
    }
  }
  
  if (trial.oob && !trial.timeout && trial.guess !== null) {
    // Add to recent OOB trials for health check
    state.oobController.recentOobTrials.push({
      correct: trial.correct,
      time: trial.time
    });
    // Keep only last 20
    if (state.oobController.recentOobTrials.length > 20) {
      state.oobController.recentOobTrials.shift();
    }
  }
  
  save();
}

// Check if we should adapt OOB percentage (every 3 blocks)
function checkOobAdaptation() {
  const blockIndex = state.counters.blockIndex;
  
  // Only adapt when (blockIndex % 3) === 0 (blocks 3, 6, 9, etc.)
  if (blockIndex % 3 !== 0) {
    return false;
  }
  
  // Need at least 40 in-bounds trials, prefer 60
  if (state.oobController.last60InBounds.length < 40) {
    console.log(`OOB adaptation skipped: only ${state.oobController.last60InBounds.length} in-bounds trials (need ‚â•40)`);
    return false;
  }
  
  // Run adaptation using the exported function
  adaptOobTargetAtTrainingBlockBoundary();
  return true;
}

// 3) Ensure adaptOobTargetAtTrainingBlockBoundary() exists and is called ONLY at block boundaries
// Runs only when blockIndex % 3 === 0
// Uses last 60 in-bounds; if <40, skip with a "skipped" log row
// Step ¬±3 toward 70‚Äì85% target; clamp 5‚Äì35%
function adaptOobTargetAtTrainingBlockBoundary(blockIndex) {
  // Only run on every 3rd block
  if (blockIndex % 3 !== 0) {
    return false;
  }
  
  const { n: last60N, acc: last60Acc } = getTrainingBlockAcc60();
  
  // Must have at least 40 in-bounds trials
  if (last60N < 40) {
    console.log(`OOB adaptation skipped: only ${last60N} in-bounds trials (need ‚â•40)`);
    
    // Push log row to qa.oobSeries with skipped indication
    if (!window.qa) window.qa = {};
    if (!window.qa.oobSeries) window.qa.oobSeries = [];
    window.qa.oobSeries.push({
      blockIndex: blockIndex,
      context: 'adaptor',
      last60N: last60N,
      acc: null,
      oobPctBefore: null,
      oobPctAfter: null,
      skipped: true
    });
    return false;
  }
  
  const oobPctBefore = state.conf.oobPct || 15; // Current OOB percentage
  
  // Target band: 70-85% in-bounds accuracy
  const targetMin = 0.70;
  const targetMax = 0.85;
  
  let oobPctAfter = oobPctBefore;
  
  if (last60Acc < targetMin) {
    // Too hard - reduce OOB by 3%
    oobPctAfter = Math.max(5, oobPctBefore - 3);
  } else if (last60Acc > targetMax) {
    // Too easy - increase OOB by 3%  
    oobPctAfter = Math.min(35, oobPctBefore + 3);
  }
  // If within target range (70-85%), no change needed
  
  // Update the OOB percentage in state
  state.conf.oobPct = oobPctAfter;
  
  // Push log row to qa.oobSeries
  if (!window.qa) window.qa = {};
  if (!window.qa.oobSeries) window.qa.oobSeries = [];
  window.qa.oobSeries.push({
    blockIndex: blockIndex,
    context: 'adaptor',
    last60N: last60N,
    acc: Math.round(last60Acc * 1000) / 1000, // Round to 3 decimal places
    oobPctBefore: oobPctBefore,
    oobPctAfter: oobPctAfter,
    skipped: false
  });
  
  console.log(`OOB adaptation: Block ${blockIndex}, Acc ${(last60Acc*100).toFixed(1)}%, ${oobPctBefore}% ‚Üí ${oobPctAfter}%`);
  
  save();
  return true;
}

// Export function to window as required
window.adaptOobTargetAtTrainingBlockBoundary = adaptOobTargetAtTrainingBlockBoundary;

// Note: adaptOobPercentage function replaced by adaptOobTargetAtTrainingBlockBoundary

// Health check for beginners - monitor rolling OOB accuracy
function checkOobHealthConditions() {
  const recentOob = state.oobController.recentOobTrials;
  
  if (recentOob.length < 20) {
    return; // Need at least 20 OOB trials
  }
  
  const oobAcc = recentOob.filter(t => t.correct).length / recentOob.length;
  
  // If OOB accuracy < 60%, activate health check
  if (oobAcc < 0.60 && !state.oobController.healthCheckActive) {
    state.oobController.healthCheckActive = true;
    state.oobController.healthCheckEndBlock = state.counters.blockIndex + 6; // Next 2 blocks (3 blocks = 1 adaptation cycle)
    
    // Cap oobPct to 10-12 range
    state.conf.oobPct = Math.max(10, Math.min(12, state.conf.oobPct));
    
    console.log(`Health check activated: OOB accuracy ${(oobAcc*100).toFixed(1)}% < 60%, capping OOB to ${state.conf.oobPct}%`);
  }
  
  // If OOB accuracy ‚â• 75% and health check is active, deactivate it
  if (oobAcc >= 0.75 && state.oobController.healthCheckActive) {
    state.oobController.healthCheckActive = false;
    state.oobController.healthCheckEndBlock = 0;
    
    console.log(`Health check deactivated: OOB accuracy ${(oobAcc*100).toFixed(1)}% ‚â• 75%`);
  }
  
  // Auto-deactivate health check if we've passed the end block
  if (state.oobController.healthCheckActive && 
      state.counters.blockIndex >= state.oobController.healthCheckEndBlock) {
    state.oobController.healthCheckActive = false;
    state.oobController.healthCheckEndBlock = 0;
    
    console.log(`Health check auto-deactivated: reached end block ${state.oobController.healthCheckEndBlock}`);
  }
}

// Update OOB health check at training block boundaries
function updateOobHealthCheckTrainingBlock() {
  // Simply call the existing health check logic
  checkOobHealthConditions();
}

/* ------------------ CONFUSION-AWARE SCHEDULING ------------------ */

// Initialize confusion tracking structures
function initializeConfusionTracking() {
  if (!state.confusionMatrix) {
    // Initialize 12x12 confusion matrix
    state.confusionMatrix = {};
    for (const truePc of PC) {
      state.confusionMatrix[truePc] = {};
      for (const guessPc of PC) {
        state.confusionMatrix[truePc][guessPc] = 0;
      }
    }
  } else {
    // Ensure all entries exist without overwriting existing values
    for (const truePc of PC) {
      if (!state.confusionMatrix[truePc]) {
        state.confusionMatrix[truePc] = {};
      }
      for (const guessPc of PC) {
        if (state.confusionMatrix[truePc][guessPc] === undefined) {
          state.confusionMatrix[truePc][guessPc] = 0;
        }
      }
    }
  }
  
  if (!state.perfStats) {
    // Initialize per-note performance stats
    state.perfStats = {};
    for (const pc of PC) {
      state.perfStats[pc] = {
        last40InBounds: [],
        last40Acc: 0,
        meanRT: 0,
        totalSeen: 0
      };
    }
  } else {
    // Ensure all entries exist without overwriting existing values
    for (const pc of PC) {
      if (!state.perfStats[pc]) {
        state.perfStats[pc] = {
          last40InBounds: [],
          last40Acc: 0,
          meanRT: 0,
          totalSeen: 0
        };
      } else {
        // Ensure all required properties exist
        if (!state.perfStats[pc].last40InBounds) {
          state.perfStats[pc].last40InBounds = [];
        }
        if (state.perfStats[pc].last40Acc === undefined) {
          state.perfStats[pc].last40Acc = 0;
        }
        if (state.perfStats[pc].meanRT === undefined) {
          state.perfStats[pc].meanRT = 0;
        }
        if (state.perfStats[pc].totalSeen === undefined) {
          state.perfStats[pc].totalSeen = 0;
        }
      }
    }
  }
  
  if (state.lastInBoundsPc === undefined) {
    state.lastInBoundsPc = null;
  }
}

// Update confusion matrix on in-bounds error
function updateConfusionMatrix(truePc, guessPc) {
  // Ensure confusion matrix structure exists
  if (!state.confusionMatrix) {
    state.confusionMatrix = {};
  }
  if (!state.confusionMatrix[truePc]) {
    state.confusionMatrix[truePc] = {};
  }
  if (state.confusionMatrix[truePc][guessPc] === undefined) {
    state.confusionMatrix[truePc][guessPc] = 0;
  }
  
  // Now safely increment
  state.confusionMatrix[truePc][guessPc]++;
}

// Update per-note performance stats
function updatePerfStats(pc, correct, rtMs) {
  // Ensure perfStats structure exists
  if (!state.perfStats) {
    state.perfStats = {};
  }
  if (!state.perfStats[pc]) {
    state.perfStats[pc] = {
      last40InBounds: [],
      last40Acc: 0,
      meanRT: 0,
      totalSeen: 0
    };
  }
  
  const stats = state.perfStats[pc];
  
  // Ensure last40InBounds exists
  if (!stats.last40InBounds) {
    stats.last40InBounds = [];
  }
  
  // Add to last40InBounds
  stats.last40InBounds.push({correct, rtMs});
  if (stats.last40InBounds.length > 40) {
    stats.last40InBounds.shift();
  }
  
  // Recalculate stats
  const validTrials = stats.last40InBounds.filter(t => t.rtMs != null && !isNaN(t.rtMs));
  stats.last40Acc = stats.last40InBounds.length > 0 ? 
    stats.last40InBounds.filter(t => t.correct).length / stats.last40InBounds.length : 0;
  stats.meanRT = validTrials.length > 0 ? 
    validTrials.reduce((sum, t) => sum + t.rtMs, 0) / validTrials.length : 0;
  stats.totalSeen++;
}

// D) Compute stats at block START and build frozen block weights - ONLY from in-bounds in trained set
function computeBlockWeightsAtStart() {
  // D) Use getTrainedPCs() as source of truth for trained set
  const trainedPcs = getTrainedPCs();
  
  // Store trained PCs in state.conf.trainedAtBlockStart for logging
  state.conf.trainedAtBlockStart = [...trainedPcs];
  
  // D) Compute perf stats from last 40 in-bounds trials per trained PC
  for (const pc of trainedPcs) {
    const stats = state.perfStats[pc];
    if (stats && stats.last40InBounds) {
      const last40N = stats.last40InBounds.length;
      const last40Acc = last40N > 0 ? 
        stats.last40InBounds.filter(t => t.correct).length / last40N : 0;
      stats.last40Acc = last40Acc;
    }
  }
  
  // D) Find topPair from last ~200 in-bounds trials (restricted to trained PCs)
  const topPair = getTopConfusionPair();
  
  // E) Build frozen block weights ONLY over trained PCs
  const weights = {};
  for (const pc of trainedPcs) {
    let w = 1.0; // Base weight
    
    // Weakness boost: if perf[pc].last40Acc < 0.80 ‚Üí w += 0.5
    const stats = state.perfStats[pc];
    const last40Acc = (stats && typeof stats.last40Acc === 'number') ? stats.last40Acc : 1; // Default to 1.0 if no data (no weakness boost for unknowns)
    if (last40Acc < 0.80) {
      w += 0.5;
    }
    
    // Top confusion boost: if pc === topPair.true ‚Üí w += 0.5
    if (topPair && topPair.true === pc) {
      w += 0.5;
    }
    
    // Floor: w = Math.max(w, 0.5)
    w = Math.max(w, 0.5);
    weights[pc] = w;
  }
  
  // Normalize to sum 1
  const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
  if (totalWeight > 0) {
    for (const pc of trainedPcs) {
      weights[pc] = weights[pc] / totalWeight;
    }
  } else {
    // Fallback: uniform distribution if all weights are 0 (should not happen due to floor)
    const uniformWeight = 1.0 / trainedPcs.length;
    for (const pc of trainedPcs) {
      weights[pc] = uniformWeight;
    }
  }
  
  // Store frozen weights and reset streak tracking
  state.conf.blockWeights = weights;
  state.conf.topPairAtBlockStart = topPair;
  state.conf.prevPc = null;
  state.conf.runLen = 0;
  
  save();
}
function getTopConfusionPair() {
  // D) Get trained PCs as source of truth
  const trainedPcs = getTrainedPCs();
  
  // D) Only use last ~200 in-bounds trials restricted to trained PCs
  const last200InBounds = (state.trials || [])
    .filter(t => !t.oob && !t.timeout && t.guess !== null && 
                 trainedPcs.includes(t.pc) && trainedPcs.includes(t.guess))
    .slice(-200);
  
  // D) Build temp confusion matrix ONLY over trained PCs
  const tempConf = {};
  for (const truePc of trainedPcs) {
    tempConf[truePc] = {};
    for (const guessPc of trainedPcs) {
      tempConf[truePc][guessPc] = 0;
    }
  }
  
  // Count errors only (true != guess), restricted to trained PCs
  for (const trial of last200InBounds) {
    if (!trial.correct && trial.pc && trial.guess && 
        trainedPcs.includes(trial.pc) && trainedPcs.includes(trial.guess)) {
      if (tempConf[trial.pc] && tempConf[trial.pc][trial.guess] !== undefined) {
        tempConf[trial.pc][trial.guess]++;
      }
    }
  }
  
  // D) Find the highest confusion count among trained PCs only
  let topTrue = null;
  let topWrong = null;
  let maxCount = 0;
  
  for (const truePc of trainedPcs) {
    for (const wrongPc of trainedPcs) {
      if (truePc !== wrongPc && tempConf[truePc][wrongPc] > maxCount) {
        maxCount = tempConf[truePc][wrongPc];
        topTrue = truePc;
        topWrong = wrongPc;
      }
    }
  }
  
  return maxCount > 0 ? {true: topTrue, wrong: topWrong, count: maxCount} : null;
}

// F) Anti-streak ‚â§ 2 for in-bounds sampling with guardrails
function choosePcWithAntiStreak(weights) {
  // Guardrails: If no weights, return null
  if (!weights || Object.keys(weights).length === 0) {
    console.warn('choosePcWithAntiStreak: No weights available');
    return null;
  }
  
  // Helper: sample from discrete distribution (weightedSample)
  function weightedSample(weights) {
    const keys = Object.keys(weights);
    const rand = Math.random();
    let cumulative = 0;
    for (const pc of keys) {
      cumulative += weights[pc];
      if (rand <= cumulative) return pc;
    }
    return keys[keys.length - 1]; // Fallback
  }
  
  // Helper: sample excluding a specific PC (weightedSampleExcluding)
  function weightedSampleExcluding(weights, excludePc) {
    const filtered = {};
    let totalWeight = 0;
    for (const pc in weights) {
      if (pc !== excludePc) {
        filtered[pc] = weights[pc];
        totalWeight += weights[pc];
      }
    }
    if (totalWeight === 0) return null;
    
    // Normalize and sample
    for (const pc in filtered) {
      filtered[pc] = filtered[pc] / totalWeight;
    }
    return weightedSample(filtered);
  }
  
  let pc = weightedSample(weights);
  if (pc === state.conf.prevPc && state.conf.runLen >= 2) {
    pc = weightedSampleExcluding(weights, state.conf.prevPc) || pc;
  }
  if (pc === state.conf.prevPc) {
    state.conf.runLen++;
  } else {
    state.conf.prevPc = pc;
    state.conf.runLen = 1;
  }
  
  return pc;
}

// Confusion-aware note selection for in-bounds trials with guardrails
function selectInBoundsNoteConfusionAware(usable) {
  // Use the new scheduler system
  return getScheduledPc();
}

// G) Log confusion series data for completed training blocks (once per block)
function logConfusionSeriesData(blockIndex) {
  // Only log once per 20-trial training block (every block completion)
  
  // Create qa object if needed
  if (!window.qa) window.qa = {};
  if (!window.qa.confSeries) window.qa.confSeries = [];
  
  // G) Log the confusion series entry using frozen weights (keys must match trained)
  window.qa.confSeries.push({
    blockIndex: blockIndex,
    weights: {...(state.conf.blockWeights || {})},  // Copy to ensure keys match trained
    topConfusion: state.conf.topPairAtBlockStart
  });
}

/* ------------------ NEW OOB PRE-PLANNING SYSTEM ------------------ */

function initializeOobBlockPlan() {
  // Freeze the current target for this entire 20-trial Training Block
  state.oob.blockTarget = state.oob.targetPct;
  
  // Apply health check cap if active
  let effectiveTarget = state.oob.blockTarget;
  if (state.oobHealthCheckActive) {
    effectiveTarget = Math.min(effectiveTarget, 0.12); // Cap to 12%
  }
  
  // Compute planned OOB count for this block
  const plannedOOB = Math.round(effectiveTarget * 20);
  
  // Build the plan array with even distribution and streak guard
  state.oob.plan = createOobPlan(plannedOOB);
  
  // Pre-compute octave mix for this block based on current in-bounds octave proportions
  state.oob.planOctaveMix = createOctaveMixForBlock();
  
  // Reset block tracking
  state.oob.currentTrialInBlock = 0;
  
  save();
}

function createOobPlan(plannedOOB) {
  // Create array of 20 false values
  const plan = new Array(20).fill(false);
  
  // If no OOB planned, return all false
  if (plannedOOB === 0) {
    return plan;
  }
  
  // Distribute OOB trials evenly across the 20 slots
  // Use even spacing to avoid clustering
  const spacing = 20 / plannedOOB;
  
  let placed = 0;
  for (let i = 0; i < plannedOOB && placed < plannedOOB; i++) {
    let targetSlot = Math.floor(i * spacing);
    
    // Find next available slot that doesn't violate 2-in-a-row rule
    while (targetSlot < 20 && placed < plannedOOB) {
      if (canPlaceOobAt(plan, targetSlot)) {
        plan[targetSlot] = true;
        placed++;
        break;
      }
      targetSlot++;
    }
  }
  
  // If we couldn't place all planned OOB due to spacing constraints,
  // try to fill remaining slots from the end, respecting the 2-in-a-row rule
  for (let slot = 19; slot >= 0 && placed < plannedOOB; slot--) {
    if (!plan[slot] && canPlaceOobAt(plan, slot)) {
      plan[slot] = true;
      placed++;
    }
  }
  
  return plan;
}

function canPlaceOobAt(plan, slot) {
  // Check if placing OOB at this slot would create >2 in a row
  
  // Count consecutive OOB before this slot
  let beforeCount = 0;
  for (let i = slot - 1; i >= 0 && plan[i]; i--) {
    beforeCount++;
  }
  
  // Count consecutive OOB after this slot
  let afterCount = 0;
  for (let i = slot + 1; i < 20 && plan[i]; i++) {
    afterCount++;
  }
  
  // Check if placing here would create a streak > 2
  const totalStreak = beforeCount + 1 + afterCount;
  return totalStreak <= 2;
}

function createOctaveMixForBlock() {
  // Get octave distribution from current training block
  const totalInBounds = state.currentBlockOctaveCount[3] + state.currentBlockOctaveCount[4] + state.currentBlockOctaveCount[5];
  
  // If no in-bounds trials yet in this block, use equal distribution
  if (totalInBounds === 0) {
    const availableOctaves = currentOctaves();
    return availableOctaves.map(oct => ({ octave: oct, weight: 1.0 / availableOctaves.length }));
  }
  
  // Calculate proportions and only include octaves that have appeared
  const mix = [];
  const availableOctaves = currentOctaves();
  
  for (const octave of availableOctaves) {
    const count = state.currentBlockOctaveCount[octave] || 0;
    if (count > 0) {  // Only include octaves that haven't appeared in-bounds yet
      mix.push({ octave: octave, weight: count / totalInBounds });
    }
  }
  
  // If no octaves have appeared yet, fall back to equal distribution
  if (mix.length === 0) {
    return availableOctaves.map(oct => ({ octave: oct, weight: 1.0 / availableOctaves.length }));
  }
  
  return mix;
}

function sampleOctaveFromMix(octaveMix) {
  if (octaveMix.length === 0) {
    return rand(currentOctaves());
  }
  
  const randomValue = Math.random();
  let cumulative = 0;
  
  for (const item of octaveMix) {
    cumulative += item.weight;
    if (randomValue <= cumulative) {
      return item.octave;
    }
  }
  
  // Fallback to last item
  return octaveMix[octaveMix.length - 1].octave;
}

/* ------------------ NEW OOB SCHEDULING SYSTEM ------------------ */

// OOB streak counter - track consecutive OOB trials
let oobStreak = 0;

function shouldBeOobTrial() {
  // Streak guard: never schedule >2 OOB in a row
  if (oobStreak >= 2) {
    return false; // Force in-bounds
  }
  
  // Use adaptive OOB percentage from state.conf.oobPct
  const oobPct = state.conf.oobPct / 100; // Convert percentage to decimal
  
  // Simple probability-based scheduling
  return Math.random() < oobPct;
}

// Call this after each trial to track the streak
function updateOobStreak(wasOobTrial) {
  if (wasOobTrial) {
    oobStreak++;
  } else {
    oobStreak = 0; // Reset streak on in-bounds trial
  }
}

// Octave parity & mirroring for OOB trials
function selectOobOctaveWithParity(trainedSet) {
  // Get recent in-bounds octave distribution
  const recentInBounds = (state.trials || [])
    .filter(t => !t.oob && t.note)
    .slice(-60); // Last 60 in-bounds trials
  
  if (recentInBounds.length === 0) {
    // No recent data, use default octave distribution
    const octaves = currentOctaves();
    return octaves[Math.floor(Math.random() * octaves.length)];
  }
  
  // Count octave usage in recent in-bounds trials
  const octaveCounts = {};
  const octaves = currentOctaves(); // [3, 4, 5]
  
  // Initialize counts
  octaves.forEach(oct => {
    octaveCounts[oct] = 0;
  });
  
  // Count actual usage
  recentInBounds.forEach(t => {
    const octave = parseInt(t.note.slice(-1));
    if (octaveCounts.hasOwnProperty(octave)) {
      octaveCounts[octave]++;
    }
  });
  
  // Create weighted distribution based on in-bounds usage
  const weights = [];
  const total = recentInBounds.length;
  
  octaves.forEach(oct => {
    const proportion = total > 0 ? octaveCounts[oct] / total : 1 / octaves.length;
    weights.push({ octave: oct, weight: proportion });
  });
  
  // Weighted random selection
  const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
  let random = Math.random() * totalWeight;
  
  for (const w of weights) {
    random -= w.weight;
    if (random <= 0) {
      return w.octave;
    }
  }
  
  // Fallback
  return octaves[Math.floor(Math.random() * octaves.length)];
}

/* ------------------ OCTAVE MIX HYBRID GATED POLICY ------------------ */

// Select octave for in-bounds trials using current mix + per-note overrides
function selectOctaveForInBounds(pc) {
  if (!state.oct) {
    return rand(currentOctaves());
  }
  
  const mix = state.oct.currentMix;
  const overrides = state.oct.perNoteOverrides[pc] || {};
  
  // Check if we're in rescue mode for this PC
  const activeRescue = findActiveRescueForPc(pc);
  
  // Apply per-note override if active (bias toward center octave by 20%)
  // OR apply rescue bias (also 20% toward center)
  let adjustedMix = {...mix};
  if (overrides.active || activeRescue) {
    const centerOct = state.oct.center;
    const biasAmount = 0.20;
    
    // Reduce all octaves proportionally and add bias to center
    const scaleFactor = 1 - biasAmount;
    for (const oct of state.oct.allowed) {
      adjustedMix[oct] *= scaleFactor;
    }
    adjustedMix[centerOct] += biasAmount;
    
    if (activeRescue) {
      console.log(`üéµ Rescue mode octave bias for ${pc}: biasing toward center (${centerOct})`, adjustedMix);
    } else {
      console.log(`üéµ Octave override for ${pc}: biasing toward center (${centerOct})`, adjustedMix);
    }
  }
  
  // Sample from the adjusted mix
  const rand = Math.random();
  let cumulative = 0;
  
  for (const oct of state.oct.allowed) {
    cumulative += adjustedMix[oct] || 0;
    if (rand <= cumulative) {
      console.log(`üéµ Selected octave ${oct} for in-bounds ${pc} (rand=${rand.toFixed(3)}, mix=${JSON.stringify(adjustedMix)})`);
      return oct;
    }
  }
  
  // Fallback to center octave
  console.log(`üéµ Fallback to center octave ${state.oct.center} for ${pc}`);
  return state.oct.center;
}

// Select octave for OOB trials (mirrors in-bounds currentMix)
function selectOctaveForOOB(pc) {
  if (!state.oct) {
    return selectOobOctaveWithParity(trainedSet(setFromIndex(state.levelIndex)));
  }
  
  // Mirror the in-bounds currentMix proportions
  const mix = state.oct.currentMix;
  const rand = Math.random();
  let cumulative = 0;
  
  for (const oct of state.oct.allowed) {
    cumulative += mix[oct] || 0;
    if (rand <= cumulative) {
      console.log(`üéµ OOB octave ${oct} for ${pc} (rand=${rand.toFixed(3)}, mirroring mix=${JSON.stringify(mix)})`);
      return oct;
    }
  }
  
  // Fallback
  console.log(`üéµ OOB fallback to center octave ${state.oct.center} for ${pc}`);
  return state.oct.center;
}

// Called when an in-bounds trial is graded
function onInBoundsGraded(trial) {
  if (!state.oct || trial.oob) return;
  
  // Add trial to current set tracking
  state.oct.inBoundsSinceSetStart.push(trial);
  
  const inBoundsCount = state.oct.inBoundsSinceSetStart.length;
  console.log(`üéØ In-bounds trial ${inBoundsCount} completed (set ${state.oct.setCounter + 1})`);
  
  // Check window thresholds
  if (inBoundsCount === 12 || inBoundsCount === 16 || inBoundsCount === 20 || inBoundsCount === 24) {
    console.log(`üéØ Window threshold reached: ${inBoundsCount} trials, evaluating performance...`);
    evaluateWindowsAndMaybeStep();
  }
}

// Evaluate performance windows and update octave mix
function evaluateWindowsAndMaybeStep() {
  if (!state.oct) return;
  
  const trials = state.oct.inBoundsSinceSetStart;
  const count = trials.length;
  
  let windowStart, windowEnd, windowName, accThreshold, medianThreshold, sdThreshold;
  let isEndOfSet = false;
  
  // Determine which window we're evaluating
  if (count === 12) {
    // Early window: evaluate trials 8-12 (indices 7-11)
    windowStart = 7; windowEnd = 11; windowName = '8-12';
    accThreshold = 0.80; medianThreshold = 15;
  } else if (count === 16) {
    // Mid window: evaluate trials 12-16 (indices 11-15) - only if we didn't switch already
    if (JSON.stringify(state.oct.currentMix) === JSON.stringify({3:0.05, 4:0.90, 5:0.05})) {
      windowStart = 11; windowEnd = 15; windowName = '12-16';
      accThreshold = 0.80; medianThreshold = 15;
    } else {
      return; // Already switched, skip mid window
    }
  } else if (count === 20) {
    // Late window: evaluate trials 16-20 (indices 15-19)
    windowStart = 15; windowEnd = 19; windowName = '16-20';
    accThreshold = 0.85; medianThreshold = 12;
  } else if (count === 24) {
    // End-of-set: evaluate all 24 trials (indices 0-23)
    windowStart = 0; windowEnd = 23; windowName = '20-24';
    accThreshold = 0.90; medianThreshold = 10; sdThreshold = 15;
    isEndOfSet = true;
  } else {
    return;
  }
  
  // Extract window trials
  const windowTrials = trials.slice(windowStart, windowEnd + 1);
  
  // Calculate statistics
  const stats = calculateWindowStats(windowTrials);
  
  // Store current mix for logging
  const fromMix = {...state.oct.currentMix};
  let toMix = null;
  let eventType = isEndOfSet ? 'end' : (windowName === '8-12' ? 'early' : windowName === '12-16' ? 'mid' : 'late');
  
  // Apply decision rules
  if (isEndOfSet) {
    // End-of-set decision affects next set's baseline
    if (stats.acc >= 0.90 && stats.median <= 10 && stats.sd <= 15) {
      state.oct.baselineMix = {3:0.25, 4:0.50, 5:0.25}; // 50/50 center/neighbors
    } else if (stats.acc >= 0.85 && stats.median <= 12) {
      state.oct.baselineMix = {3:0.20, 4:0.60, 5:0.20}; // 60/40
    } else if (stats.acc < 0.80) {
      state.oct.baselineMix = {3:0.15, 4:0.70, 5:0.15}; // 70/30 (or fallback 90/10 if struggling)
      if (stats.acc < 0.60) {
        state.oct.baselineMix = {3:0.05, 4:0.90, 5:0.05}; // 90/10 fallback
      }
    }
    
    // Reset for next set
    state.oct.setCounter++;
    state.oct.inBoundsSinceSetStart = [];
    state.oct.currentMix = {...state.oct.baselineMix};
    toMix = {...state.oct.currentMix};
  } else {
    // Within-set decision affects current mix
    if (windowName === '16-20') {
      // Late window: higher thresholds
      if (stats.acc >= accThreshold && stats.median <= medianThreshold) {
        state.oct.currentMix = {3:0.20, 4:0.60, 5:0.20}; // 60/40
        toMix = {...state.oct.currentMix};
      }
    } else {
      // Early/mid window: standard thresholds
      if (stats.acc >= accThreshold && stats.median <= medianThreshold) {
        state.oct.currentMix = {3:0.15, 4:0.70, 5:0.15}; // 70/30
        toMix = {...state.oct.currentMix};
      }
    }
  }
  
  // Log the decision
  if (toMix || isEndOfSet) {
    const logEntry = {
      ts: Date.now(),
      set: state.oct.setCounter,
      event: eventType,
      win: windowName,
      acc: stats.acc,
      median: stats.median,
      sd: stats.sd,
      from: fromMix,
      to: toMix || fromMix
    };
    state.oct.history.push(logEntry);
    
    console.log(`üèÜ Octave policy decision:`, logEntry);
    if (toMix && JSON.stringify(fromMix) !== JSON.stringify(toMix)) {
      console.log(`üéØ Mix changed from ${JSON.stringify(fromMix)} to ${JSON.stringify(toMix)}`);
    }
  }
  
  // Update per-note overrides based on rolling performance
  updatePerNoteOverrides();
}

// Calculate statistics for a window of trials
function calculateWindowStats(trials) {
  if (trials.length === 0) {
    return { acc: 0, median: 0, sd: 0 };
  }
  
  // Accuracy
  const correctCount = trials.filter(t => t.correct).length;
  const acc = correctCount / trials.length;
  
  // Cents errors (use signed error if available, otherwise compute from guess vs true)
  const centsErrors = [];
  for (const trial of trials) {
    // For now, we don't have cents error field, so skip cents calculation
    // In a real implementation, this would extract signed cents error from detune info
    if (typeof trial.centsError === 'number') {
      centsErrors.push(trial.centsError);
    }
  }
  
  let median = 0, sd = 0;
  if (centsErrors.length > 0) {
    centsErrors.sort((a, b) => a - b);
    const mid = Math.floor(centsErrors.length / 2);
    median = centsErrors.length % 2 === 0 
      ? (centsErrors[mid - 1] + centsErrors[mid]) / 2 
      : centsErrors[mid];
    
    const mean = centsErrors.reduce((sum, err) => sum + err, 0) / centsErrors.length;
    const variance = centsErrors.reduce((sum, err) => sum + Math.pow(err - mean, 2), 0) / centsErrors.length;
    sd = Math.sqrt(variance);
  }
  
  return { acc, median: Math.abs(median), sd };
}

// Update per-note override flags based on rolling last-40 performance
function updatePerNoteOverrides() {
  if (!state.oct || !state.trials) return;
  
  // Get last 40 in-bounds trials per pitch class
  const recentTrials = state.trials
    .filter(t => !t.oob && t.truePc)
    .slice(-200); // Look at more trials to get enough per PC
  
  // Group by pitch class
  const byPc = {};
  for (const trial of recentTrials) {
    const pc = trial.truePc;
    if (!byPc[pc]) byPc[pc] = [];
    byPc[pc].push(trial);
  }
  
  // Evaluate each pitch class
  for (const pc of PC) {
    const pcTrials = (byPc[pc] || []).slice(-40); // Last 40 for this PC
    
    if (pcTrials.length >= 10) { // Need at least 10 trials to evaluate
      const correctCount = pcTrials.filter(t => t.correct).length;
      const acc = correctCount / pcTrials.length;
      
      // Check if this PC is weak (acc < 75% or median > 25¬¢)
      // For now, only use accuracy threshold since we don't have cents errors
      const isWeak = acc < 0.75;
      
      if (!state.oct.perNoteOverrides[pc]) {
        state.oct.perNoteOverrides[pc] = { active: false, lastEvaluated: 0 };
      }
      
      state.oct.perNoteOverrides[pc].active = isWeak;
      state.oct.perNoteOverrides[pc].lastEvaluated = Date.now();
    }
  }
}

/* ------------------ OCTAVE POLICY DEBUG HELPERS ------------------ */

// Debug helper function - expose to global scope for console access
window.debugOctavePolicy = function() {
  if (!state.oct) {
    console.log('‚ùå Octave policy not initialized');
    return;
  }
  
  const trials = state.oct.inBoundsSinceSetStart;
  const octaveCount = {3: 0, 4: 0, 5: 0};
  trials.forEach(trial => {
    const octave = trial.targetOctave || parseInt(trial.note?.slice(-1));
    if (octave >= 3 && octave <= 5) {
      octaveCount[octave]++;
    }
  });
  
  console.log('üéµ Octave Policy Debug Info:');
  console.log('üìä Current state:', {
    setCounter: state.oct.setCounter,
    trialsInCurrentSet: trials.length,
    currentMix: state.oct.currentMix,
    baselineMix: state.oct.baselineMix
  });
  console.log('üìà Octave distribution:', octaveCount);
  console.log('üìù Recent history:', state.oct.history.slice(-3));
  console.log('‚ö†Ô∏è Per-note overrides:', state.oct.perNoteOverrides);
  
  // Calculate expected vs actual distribution
  const total = trials.length;
  if (total > 0) {
    const expectedDist = {
      3: Math.round(state.oct.currentMix[3] * total),
      4: Math.round(state.oct.currentMix[4] * total), 
      5: Math.round(state.oct.currentMix[5] * total)
    };
    console.log('üéØ Expected vs Actual:', {expected: expectedDist, actual: octaveCount});
  }
};

function getOobCandidatesWithMirroring(set) {
  const baseOobs = currentOOBs(set);
  if (baseOobs.length === 0) return [];
  
  // Use pre-computed octave mix for this trial
  const targetOctave = sampleOctaveFromMix(state.oob.planOctaveMix);
  
  // For health check: prefer OOB chroma far from trained notes
  if (state.oobHealthCheckActive) {
    const trainedPcs = trainedSet(set);
    const trainedIndices = trainedPcs.map(pc => PC2I[pc]);
    
    const farOobs = baseOobs.filter(pc => {
      const pcIndex = PC2I[pc];
      return !trainedIndices.some(trainedIdx => {
        const dist = Math.min(
          Math.abs(pcIndex - trainedIdx),
          12 - Math.abs(pcIndex - trainedIdx)
        );
        return dist <= 1; // Avoid ¬±1 semitone
      });
    });
    
    const candidateList = farOobs.length > 0 ? farOobs : baseOobs;
    return {pc: rand(candidateList), octave: targetOctave};
  }
  
  return {pc: rand(baseOobs), octave: targetOctave};
}

// 1) Implement getTrainingBlockAcc60()
// Filter last 60 in-bounds (!oob) from state.trials
// Return { n, acc } with acc=null if n===0
function getTrainingBlockAcc60() {
  const trials = state.trials || [];
  
  // Filter in-bounds trials (not OOB)
  const inBoundsTrials = trials.filter(t => !t.oob);
  
  // Get last 60 in-bounds trials
  const last60InBounds = inBoundsTrials.slice(-60);
  const n = last60InBounds.length;
  
  // Return acc=null if no trials
  if (n === 0) {
    return { n: 0, acc: null };
  }
  
  // Calculate accuracy
  const correct = last60InBounds.filter(t => t.correct).length;
  const acc = correct / n;
  
  return { n, acc };
}

// 2) Implement logTrainingBlockOobData(context='boundary')
// Uses getTrainingBlockAcc60()
// Appends one row to qa.oobSeries: { blockIndex, context, last60N, last60Acc, oobPct }
// Console log a compact line for QA
function logTrainingBlockOobData(blockIndex, context = 'boundary') {
  // Get last 60 in-bounds accuracy stats
  const { n: last60N, acc: last60Acc } = getTrainingBlockAcc60();
  
  // Calculate observed OOB% for this Training Block
  const blockTrials = state.trials.filter(t => 
    t.set === setFromIndex(state.levelIndex) && 
    t.block === blockFromIndex(state.levelIndex)
  );
  const oobTrials = blockTrials.filter(t => t.oob);
  const oobPct = blockTrials.length > 0 ? (oobTrials.length / blockTrials.length * 100) : 0;
  
  // Push to qa.oobSeries (note: this creates qa object if it doesn't exist)
  if (!window.qa) window.qa = {};
  if (!window.qa.oobSeries) window.qa.oobSeries = [];
  
  // Append one row to qa.oobSeries as specified
  window.qa.oobSeries.push({
    blockIndex: blockIndex,
    context: context,
    last60N: last60N,
    last60Acc: last60Acc,
    oobPct: Math.round(oobPct * 10) / 10  // Round to 1 decimal place
  });
  
  // Console log a compact line for QA
  const accStr = last60Acc !== null ? `${(last60Acc * 100).toFixed(1)}%` : 'null';
  console.log(`QA Block ${blockIndex}: last60=${last60N}(${accStr}), OOB=${oobPct.toFixed(1)}%`);
}

function updateOobStatusPill() {
  const targetPctDisplay = state.conf.oobPct; // Already in percentage format
  text('oobStatusPill', `OOB ${targetPctDisplay}%`);
}

function updateLevelUI(){
  const set=setFromIndex(state.levelIndex), block=blockFromIndex(state.levelIndex);
  text('setInfo', `Set ${set} / 12`);
  text('blockInfo', `Block ${block} / 24`);
  if(block >= 21){ text('accInfo', `Testing ‚Äî No Feedback`); }
  else{
    const req=(thresholdForIndex(state.levelIndex)*100).toFixed(0);
    const acc=((state.levelCorrect/state.levelTrials*100)||0).toFixed(0);
    text('accInfo', `Acc ${acc}% (req ${req}%)`);
  }
  text('delayInfo', `RT limit: ${rtWindowForSet(set)}ms ‚Ä¢ Delay: ${delayMs}ms`);
  
  // Update block time display with current/total format
  updateBlockTimeDisplay();
  
  // Update OOB status pill
  updateOobStatusPill();
}

function updateBlockTimeDisplay() {
  // Calculate blocks per set (24 blocks total, 5 blocks per set for timing purposes)
  const BLOCKS_PER_SET = 5;
  const currentTrainingBlock = ((state.currentBlock - 1) % BLOCKS_PER_SET) + 1;
  const blockTime = getBlockActiveTime();
  const blockTimeStr = fmtMMSS(blockTime);
  text('blockTimeInfo', `${currentTrainingBlock}/${BLOCKS_PER_SET} ${blockTimeStr}/6:00`);
}

/* Build note pad and attach handlers */
function paintNotes(){
  const pad=byId('notePad'); if(!pad) return; pad.innerHTML='';
  const set=setFromIndex(state.levelIndex);
  const learned = new Set(trainedSet(set));
  const sorted = PC.filter(pc=> learned.has(pc));
  for(const pc of sorted){
    const b=document.createElement('button');
    b.textContent=pcLabel(pc);
    // B) Set data-pc to canonical label
    b.dataset.pc=pc;  // pc is already canonical from PC array
    b.className='note';
    b.type='button';
    // B) In click handler, pass structured input to finalizeGrade
    b.addEventListener('click', (e)=> {
      const pc = normalizePc(e.target.dataset.pc || e.target.textContent);
      finalizeGrade({ pc: pc, isOOB: false });
    });
    pad.appendChild(b);
  }
  safe('btnOOB', el=> {
    el.style.display = set>=12 ? 'none' : 'block';
    el.onclick = ()=> finalizeGrade({ pc: null, isOOB: true });
  });
}

/* Shepard gating for tests */
function maybeRunShepard(){
  const blk=blockFromIndex(state.levelIndex);
  if(!blockHasFeedback(blk) && state.shepardDoneFor!==state.levelIndex){
    state.shepardDoneFor=state.levelIndex; save();
    return playShepard20s();
  }
  return Promise.resolve();
}

/* ---------- Specials at BLOCK 15 (weakest from last 15 blocks) ---------- */
function chooseWeakestFromLastBlocks(nBlocks=15){
  const set = setFromIndex(state.levelIndex);
  const curBlock = blockFromIndex(state.levelIndex);
  const from = Math.max(1, curBlock - (nBlocks - 1));
  const trained = new Set(trainedSet(set));
  const windowTrials = (state.trials||[]).filter(t =>
    t.set === set && t.block >= from && t.block <= curBlock && t.block >= 1 && t.block <= 20
  );
  const stats = new Map();
  for(const pc of trained) stats.set(pc, {ok:0, n:0, order:UNLOCK_ORDER.indexOf(pc)});
  for(const t of windowTrials){ if(!trained.has(t.pc)) continue; const s=stats.get(t.pc); s.n++; if(t.correct) s.ok++; }
  let pick=null;
  for(const [pc,s] of stats){
    if(pick===null) pick={pc,...s};
    else if(s.ok < pick.ok || (s.ok===pick.ok && s.n > pick.n) || (s.ok===pick.ok && s.n===pick.n && s.order < pick.order)) pick={pc,...s};
  }
  return pick ? pick.pc : UNLOCK_ORDER[Math.min(set-1, UNLOCK_ORDER.length-1)];
}
function startSpecialAtBlock15(){
  const set = setFromIndex(state.levelIndex);
  if(set < 5) return false;
  if(blockFromIndex(state.levelIndex) !== 15) return false;
  if(state.specialRanForLevel === state.levelIndex) return false;
  state.specialRanForLevel = state.levelIndex; save();

  const targetPc = chooseWeakestFromLastBlocks(15);
  special = {mode:'A', targetPc, total:12, done:0, withFeedback:true, correct:0};
  showSpecialUI(true, `Special A ‚Äî focus: ${pcLabel(targetPc)}`);
  text('btnTarget', `Target (${pcLabel(targetPc)})`);
  text('btnOther',  'Other (¬±2 semitones)');
  nextSpecialTrial(true);
  return true;
}
function showSpecialUI(show, label){
  if(show){
    showFlex('specialBar'); text('specialText', label||'Special Exercise');
    text('specialCount', '0 / 0');
    showBlock('binaryPad'); hide('notePad'); hide('btnOOB');
  }else{
    hide('specialBar'); hide('binaryPad'); showBlock('notePad');
    const set=setFromIndex(state.levelIndex);
    safe('btnOOB', el=> el.style.display = set>=12 ? 'none' : 'block');
  }
}
function nextSpecialTrial(){
  if(!special) return;
  const set=setFromIndex(state.levelIndex);
  const plusMinusTwoPitches = getPlusMinusTwoSemitones(special.targetPc);
  const isTarget = Math.random()<0.5;
  const pitchPc = isTarget ? special.targetPc : rand(plusMinusTwoPitches.filter(p => p !== special.targetPc));
  truePc = pitchPc; isOOBTrial = !isTarget;
  currentNote = `${pitchPc}${rand(currentOctaves())}`;
  playSample(currentNote);
  clearTimeout(rtTimer); rtTimer=null; // no RT in specials
  text('promptPill','Target or Other?');
  text('specialCount', `${special.done} / ${special.total}`);
}
function endSpecialOrAdvance(){
  if(!special) return;
  if(special.done >= special.total){
    if(special.mode==='A'){
      special = {mode:'B', targetPc: special.targetPc, total:22, done:0, withFeedback:false, correct:0};
      showSpecialUI(true, `Special B ‚Äî focus: ${pcLabel(special.targetPc)}`);
      text('btnTarget', `Target (${pcLabel(special.targetPc)})`);
      nextSpecialTrial();
    }else{
      const trials = (state.trials||[]).filter(t=> (t.special==='A' || t.special==='B') && t.pc===special.targetPc);
      const ok = trials.filter(t=> t.correct).length;
      const n  = trials.length;
      const pct = n ? Math.round((ok/n)*1000)/10 : 0;
      alert(`üéâ Hooray! You identified ${pcLabel(special.targetPc)} at ${pct}% accuracy.`);
      special = null; showSpecialUI(false);
      text('promptPill','Specials done ‚Äî press Play to continue');
      /* one-shot suppress strict modal after specials */
      suppressStrictOnce = true;
    }
  }
}
function answerSpecial(userSaysTarget){
  if(!special) return;
  const correct = (userSaysTarget && !isOOBTrial) || (!userSaysTarget && isOOBTrial);
  state.trials.push({note:currentNote, pc:truePc, guess:userSaysTarget?'TARGET':'OTHER', correct, timeout:false, oob:isOOBTrial, set:setFromIndex(state.levelIndex), block:0, time:Date.now(), special:special.mode});
  save();
  if(special.withFeedback){
    feedback(correct, correct ? undefined : (isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`));
  }
  if(correct) special.correct = (special.correct||0) + 1;
  special.done++; text('specialCount', `${special.done} / ${special.total}`);
  if(special.done >= special.total) { endSpecialOrAdvance(); return; }
  setTimeout(()=> nextSpecialTrial(), Math.max(500, delayMs));
}

/* ------------------ ASSESSMENT TEST ------------------ */
function startAssessment() {
  // Show warning modal first
  byId('assessmentWarningModal').style.display = 'flex';
}

function proceedWithAssessment() {
  // Hide warning modal and start assessment
  byId('assessmentWarningModal').style.display = 'none';
  
  showScreen('assessmentScreen');
  assessmentActive = false;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  text('assessmentProgress', 'Trial 0 / 20');
  text('assessmentPrompt', 'Press Start to begin assessment');
  hide('assessmentResults');
  
  populateAssessmentNotes();
}

function cancelAssessment() {
  byId('assessmentWarningModal').style.display = 'none';
}

function populateAssessmentNotes() {
  const pad = byId('assessmentPad');
  if (!pad) return;
  pad.innerHTML = '';
  
  for (const pc of PC) {
    const b = document.createElement('button');
    b.textContent = pcLabel(pc);
    b.dataset.pc = pc;
    b.className = 'note';
    b.type = 'button';
    b.addEventListener('click', () => assessmentGuess(pc));
    pad.appendChild(b);
  }
}

function beginAssessment() {
  assessmentActive = true;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  // Generate 20 random trials with random audio types and pitches
  for (let i = 0; i < 20; i++) {
    const audioTypes = [AUDIO_TYPES.PIANO, AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR];
    const randomAudioType = rand(audioTypes);
    const randomPc = rand(PC);
    
    // Use appropriate octave range for the audio type - clamp to 3-5
    let octaves = [3, 4, 5]; // Both audio types now use same range
    const randomOctave = rand(octaves);
    
    assessmentTrials.push({
      pc: randomPc,
      note: `${randomPc}${randomOctave}`,
      audioType: randomAudioType,
      answered: false,
      guess: null,
      correct: false
    });
  }
  
  nextAssessmentTrial();
}

async function nextAssessmentTrial() {
  if (assessmentCurrentTrial >= assessmentTrials.length) {
    completeAssessment();
    return;
  }
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  text('assessmentProgress', `Trial ${assessmentCurrentTrial + 1} / 20`);
  text('assessmentPrompt', 'Listening‚Ä¶ choose the pitch');
  
  // Temporarily change audio type for this trial
  const originalAudioType = state.audioType;
  state.audioType = trial.audioType;
  
  try {
    await playSample(trial.note);
  } finally {
    // Restore original audio type
    state.audioType = originalAudioType;
  }
}

function assessmentGuess(pc) {
  if (!assessmentActive || assessmentCurrentTrial >= assessmentTrials.length) return;
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  if (trial.answered) return;
  
  trial.answered = true;
  trial.guess = pc;
  trial.correct = (pc === trial.pc);
  
  assessmentCurrentTrial++;
  
  // Small delay before next trial
  setTimeout(() => {
    if (assessmentCurrentTrial < assessmentTrials.length) {
      nextAssessmentTrial();
    } else {
      completeAssessment();
    }
  }, 800);
}

function completeAssessment() {
  assessmentActive = false;
  
  let correct = 0;
  let nearMiss = 0; // Within ¬±1 semitone
  
  for (const trial of assessmentTrials) {
    if (trial.correct) {
      correct++;
    } else if (trial.guess) {
      const targetIdx = PC2I[trial.pc];
      const guessIdx = PC2I[trial.guess];
      const distance = Math.min(
        Math.abs(targetIdx - guessIdx),
        12 - Math.abs(targetIdx - guessIdx)
      );
      if (distance <= 1) {
        nearMiss++;
      }
    }
  }
  
  const exactPercent = Math.round((correct / 20) * 100);
  const nearMissPercent = Math.round((nearMiss / 20) * 100);
  
  // Store result
  const result = {
    date: Date.now(),
    exact: exactPercent,
    nearMiss: nearMissPercent,
    trials: assessmentTrials.slice()
  };
  
  state.assessmentScores.push(result);
  save();
  
  // Show results in modal
  const modalStats = byId('modalAssessmentStats');
  if (modalStats) {
    modalStats.innerHTML = `
      <div style="font-size:18px;margin:8px 0">
        <div><strong>Exact Correct: ${exactPercent}%</strong> (${correct}/20)</div>
        <div>Within ¬±1 semitone: ${nearMissPercent}% (${nearMiss}/20)</div>
      </div>
    `;
  }
  
  // Show results modal
  byId('assessmentResultsModal').style.display = 'flex';
  
  // Update chart if possible
  try { drawChart(); } catch(_) {}
}

/* ------------------ ASSESSMENT TRACKER ------------------ */
function showTracker() {
  showScreen('trackerScreen');
  updateTrackerDisplay();
  drawTrackerChart();
}

function updateTrackerDisplay() {
  const scores = state.assessmentScores || [];
  const count = scores.length;
  text('trackerCount', `${count} assessment${count === 1 ? '' : 's'}`);
  
  const history = byId('trackerHistory');
  if (!history) return;
  
  if (count === 0) {
    history.innerHTML = '<p style="opacity:0.7;text-align:center">No assessments completed yet</p>';
    return;
  }
  
  // Sort by date (most recent first)
  const sortedScores = [...scores].sort((a, b) => b.date - a.date);
  
  let html = '';
  sortedScores.forEach((score, index) => {
    const date = new Date(score.date).toLocaleDateString();
    const time = new Date(score.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    html += `
      <div style="padding:8px;margin:4px 0;border-radius:8px;background:var(--muted2);display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>${date} ${time}</strong>
        </div>
        <div>
          <span style="color:var(--good)">Exact: ${score.exact}%</span> ‚Ä¢ 
          <span style="color:var(--accent)">¬±1: ${score.nearMiss}%</span>
        </div>
      </div>
    `;
  });
  
  history.innerHTML = html;
}

function drawTrackerChart() {
  const canvas = byId('trackerCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  
  const P = {l: 56, r: 24, t: 16, b: 28};
  const AX = P.l, AY = P.t, AW = W - P.l - P.r, AH = H - P.t - P.b;
  
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  const colMuted = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.fillStyle = colCard;
  ctx.fillRect(0, 0, W, H);
  
  const scores = state.assessmentScores || [];
  if (scores.length === 0) {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
    ctx.font = '14px Fredoka, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No assessment data yet', W / 2, H / 2);
    return;
  }
  
  // Sort by date
  const sortedScores = [...scores].sort((a, b) => a.date - b.date);
  
  const maxTests = Math.max(10, sortedScores.length);
  const xScale = (i) => AX + (i / (maxTests - 1)) * AW;
  const yScale = (pct) => AY + AH - (pct / 100) * AH;
  
  // Draw grid lines
  ctx.strokeStyle = colMuted;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 100; i += 20) {
    const y = yScale(i);
    ctx.beginPath();
    ctx.moveTo(AX, y);
    ctx.lineTo(AX + AW, y);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(AX, AY);
  ctx.lineTo(AX, AY + AH);
  ctx.lineTo(AX + AW, AY + AH);
  ctx.stroke();
  
  // Draw Y-axis labels
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
  ctx.font = '12px Fredoka, sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 100; i += 20) {
    ctx.fillText(`${i}%`, AX - 8, yScale(i) + 4);
  }
  
  if (sortedScores.length > 1) {
    // Draw exact scores line
    const exactColor = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.beginPath();
    ctx.strokeStyle = exactColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.exact);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Draw near-miss scores line
    const nearMissColor = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.beginPath();
    ctx.strokeStyle = nearMissColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.nearMiss);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }
  
  // Draw data points
  sortedScores.forEach((score, i) => {
    const x = xScale(i);
    
    // Exact score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.exact), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.fill();
    
    // Near-miss score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.nearMiss), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.fill();
  });
}

/* -------- Normal trials -------- */
/* NOTE: guess() and chooseOOB() functions removed - replaced by gradeGuess() */

/* Driving */
function scheduleAuto(){ if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; } if(autoNext && sessionActive && !paused && !shepRunning && !special){ autoTimer = setTimeout(()=> nextTrial(true), delayMs); } }
async function nextTrial(forceNew=false){
  if(!sessionActive || paused || shepRunning || special) return;
  if(inFlightTrial) return;

  /* clear the one-shot strict suppression as soon as normal play resumes */
  suppressStrictOnce = false;

  if(startSpecialAtBlock15()) return;

  inFlightTrial=true;
  try{
    await resumeCtx();
    await maybeRunShepard();
    if(paused || !sessionActive || special) return;
    if(!currentNote || forceNew){
      // B) Schedule path must tag in-bounds/OOB explicitly
      const trained = getTrainedPCs();
      const isOOB = shouldBeOobTrial() && currentOOBs(setFromIndex(state.levelIndex)).length > 0;
      
      let chosenPc;
      if (isOOB) {
        chosenPc = pickOobPc(trained);
      } else {
        // Use confusion-aware scheduler for in-bounds
        const usable = trainedSet(setFromIndex(state.levelIndex));
        chosenPc = selectInBoundsNoteConfusionAware(usable) || (trained.length > 0 ? trained[Math.floor(Math.random() * trained.length)] : 'F'); // Fallback
      }
      
      // C) Freeze the ground-truth at schedule time
      const truePc = normalizePc(chosenPc);
      const plannedOOB = !!isOOB;
      let detuneCents = 0, detuneMode = 'anchor', jlLevel = null;
      let chosenOctave;
      
      if (plannedOOB) {
        detuneCents = 0; 
        detuneMode = 'oob'; 
        jlLevel = null;
        
        // Use octave parity mirroring for OOB trials
        chosenOctave = selectOctaveForOOB(truePc);
        currentNote = `${truePc}${chosenOctave}`;
      } else {
        // in-bounds: call chooseDetuneMode(truePc) and assign cents/mode/jlLevel
        const detuneInfo = selectDetune(truePc, false);
        detuneCents = detuneInfo.cents;
        detuneMode = detuneInfo.mode;
        jlLevel = detuneInfo.jlLevel;
        
        chosenOctave = selectOctaveForInBounds(truePc);
        currentNote = `${truePc}${chosenOctave}`;
      }
      
      // C) Freeze in state.current (REQUIRED for grading)
      state.meta.trialSeq = (state.meta.trialSeq || 0) + 1;
      // Select timbre for this trial
      const selectedTimbre = plannedOOB && state.lastInBoundsTimbre ? 
        state.lastInBoundsTimbre : // OOB mirrors in-bounds timbre
        selectTimbreForTrial(truePc); // Normal selection
      
      // Store selected timbre for next OOB trial
      if (!plannedOOB) {
        state.lastInBoundsTimbre = selectedTimbre;
      }
      
      state.current = {
        trialId: state.meta.trialSeq,        // integer incrementing
        truePc,                                // REQUIRED; non-null
        oob: !!plannedOOB,
        octave: chosenOctave,
        timbre: selectedTimbre,
        detuneCents, detuneMode, jlLevel,
        startedAt: performance.now()
      };
      
      // Store frozen trial state globally for backward compatibility
      isOOBTrial = plannedOOB;
      currentDetuneCents = detuneCents;
      currentDetuneMode = detuneMode;
      currentJlLevel = jlLevel;
      
      // Open the trial for input
      state.trialOpen = true;
    }
    
    await playSample(currentNote, currentDetuneCents, state.current.timbre);
    if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
    const baseRt = rtWindowForSet(setFromIndex(state.levelIndex));
    const rtms = baseRt + firstRtBonusMs + LATENCY_CUSHION_MS;
    firstRtBonusMs = 0;
    rtTimer = setTimeout(()=>handleTimeout(), rtms);
    
    // Trial is now open, block HUD shows current progress
    updateBlockHUD();
  }catch(e){ report(e); }
  finally{ inFlightTrial=false; }
}

/* ------------------ ATOMIC GRADING SYSTEM ------------------ */

function finalizeGrade(args) {
  const cur = state.current;
  if (!cur || state.grade?.inProgress || state.grade?.lastTrialId === cur.trialId) return;
  state.grade = { inProgress: true, lastTrialId: cur.trialId };

  // A) Handle both old and new calling conventions for compatibility
  if (typeof args === 'string' || args === null) {
    // Legacy call: finalizeGrade(guessPcRaw) - convert to structured format
    const guessPcRaw = args;
    args = { 
      pc: guessPcRaw === 'OOB' ? null : guessPcRaw, 
      isOOB: guessPcRaw === 'OOB' 
    };
  }
  
  // B) Compute correctness with OOB-aware rule
  const truePc = cur.truePc;
  const isOobTrial = !!cur.oob;
  const isOobGuess = !!args.isOOB;
  const guessPc = normalizePc(args.pc);
  
  const correct = isOobTrial ? isOobGuess : (guessPc !== null && guessPc === truePc);
  const isTimeout = args.pc === null && !args.isOOB;

  // C) Store trials consistently with new fields
  const t = {
    time: Date.now(),
    trialId: cur.trialId,
    note: cur.truePc + String(cur.octave ?? ''),
    // New structured fields
    truePc: cur.truePc,
    guessPc: guessPc,
    guessIsOOB: isOobGuess,
    correct,
    timeout: isTimeout,
    oob: !!cur.oob,
    rtMs: Math.round(performance.now() - (cur.startedAt || performance.now())),
    detuneCents: cur.detuneCents ?? 0,
    detuneMode: cur.detuneMode || (cur.oob ? 'oob' : 'anchor'),
    jlLevel: cur.jlLevel ?? null,
    timbreUsed: cur.timbre || state.audioType || 'sine',
    timbre: cur.timbre || state.audioType || 'sine', // Add explicit timbre field as specified
    // Piano-specific octave tracking
    targetOctave: cur.octave ?? null,
    sourceOctave: (state.audioType === AUDIO_TYPES.PIANO) ? cur.octave : cur.octave, // For piano: sourceOctave = targetOctave (no remapping)
    semitoneShift: (state.audioType === AUDIO_TYPES.PIANO) ? 0 : (cur.semitoneShift ?? 0), // Piano has no coarse octave shift
    // Legacy fields for compatibility with old readers:
    pc: cur.truePc,
    guess: isOobGuess ? 'OOB' : guessPc
  };
  
  state.trials.push(t);
  state.grade.inProgress = false;

  // Update timbre statistics for variety mode
  if (cur.timbre && cur.truePc && !isOobTrial) { // Only track in-bounds trials
    updateTimbreStats(cur.truePc, cur.timbre, correct, cur.detuneCents || 0);
  }

  renderFeedback(t);
  scheduleNextTrial();
}

function scheduleNextTrial() {
  // Clear current note and close trial
  currentNote = null;
  state.trialOpen = false;
  
  // Clear RT timer
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  
  // Update stats/scheduler
  if (state.trials.length > 0) {
    const lastTrial = state.trials[state.trials.length - 1];
    recordTrialStats(lastTrial);
  }
  
  advanceCheck();
  scheduleAuto();
}

/* ------------------ CENTRALIZED GRADING (LEGACY - REPLACED) ------------------ */
// D) Grade from the frozen ground-truth only
function gradeGuess(guessPcRaw) {
  if(!sessionActive || paused || shepRunning || special) return;
  if(!state.trialOpen) return; // Input locking - ignore late clicks
  
  // Convert legacy calls to structured format
  finalizeGrade({ pc: guessPcRaw === 'OOB' ? null : guessPcRaw, isOOB: guessPcRaw === 'OOB' });
}

// E) Make the feedback UI null-safe and OOB-aware
function renderFeedback(trial) {
  const fb = blockHasFeedback(blockFromIndex(state.levelIndex));
  if (!fb && !special?.withFeedback) return;
  
  const box = byId('feedbackBox');
  const overlay = byId('feedbackOverlay');
  if (!box || !overlay) return;
  
  box.style.background = trial.correct ? 'var(--good)' : 'var(--bad)';
  
  if (trial.correct) {
    if (trial.oob) {
      box.textContent = 'Correct ‚Äî that was out of bounds.';
    } else {
      box.textContent = 'Correct!';
    }
  } else {
    if (trial.oob) {
      const safeLabel = trial.truePc ? pcLabel(trial.truePc) : '(unknown)';
      box.textContent = `Incorrect ‚Äî that was out of bounds (it was ${safeLabel}).`;
    } else {
      const safeLabel = trial.truePc ? pcLabel(trial.truePc) : '(unknown)';
      box.textContent = `Incorrect ‚Äî it was ${safeLabel}`;
    }
  }
  
  overlay.style.display = 'flex';
  requestAnimationFrame(() => overlay.classList.add('show'));
  setTimeout(() => {
    overlay.classList.remove('show');
    overlay.style.display = 'none';
  }, 1000);
}

// Helper to show toast messages
function showToast(message) {
  // Reuse existing feedback system for toast
  const box=byId('feedbackBox'); const overlay=byId('feedbackOverlay');
  if(!box||!overlay) return;
  box.style.background= 'var(--bad)';
  box.textContent = message;
  overlay.style.display='flex'; requestAnimationFrame(()=>overlay.classList.add('show'));
  setTimeout(()=>{ overlay.classList.remove('show'); overlay.style.display='none'; }, 1000);
}

// Handle trial statistics and progression
function recordTrialStats(trial) {
  const correct = trial.correct;
  
  // Update level counters
  state.levelTrials++;
  if(correct) state.levelCorrect++;
  state.trainingBlockTrials = (state.trainingBlockTrials || 0) + 1;
  
  const block = blockFromIndex(state.levelIndex);
  if(block >= 21){ 
    if(correct){ 
      state.testFailStreak=0; 
    } else { 
      state.testFailStreak = (state.testFailStreak || 0) + 1; 
    }
  }
  
  // Update jitter statistics for in-bounds trials
  if (!trial.oob && trial.truePc) {
    const trainedPcs = getTrainedPCs();
    if (trainedPcs.includes(trial.truePc)) {
      addJitterStat(trial.truePc, correct, trial.rtMs);
      evaluateJitterLevel(trial.truePc);
    }
  }
  
  // Update confusion tracking for in-bounds errors
  if (!trial.oob && !correct && trial.guessPc && trial.truePc) {
    const trainedPcs = getTrainedPCs();
    if (trainedPcs.includes(trial.truePc) && trainedPcs.includes(trial.guessPc)) {
      updateConfusionMatrix(trial.truePc, trial.guessPc);
      updatePerfStats(trial.truePc, correct, trial.rtMs);
      state.lastInBoundsPc = trial.truePc;
    }
  }
  
  // Update OOB controller
  updateOobController(trial);
  
  // Update OOB streak tracking
  updateOobStreak(trial.oob);
  
  // Update scheduler block system (NEW)
  onTrialGraded();
  
  // Update octave policy for in-bounds trials
  if (!trial.oob) {
    onInBoundsGraded(trial);
  }
  
  // Check for OOB adaptation at block boundaries
  checkOobAdaptation();
  
  save(); 
  updateLevelUI(); 
  try{ drawChart(); }catch(_){}; 
  if(block >= 21 && !correct) maybeSuggestRestart();
}
function handleTimeout(){
  if(!sessionActive || paused || special) return;
  if(!state.trialOpen) return;
  
  finalizeGrade({ pc: null, isOOB: false }); // E) Timeout path with structured input
}

/* Suggestion banner */
function hideSuggestBanner(){ hide('suggestBanner'); }
function showSuggestBanner(){ const set = setFromIndex(state.levelIndex); if(state.suggestShownSet === set) return; byId('suggestBanner').style.display='flex'; }
function restartCurrentSet(){
  const set = setFromIndex(state.levelIndex);
  state.levelIndex = (set-1)*LEVELS_PER_SET + 1;
  state.levelTrials = 0; state.levelCorrect = 0;
  state.shepardDoneFor = -1; state.testFailStreak = 0;
  state.suggestShownSet = null; save();
  updateLevelUI(); paintNotes();
  updateBlockHUD(); // Show current block progress
  hideSuggestBanner();
}
function maybeSuggestRestart(){
  const block = blockFromIndex(state.levelIndex);
  if(block < 21){ state.testFailStreak = 0; hideSuggestBanner(); suggestedRestartFlag=false; save(); return; }
  if(state.testFailStreak >= 10 && !suggestedRestartFlag){ suggestedRestartFlag = true; showSuggestBanner(); }
}

/* NOTE: recordTrial() function removed - replaced by recordTrialStats() and centralized grading */

function feedback(ok, wrongMsgOverride){
  const fb=blockHasFeedback(blockFromIndex(state.levelIndex));
  if(!fb && !special?.withFeedback) return;
  const box=byId('feedbackBox'); const overlay=byId('feedbackOverlay');
  if(!box||!overlay) return;
  box.style.background= ok? 'var(--good)':'var(--bad)';
  if(ok) box.textContent = 'Correct!';
  else   box.textContent = wrongMsgOverride || 'Incorrect';
  overlay.style.display='flex'; requestAnimationFrame(()=>overlay.classList.add('show'));
  setTimeout(()=>{ overlay.classList.remove('show'); overlay.style.display='none'; }, 500);
}

function advanceCheck(){
  if(state.levelTrials<20) return;
  const acc=state.levelCorrect/state.levelTrials, need=thresholdForIndex(state.levelIndex);
  const passed = acc>=need;
  const block = blockFromIndex(state.levelIndex);
  const key = String(state.levelIndex);
  
  // Training Block completed - handle adaptive OOB
  // Call AFTER logger as specified in requirements
  logTrainingBlockOobData(block, 'boundary');
  const adaptBoundary = adaptOobTargetAtTrainingBlockBoundary(block);
  updateOobHealthCheckTrainingBlock();
  updateOobStatusPill();
  
  // Log confusion series data
  logConfusionSeriesData(block);
  
  // Log timbre block end for variety mode
  logTimbreBlockEnd();
  
  // Process per-timbre rescues at block boundary
  processTimbreRescuesAtBlockBoundary(block);
  
  // Reset training block counters
  state.trainingBlockTrials = 0;
  state.currentBlockOctaveCount = {3: 0, 4: 0, 5: 0};
  
  // Reset OOB plan for next block
  state.oob.currentTrialInBlock = 0;
  state.oob.plan = [];
  state.oob.planOctaveMix = [];
  
  // Show feedback for test blocks (21-24) at completion
  if(block >= 21) {
    const percentage = Math.round(acc * 100);
    if(passed) {
      alert(`Well done, you passed with ${percentage}%!`);
    } else {
      // Suppress strict modal during failure dialogs
      suppressStrictOnce = true;
      alert(`Sorry you didn't make it with ${percentage}%.`);
      
      // Check for 10-fail streak and show struggle suggestion
      if(state.testFailStreak >= 10) {
        const confirmed = confirm(`Struggling? Perhaps go back to the start of set?\n\nClick OK to restart the set, or Cancel to dismiss and try again.`);
        if(confirmed) {
          restartCurrentSet();
          return;
        }
      }
      // Keep suppression active after dialogs
      suppressStrictOnce = true;
    }
  }
  
  if(!passed){
    state.levelFailCounts[key] = (state.levelFailCounts[key]||0) + 1;
    if(state.levelFailCounts[key] >= 10){
      if(confirm('You‚Äôve attempted this level 10+ times without passing. Drop to a lower level?')){
        if(state.levelIndex>1) state.levelIndex--;
        state.levelTrials=0; state.levelCorrect=0; state.shepardDoneFor=-1;
        save(); updateLevelUI(); paintNotes();
        alert('Dropped one level. Keep going!');
        return;
      }
    }
  }else{
    state.levelFailCounts[key]=0;
  }
  state.levelTrials=0; state.levelCorrect=0;
  if(passed && state.levelIndex<LEVELS_TOTAL){
    const oldSet = setFromIndex(state.levelIndex);
    state.levelIndex++;
    state.trainingBlockIndex++;  // Advance training block
    const newSet = setFromIndex(state.levelIndex);
    save(); updateLevelUI(); paintNotes();
    
    // Check if we're moving to a new set (new pitch introduced)
    if(newSet > oldSet && newSet <= UNLOCK_ORDER.length){
      showNewPitchModal(newSet);
    }
    // Note: Removed startFlappyReward() - Flappy only opens from TimeBlock breaks
  } else save();
}

/* ------------------ SESSION ------------------ */
function initiateTrainingSession(){
  stopAllTimers();
  sealDanglingSession();
  
  // Check daily lockout first (new system)
  if(isDailyLocked()){
    alert('Training completed for today. Come back tomorrow!\nYou can still play Flappy from the menu.');
    showScreen('menuScreen'); 
    return;
  }
  
  // Legacy lockout check (fallback)
  if(isLocked()){
    const left = state.lockoutUntil - Date.now();
    alert(`Training is locked for ${fmtHMM(left)}.\nYou can still play Flappy from the menu, or Reset lockout/timer.`);
    showScreen('menuScreen'); return;
  }
  
  // Check if cold recall has been done today
  const todayKey = getTodayKey();
  const todayRecall = state.recall[todayKey];
  
  if (!todayRecall || !todayRecall.cold || todayRecall.cold.length === 0) {
    // Show cold recall modal before starting training
    showColdRecall();
    return;
  }
  
  // Cold recall already done, proceed with training
  startTrainingAfterColdRecall();
}

function startTrainingAfterColdRecall(){
  showScreen('trainerScreen');
  if(!state.startDate) state.startDate=Date.now();
  ensureWeekRoll();
  sessionActive=true; paused=false;
  (state.sessions||[]).push({start:Date.now(),end:null,pauses:[],completed:false}); 
  
  // Start the new daily session system
  if (!startDailySession()) {
    // Failed to start daily session (probably already completed)
    showScreen('menuScreen');
    return;
  }
  
  // Keep legacy timeblock system for compatibility (but daily system takes precedence)
  if (!state.timeblock.breakActive) {
    if (state.timeblock.running) {
      state.timeblock.startedAt = performance.now();
    }
    startTimeBlockTimer();
  }
  
  state.lastSeen = Date.now(); save();
  updateCapsUI(); updateLevelUI(); paintNotes();
  updateBlockHUD(); // Show current block progress instead of "Press Play"
  stopAllTimers();
  tickId=setInterval(()=>{
    ensureWeekRoll();
    if(sessionActive && !paused && !shepRunning){ 
      state.thisWeekMs = (state.thisWeekMs||0) + 1000; 
      save(); 
    }
    
    if(sessionActive && !paused){
      // Update total time display  
      const left = Math.max(0, SESS_DAILY_MS - msUsedQuota());
      text('timerInfo', `Left: ${fmtMMSS(left)}`);
      
      if(left<=0){
        endSessionWithWarmRecall();
      }
    }
    
    // Handle TimeBlock break countdown
    if (state.timeblock.breakActive && state.timeblock.breakEndsAt) {
      updateTimeBlockBreakUI();
      
      const now = Date.now();
      if (now >= state.timeblock.breakEndsAt) {
        // Check if Flappy round has ended
        if (!running) {
          // No flappy game running, end break automatically
          endTimeBlockBreakAndCloseModal();
        }
        // If flappy is still running, let user continue but show message
      }
    }
    
    updateCapsUI(); 
    try { drawChart(); } catch(_) {}
  },1000);
}

// Backwards compatibility wrapper
function startSession(){
  initiateTrainingSession();
}

function endSessionWithWarmRecall(){
  if(!sessionActive) return;
  
  // Complete day without automatic warm recall
  // User must manually press warm recall button if desired
  completeDayWithoutLockout();
  showScreen('menuScreen');
}
function endSession(auto){
  if(!sessionActive) return;
  sessionActive=false;
  stopAllTimers();
  const rec=state.sessions[state.sessions.length-1]; if(rec && !rec.end) rec.end=Date.now();
  save(); updateCapsUI(); try{ drawChart(); }catch(_){};
  if(auto){
    const left = state.lockoutUntil ? fmtHMM(state.lockoutUntil - Date.now()) : 'some time';
    alert(`Cap reached. Locked for ${left}.`);
  }
}
function pauseStart(reason){
  const rec=state.sessions[state.sessions.length-1]; if(!rec) return;
  rec.pauses=rec.pauses||[]; const last=rec.pauses[rec.pauses.length-1];
  if(!(last && !last.end)) rec.pauses.push({start:Date.now(), end:null, reason});
  paused=true;
  
  // Pause daily session timer (new system)
  // Don't pause during breaks as the break timer should continue
  if (reason !== 'timeblock-break' && !state.session.inBreak) {
    // The daily session timer continues running but this allows other systems to pause
    // The daily session manages its own pause state via inBreak flag
  }
  
  // Pause TimeBlock timer when training pauses (legacy system)
  if (reason !== 'timeblock-break') {
    pauseTimeBlockTimer();
  }
  
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
}

function pauseEnd(){
  const rec=state.sessions[state.sessions.length-1]; if(!rec||!rec.pauses||!rec.pauses.length) return;
  const last=rec.pauses[rec.pauses.length-1]; if(last && !last.end) last.end=Date.now();
  paused=false;
  
  // Resume daily session - handled by updateDailySession timer
  
  // Resume TimeBlock timer when training resumes (legacy system)
  if (!state.timeblock.breakActive) {
    startTimeBlockTimer();
  }
}
function pauseResume(){
  if(!sessionActive) return;
  if(paused){ pauseEnd(); safe('btnPause', el=> el.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else if(currentNote){ nextTrial(false); } }
  else { safe('btnPause', el=> el.textContent='‚ñ∂ Resume'); pauseStart('user'); }
}

/* ------------------ QUOTA ------------------ */
function quotaStart(){ if(state.capResetAt && Date.now() >= state.capResetAt) return state.capResetAt; const d = new Date(); d.setHours(0,0,0,0); return d.getTime(); }
function msUsedQuota(){ const start = quotaStart(); return (state.sessions || []).filter(s => s.start >= start).reduce((a, s) => a + activeDuration(s), 0); }

/* ------------------ SCHEDULER WEIGHT SYSTEM ------------------ */

// 1) Trained set detection (single source of truth)
function getTrainedPCs() {
  // Preferred explicit state
  if (Array.isArray(state?.training?.activeSet) && state.training.activeSet.length) {
    return [...new Set(state.training.activeSet)];
  }
  
  // Fallback: enabled note buttons with data-pc
  const els = Array.from(document.querySelectorAll('.note-btn:not([aria-disabled="true"])'));
  if (els.length > 0) {
    const pcs = els.map(el => el.dataset.pc || el.textContent?.trim()).filter(Boolean);
    const normalizedPcs = pcs.map(pc => normalizePc(pc)).filter(Boolean);
    if (normalizedPcs.length > 0) {
      return [...new Set(normalizedPcs)];
    }
  }
  
  // Final fallback: use trainedSet based on current level
  const currentSet = setFromIndex(state.levelIndex);
  return trainedSet(currentSet);
}

// 2) Begin-of-block freeze (call at the START of each 20-trial block)
function freezeBlockWeights() {
  const trained = getTrainedPCs();
  if (trained.length === 0) {
    console.warn('No trained PCs found, skipping weight freeze');
    return;
  }
  
  // Get in-bounds trials (truePc in trained set)
  const IN = state.trials.filter(t => 
    !t.oob && t.truePc && trained.includes(t.truePc)
  );
  
  // Performance window (last-40 in-bounds per trained pc)
  const perf = {};
  for (const pc of trained) {
    const pcTrials = IN.filter(t => t.truePc === pc).slice(-40);
    perf[pc] = {
      last40N: pcTrials.length,
      last40Acc: pcTrials.length > 0 ? pcTrials.filter(t => t.correct).length / pcTrials.length : 0
    };
  }
  
  // Confusion window (last-200 in-bounds among trained)
  const last200 = IN.slice(-200);
  let topPair = null;
  let maxOffDiagCount = 0;
  let totalOffDiagCount = 0;
  
  // Count confusions in last-200 trials (only wrong guesses between trained PCs)
  const confCounts = {};
  for (const truePc of trained) {
    confCounts[truePc] = {};
    for (const wrongPc of trained) {
      confCounts[truePc][wrongPc] = 0;
    }
  }
  
  for (const t of last200) {
    if (trained.includes(t.truePc) && trained.includes(t.guessPc) && !t.correct) {
      if (!confCounts[t.truePc]) confCounts[t.truePc] = {};
      confCounts[t.truePc][t.guessPc] = (confCounts[t.truePc][t.guessPc] || 0) + 1;
      totalOffDiagCount++;
      
      // Track top confusion pair (true != wrong)
      if (t.truePc !== t.guessPc) {
        const count = confCounts[t.truePc][t.guessPc];
        if (count > maxOffDiagCount) {
          maxOffDiagCount = count;
          topPair = { true: t.truePc, wrong: t.guessPc };
        }
      }
    }
  }
  
  // Only apply confusion boost if total off-diagonal counts >= 10
  if (totalOffDiagCount < 10) {
    topPair = null;
  }
  
  // Raw weights (per trained pc)
  const weights = {};
  for (const pc of trained) {
    let w = 1.0;
    
    // Weakness boost: if last40N >= 8 and last40Acc < 0.80
    if (perf[pc].last40N >= 8 && perf[pc].last40Acc < 0.80) {
      w += 0.5;
    }
    
    // Confusion boost: if this pc is the 'true' part of top confusion pair
    if (topPair && topPair.true === pc) {
      w += 0.5;
    }
    
    // Clamp minimum weight
    w = Math.max(w, 0.5);
    weights[pc] = w;
  }
  
  // Normalize weights across trained set only
  const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
  const normalizedWeights = {};
  for (const pc of trained) {
    normalizedWeights[pc] = weights[pc] / totalWeight;
  }
  
  // Store frozen weights
  state.conf.blockWeights = normalizedWeights;
  
  // Log for visibility
  window.qa = window.qa || {};
  qa.confSeries = qa.confSeries || [];
  qa.confSeries.push({
    blockIndex: state.counters?.blockIndex ?? 0,
    trained: [...trained],
    weights: { ...normalizedWeights },
    topConfusion: topPair ? { ...topPair } : null
  });
  
  console.log('Block weights frozen:', {
    blockIndex: state.counters?.blockIndex ?? 0,
    trained,
    weights: normalizedWeights,
    topConfusion: topPair,
    perfStats: perf
  });
}

// 3) Anti-streak sampling with weights
function choosePcWithAntiStreak(weights) {
  state.conf = state.conf || {};
  
  let pc = weightedSample(weights);
  
  // Anti-streak logic: if same as previous AND run length >= 2, try to avoid
  if (pc === state.conf.prevPc && (state.conf.runLen || 0) >= 2) {
    pc = weightedSampleExcluding(weights, state.conf.prevPc) || pc;
  }
  
  // Update run length tracking
  if (pc === state.conf.prevPc) {
    state.conf.runLen = (state.conf.runLen || 0) + 1;
  } else {
    state.conf.prevPc = pc;
    state.conf.runLen = 1;
  }
  
  return pc;
}

// Helper: weighted random sampling
function weightedSample(weights) {
  const pcs = Object.keys(weights);
  if (pcs.length === 0) return null;
  if (pcs.length === 1) return pcs[0];
  
  const rand = Math.random();
  let cumulative = 0;
  
  for (const pc of pcs) {
    cumulative += weights[pc];
    if (rand <= cumulative) {
      return pc;
    }
  }
  
  // Fallback to last PC if rounding errors
  return pcs[pcs.length - 1];
}

// Helper: weighted sampling excluding a specific PC
function weightedSampleExcluding(weights, excludePc) {
  const availableWeights = {};
  let totalWeight = 0;
  
  for (const [pc, weight] of Object.entries(weights)) {
    if (pc !== excludePc) {
      availableWeights[pc] = weight;
      totalWeight += weight;
    }
  }
  
  if (totalWeight === 0) return null;
  
  // Renormalize available weights
  const normalizedWeights = {};
  for (const [pc, weight] of Object.entries(availableWeights)) {
    normalizedWeights[pc] = weight / totalWeight;
  }
  
  return weightedSample(normalizedWeights);
}

// 4) Block progression logic
function onTrialGraded() {
  // Initialize counters if needed
  state.counters = state.counters || { trialInBlock: 0, blockIndex: 0 };
  
  // If trialInBlock is 0, this means we're at the start of a new block
  if (state.counters.trialInBlock === 0) {
    freezeBlockWeights();
  }
  
  // Increment trial counter
  state.counters.trialInBlock++;
  
  // If we've completed 20 trials, reset counter and increment block
  if (state.counters.trialInBlock >= 20) {
    // Log block completion for QA tracking
    logTimbreBlockData();
    
    state.counters.trialInBlock = 0;
    state.counters.blockIndex++;
  }
  
  save();
  
  // Update the block HUD display
  updateBlockHUD();
}

// Update Block HUD display
function updateBlockHUD() {
  state.counters = state.counters || { trialInBlock: 0, blockIndex: 0 };
  const current = state.counters.trialInBlock;
  const hudText = `${current}/20`;
  
  const hudEl = byId('blockHUD');
  if (hudEl) {
    hudEl.textContent = hudText;
    
    // Gray out during breaks
    if (state.inBreak || paused) {
      hudEl.style.opacity = '0.5';
    } else {
      hudEl.style.opacity = '1.0';
    }
  }
}

// Log timbre block data for QA tracking
function logTimbreBlockData() {
  window.qa = window.qa || {};
  qa.timbreSeries = qa.timbreSeries || [];
  
  // Count timbre usage in recent trials
  const recentTrials = (state.trials || []).slice(-20); // Last 20 trials
  const chosenCount = recentTrials.filter(t => t.timbreUsed === state.timbre?.chosen).length;
  const altCount = recentTrials.length - chosenCount;
  
  const altOfDay = state.timbre?.altPool?.length > 0 ? 
    state.timbre.altPool[state.timbre.rotationIndex % state.timbre.altPool.length] : 
    null;
  
  qa.timbreSeries.push({
    blockIndex: state.counters?.blockIndex || 0,
    mode: state.timbre?.mode || 'single',
    chosen: state.timbre?.chosen || 'piano',
    altOfDay: altOfDay,
    proportions: { 
      chosen: state.timbre?.currentProportions?.chosen || 1.0, 
      alt: state.timbre?.currentProportions?.alt || 0.0 
    },
    counts: { 
      chosenTrials: chosenCount, 
      altTrials: altCount 
    }
  });
}

// 5) Get current pitch class for trial using scheduler
function getScheduledPc() {
  const trained = getTrainedPCs();
  
  // Edge cases
  if (trained.length === 0) {
    console.warn('No trained PCs available for scheduling');
    return null;
  }
  
  if (trained.length === 1) {
    // Single PC case - anti-streak is moot
    state.conf.blockWeights = { [trained[0]]: 1 };
    return trained[0];
  }
  
  // Use frozen weights if available, otherwise create uniform weights
  let weights = state.conf.blockWeights || {};
  
  // Verify weights match current trained set
  const weightsKeys = Object.keys(weights);
  const weightsMatch = weightsKeys.length === trained.length && 
                      weightsKeys.every(pc => trained.includes(pc));
  
  if (!weightsMatch) {
    console.warn('Block weights do not match trained set, using uniform weights');
    weights = {};
    for (const pc of trained) {
      weights[pc] = 1 / trained.length;
    }
    state.conf.blockWeights = weights;
  }
  
  return choosePcWithAntiStreak(weights);
}

/* ------------------ END SCHEDULER WEIGHT SYSTEM ------------------ */

// Initialize jitter level for a pitch class if not exists
function initJitterForPc(pc) {
  if (!state.jitter.levelByPc[pc]) {
    state.jitter.levelByPc[pc] = 0; // Start at JL0
  }
  if (!state.jitter.statsByPc[pc]) {
    state.jitter.statsByPc[pc] = {
      last40: [],
      acc: 0,
      medianCents: 0,
      sdCents: 0
    };
  }
}

// Get jitter level for a pitch class
function getJitterLevel(pc) {
  initJitterForPc(pc);
  return state.jitter.levelByPc[pc];
}

// Add a trial result to the per-PC statistics  
function addJitterStat(pc, correct, rtMs) {
  initJitterForPc(pc);
  const stats = state.jitter.statsByPc[pc];
  
  // Add to last40 array
  stats.last40.push({ correct, rtMs, time: Date.now() });
  
  // Keep only last 40 in-bounds trials
  if (stats.last40.length > 40) {
    stats.last40 = stats.last40.slice(-40);
  }
  
  // Recalculate statistics
  updateJitterStats(pc);
}

// Update calculated statistics for a pitch class
function updateJitterStats(pc) {
  const stats = state.jitter.statsByPc[pc];
  if (!stats || stats.last40.length === 0) return;
  
  // Calculate accuracy
  const correct = stats.last40.filter(t => t.correct).length;
  stats.acc = correct / stats.last40.length;
  
  // Use simple error proxy as specified: 0 for correct, 100 for incorrect
  const errors = stats.last40.map(t => t.correct ? 0 : 100);
  
  // Calculate median
  const sorted = [...errors].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  stats.medianCents = sorted.length % 2 === 0 ? 
    (sorted[mid - 1] + sorted[mid]) / 2 : 
    sorted[mid];
    
  // Calculate standard deviation
  const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
  const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
  stats.sdCents = Math.sqrt(variance);
}

// Evaluate promotion/demotion for a pitch class
function evaluateJitterLevel(pc) {
  const stats = state.jitter.statsByPc[pc];
  if (!stats || stats.last40.length < 20) return; // Need at least 20 trials
  
  const currentLevel = getJitterLevel(pc);
  const acc = stats.acc;
  
  let newLevel = currentLevel;
  
  // Demote (rescue) if accuracy < 0.75
  if (acc < 0.75) {
    newLevel = Math.max(0, currentLevel - 1);
  }
  // Promotion conditions (require at least 20 in last-40)
  else if (currentLevel === 0 && acc >= 0.75) {
    newLevel = 1;
  }
  else if (currentLevel === 1 && acc >= 0.80) {
    newLevel = 2;
  }
  else if (currentLevel === 2 && acc >= 0.90) {
    newLevel = 3;
  }
  
  // Clamp to valid range [0,3]
  newLevel = Math.max(0, Math.min(3, newLevel));
  
  if (newLevel !== currentLevel) {
    state.jitter.levelByPc[pc] = newLevel;
    console.log(`Jitter level change for ${pcLabel(pc)}: JL${currentLevel} -> JL${newLevel} (acc=${(acc*100).toFixed(1)}%)`);
    save();
  }
}

// Create a function chooseDetuneMode(pc) that returns "anchor" | "probe" | "jitter"
function chooseDetuneMode(pc) {
  const L = state.jitter.levelByPc[pc] || 0;
  const specs = JITTER_LEVELS[L];
  
  const rand = Math.random();
  
  // Use cumulative probability sampling
  if (rand < specs.anchorRate) {
    return 'anchor';
  }
  if (rand < specs.anchorRate + specs.probeRate) {
    return 'probe';  
  }
  return 'jitter';
}

// Export chooseDetuneMode to window for debugging and validation
window.chooseDetuneMode = chooseDetuneMode;

// Select detune mode and value for a trial
function selectDetune(pc, isOOB) {
  // OOB trials always get no detune
  if (isOOB) {
    return {
      cents: 0,
      mode: 'oob',
      jlLevel: null
    };
  }
  
  // Get jitter level and choose mode
  const level = getJitterLevel(pc);
  const mode = chooseDetuneMode(pc);
  const specs = JITTER_LEVELS[level];
  
  // Check if we're in rescue mode for this PC
  const activeRescue = findActiveRescueForPc(pc);
  
  if (mode === 'anchor') {
    return {
      cents: 0,
      mode: 'anchor',
      jlLevel: level
    };
  }
  
  if (mode === 'probe') {
    const sign = Math.random() < 0.5 ? -1 : 1;
    let cents = sign * (25 + Math.random() * 15); // ¬±25..¬±40¬¢
    
    // During rescue: clamp to lower half of range
    if (activeRescue) {
      const absVal = Math.abs(cents);
      const clampedAbs = Math.min(absVal, 25 + (15 * 0.5)); // Clamp to lower half
      cents = sign * clampedAbs;
    }
    
    return {
      cents: cents,
      mode: 'probe',
      jlLevel: level
    };
  }
  
  // Jitter mode
  const sign = Math.random() < 0.5 ? -1 : 1;
  let jitterRange = specs.jitterMax - specs.jitterMin;
  
  // During rescue: use smaller jitter band (clamp to lower half of current JL range)
  if (activeRescue) {
    jitterRange *= 0.5; // Reduce to lower half
  }
  
  const cents = sign * (specs.jitterMin + Math.random() * jitterRange);
  return {
    cents: cents,
    mode: 'jitter',
    jlLevel: level
  };
}

/* ------------------ BLOCK SYSTEM ------------------ */
function getBlockActiveTime() {
  if (!state.blockStartTime) return 0;
  const now = Date.now();
  const rec = state.sessions[state.sessions.length - 1];
  if (!rec) return 0;
  
  // Calculate active time in current block (excluding pauses)
  let totalPauseTime = 0;
  if (rec.pauses) {
    rec.pauses.forEach(p => {
      const pStart = Math.max(p.start, state.blockStartTime);
      const pEnd = p.end ? Math.min(p.end, now) : now;
      if (pStart < pEnd) totalPauseTime += pEnd - pStart;
    });
  }
  
  return Math.max(0, now - state.blockStartTime - totalPauseTime);
}

function startNewBlock() {
  state.blockStartTime = Date.now();
  state.inBreak = false;
  state.breakStartTime = null;
  save();
}

function checkBlockCompletion() {
  // D) Disabled legacy block system - Flappy modal is opened ONLY from beginTimeBlockBreak()
  // This legacy block system is replaced by the 6-minute TimeBlock system
  return;
}

/* D) Removed legacy block system functions - only TimeBlock system should trigger Flappy */

/* D) Removed updateBreakUI - legacy function, now using updateTimeBlockBreakUI */

/* ------------------ PROGRESS / CHARTS ------------------ */
function eightWeekBins(pitch){
  const t0=todayKey(Date.now());
  const bins=[];
  for(let w=1; w<=8; w++){ const start=t0 - (w-1)*7*86400000; const end=start+7*86400000; bins.push({w,start,end,n:0,ok:0}); }
  const oldest=bins[7].start;
  const trials=(state.trials||[]).filter(tr=>{
    const d=dateAtMidnight(tr.time);
    return d>=oldest && d<bins[0].end && (pitch==='OVERALL'|| tr.pc===pitch);
  });
  for(const tr of trials){
    const d=dateAtMidnight(tr.time);
    const daysAgo=Math.floor((t0 - d)/86400000);
    const w=Math.floor(daysAgo/7)+1;
    const idx=Math.min(8,Math.max(1,w))-1;
    const b=bins[idx]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function thisWeekBins(pitch){
  const ws = weekStartTs();
  const bins=[];
  for(let i=0;i<7;i++){ bins.push({day:i+1,start:ws+i*86400000,end:ws+(i+1)*86400000,n:0,ok:0}); }
  const trials=(state.trials||[]).filter(tr=> tr.time>=ws && tr.time<ws+7*86400000 && (pitch==='OVERALL'|| tr.pc===pitch));
  for(const tr of trials){
    const day = Math.floor((dateAtMidnight(tr.time) - ws)/86400000);
    const b = bins[Math.max(0, Math.min(6, day))]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function drawLine(ctx, pts, color, xscale, yscale){ ctx.beginPath(); let started=false; for(const p of pts){ if(p.y===null) continue; const x=xscale(p.x), y=yscale(p.y); if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y); } if(!started) return; ctx.strokeStyle=color; ctx.lineWidth=2.5; ctx.stroke(); }
function drawDot(ctx, x, y, color, r=6){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); }
function drawChart(){
  const canvas = byId('progressCanvas'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  const P={l:56,r:24,t:16,b:28}; const AX=P.l, AY=P.t, AW=W-P.l-P.r, AH=H-P.t-P.b;
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  ctx.fillStyle=colCard; ctx.fillRect(0,0,W,H);
  const mode=byId('granularitySelect')?.value||'WEEKLY';
  const pitch=byId('pitchSelect')?.value||'OVERALL';
  const colGood=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a';
  const colNeutral=getComputedStyle(document.documentElement).getPropertyValue('--neutral')||'#94a3b8';
  const colMuted=getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#334155';
  const colText=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb';
  const yscale=(v)=> AY + AH - (v/100)*AH;

  /* Y grid + labels */
  ctx.strokeStyle=colMuted; ctx.lineWidth=1; ctx.beginPath();
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy); ctx.moveTo(AX,y); ctx.lineTo(AX+AW,y);} ctx.stroke();
  ctx.fillStyle=colText; ctx.font='12px system-ui,sans-serif';
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy)+4; ctx.fillText(String(gy)+'%', 8, y); }

  if(mode==='WEEKLY'){
    const bins=thisWeekBins(pitch);
    const xscale=(d)=> AX + ((d - 1)/(7 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.fillText(`Day ${d}`, x-18, H-6); }
    const pts=bins.map(b=> b.n===0? {x:b.day,y:null}:{x:b.day,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const b of bins){
      if(b.n>0) drawDot(ctx,xscale(b.day), yscale(Math.round((b.ok/b.n)*1000)/10), colGood, 6);
      else      drawDot(ctx,xscale(b.day), yscale(0), colNeutral, 5);
    }
  } else {
    const weeks=eightWeekBins(pitch);
    const xscale=(w)=> AX + ((w - 1)/(8 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.fillText(`Week ${w}`, x-22, H-6); }
    const pts=weeks.map(b=> b.n===0? {x:b.w,y:null}:{x:b.w,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const p of weeks){
      if(p.n>0) drawDot(ctx,xscale(p.w), yscale(Math.round((p.ok/p.n)*1000)/10), colGood, 5);
      else      drawDot(ctx,xscale(p.w), yscale(0), colNeutral, 4);
    }
  }
  ctx.fillStyle=colText; ctx.font='13px system-ui,sans-serif';
  const label=(pitch==='OVERALL')?'Overall':`Pitch: ${pcLabel(pitch)}`;
  ctx.fillText(label, AX, AY-2);
}

/* Pitch dropdown + view toggle */
function populatePitchSelect(){
  const sel = byId('pitchSelect'); if(!sel) return;
  sel.innerHTML='';
  const mk=(v,t)=>{ const o=document.createElement('option'); o.value=v; o.textContent=t; return o; };
  sel.appendChild(mk('OVERALL','Overall'));
  PC.forEach(pc=> sel.appendChild(mk(pc, pcLabel(pc))));
  sel.onchange = ()=> drawChart();
  const gran = byId('granularitySelect'); if(gran){ gran.onchange = ()=> drawChart(); gran.value='WEEKLY'; }
  
  // Update variety mode UI when menu is shown
  updateVarietyModeUI();
}

/* ------------------ TUTORIAL PAGER ------------------ */
let tIndex = 0;
function setTutorialPage(i){
  tIndex = Math.max(0, Math.min(6, i));
  ['tPage1','tPage2','tPage3','tPage4','tPage5','tPage6','tPage7'].forEach((id, idx)=>{
    const el = byId(id);
    if(el) el.classList.toggle('active', idx===tIndex);
  });
  const back = byId('tBack'); if(back) back.style.visibility = (tIndex===0 ? 'hidden' : 'visible');
  const next = byId('tNext'); if(next) next.textContent = (tIndex===6 ? 'Got it' : 'Next ‚ñ∂');
}
function nextTutorial(){ if(tIndex<6){ setTutorialPage(tIndex+1); return; } hide('welcomeModal'); showScreen('menuScreen'); updateCapsUI(); populatePitchSelect(); drawChart(); }
function prevTutorial(){ setTutorialPage(tIndex-1); }

/* ------------------ WIRING ------------------ */
function wireOnce(){
  sealDanglingSession();
  try{ populatePitchSelect(); drawChart(); }catch(_){}
  
  // E) Preload flappy audio on app init
  preloadFlappyAudio();
  
  // Initialize piano samples for octaves 3,4,5
  initializePianoSamples();
  
  // Start unified ticker for timer updates
  startUnifiedTicker();
  
  // Start
  safe('startBtn', el=> el.onclick=()=>{
    const name=(byId('userNameInput')?.value||'').trim()||'Player';
    state.userName=name; save();
    safe('greeting', g=> g.textContent=`Hello ${state.userName}!`);
    showFlex('welcomeModal'); setTutorialPage(0);
  });
  safe('tNext', el=> el.onclick=()=> nextTutorial());
  safe('tBack', el=> el.onclick=()=> prevTutorial());

  // Menu
  safe('menuStart',   el=> el.onclick=()=> startSession());
  safe('startAssessment', el=> el.onclick=()=> startAssessment());
  safe('viewTracker', el=> el.onclick=()=> showTracker());
  safe('startWarmRecall', el=> el.onclick=()=> startWarmRecallFromMenu());
  safe('playFlappy',  el=> el.onclick=()=> openFlappyFromMenu());
  safe('resetLockout',el=> el.onclick=()=>{
    if(!confirm('Reset lockout/timer now? This starts a fresh 30-minute window immediately.')) return;
    state.lockoutUntil = null; state.capResetAt = Date.now(); state.lastSeen = Date.now();
    // Reset block system
    state.currentBlock = 1;
    state.blockStartTime = null;
    state.inBreak = false;
    state.breakStartTime = null;
    save(); updateCapsUI(); alert('Timer reset. You can start training now.');
  });
  safe('menuReset',   el=> el.onclick=()=> doFactoryReset());

  // Assessment warning modal
  safe('btnProceedAssessment', el=> el.onclick=()=> proceedWithAssessment());
  safe('btnCancelAssessment', el=> el.onclick=()=> cancelAssessment());
  
  // Assessment results modal
  safe('btnRetakeAssessmentModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    proceedWithAssessment();
  });
  safe('btnBackMenuModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    showScreen('menuScreen'); 
    populatePitchSelect(); 
    drawChart();
  });

  // Assessment screen
  safe('btnStartAssessment', el=> el.onclick=()=> beginAssessment());
  safe('btnBackMenuAssessment', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });
  safe('btnRetryAssessment', el=> el.onclick=()=> { hide('assessmentResults'); beginAssessment(); });
  safe('btnBackMenuFromResults', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Tracker screen
  safe('btnBackMenuTracker', el=> el.onclick=()=> { showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Recall system buttons
  safe('btnColdRecallComplete', el=> el.onclick=()=> {
    startRecallReview();
  });
  
  safe('btnWarmRecallComplete', el=> el.onclick=()=> {
    startRecallReview();
  });
  
  safe('btnExportRecall', el=> el.onclick=()=> exportRecallCSV());

  // Set selector
  safe('setSizeSelect', sel=>{
    if(!sel.options.length){
      for(let i=1;i<=SETS;i++){
        const o=document.createElement('option');
        o.value=i; o.textContent=`${i} ${i===1?'pitch':'pitches'}`;
        sel.appendChild(o);
      }
    }
    sel.value = String(setFromIndex(state.levelIndex));
  });
  safe('applySetBtn', el=> el.onclick=()=>{
    const v = parseInt(byId('setSizeSelect')?.value||'1',10)||1;
    state.levelIndex=(v-1)*LEVELS_PER_SET+1; state.levelTrials=0; state.levelCorrect=0; state.shepardDoneFor=-1; state.testFailStreak=0; suggestedRestartFlag=false; state.suggestShownSet=null; save();
    alert(`Scope set to ${v} ${v===1?'pitch':'pitches'} (Block 1/24)`); paintNotes();
  });

  // Audio type selection
  safe('audioTypeSelect', el=> {
    el.value = state.timbre?.chosen || state.audioType || AUDIO_TYPES.PIANO;
  });
  safe('applyAudioBtn', el=> el.onclick=()=>{
    const newType = byId('audioTypeSelect')?.value || AUDIO_TYPES.PIANO;
    state.audioType = newType; // Keep for legacy compatibility
    
    // Update timbre state
    if (state.timbre) {
      state.timbre.chosen = newType;
      updateAltPool(); // Update alternate pool
    }
    
    save();
    const labels = {
      [AUDIO_TYPES.PIANO]: 'Piano (C3-B5)',
      [AUDIO_TYPES.SINE]: 'Sine Wave (C3-B5)', 
      [AUDIO_TYPES.GUITAR]: 'Guitar (C3-B5)'
    };
    alert(`Audio changed to ${labels[newType] || 'Piano'}`);
    updateVarietyModeUI(); // Update variety mode status
  });

  // Variety Mode Toggle
  safe('varietyModeSelect', el=> {
    el.value = state.timbre?.mode || 'single';
  });
  safe('applyVarietyModeBtn', el=> el.onclick=()=>{
    const newMode = byId('varietyModeSelect')?.value || 'single';
    
    // Check if user is enabling variety mode before Week 3
    if (newMode === 'variety') {
      // Initialize timbre system if not done yet
      initTimbreVarietySystem();
      
      // Check if user is new (no start date) or before Week 3
      const shouldShowWarning = !state.startDate || 
        (state.timbre?.recommendFromDate && 
         new Date(getTodayDateString()) < new Date(state.timbre.recommendFromDate));
      
      if (shouldShowWarning) {
        alert('Variety Mode is suggested for Week 3 onwards. You are currently not at Week 3 yet, but you can still enable it if desired.');
        // Ask user if they want to continue
        if (!confirm('Do you want to enable Variety Mode now?')) {
          // User chose not to enable it, revert the selection
          byId('varietyModeSelect').value = 'single';
          return;
        }
      }
    }
    
    if (state.timbre) {
      state.timbre.mode = newMode;
      updateTimbreMode(); // Update proportions
    }
    
    save();
    alert(`Variety Mode ${newMode === 'variety' ? 'enabled' : 'disabled'}`);
    updateVarietyModeUI(); // Update UI
  });

  // Variety Mode Help
  safe('varietyModeHelp', el=> el.onclick=()=>{
    alert('Variety Mode:\n\n' +
          '‚Ä¢ Weeks 1-2: Uses only your chosen timbre (100%)\n' +
          '‚Ä¢ Week 3+: Uses 80% chosen timbre, 20% alternate timbres (rotates daily)\n' +
          '‚Ä¢ Activates automatically 2 weeks after starting training\n' +
          '‚Ä¢ Includes per-timbre rescue when accuracy is low on specific timbres');
  });

  // Dev Force Variety Mode Toggle
  safe('forceVarietySelect', el=> {
    el.value = state.timbre?.forceVariety ? 'on' : 'off';
  });
  safe('applyForceVarietyBtn', el=> el.onclick=()=>{
    const newSetting = byId('forceVarietySelect')?.value === 'on';
    if (state.timbre) {
      state.timbre.forceVariety = newSetting;
      updateTimbreMode(); // Recalculate mode
    }
    save();
    alert(`Force Variety Mode ${newSetting ? 'enabled' : 'disabled'}`);
    updateVarietyModeUI(); // Update UI
  });

  // Theme selection
  safe('themeSelect', el=> {
    el.value = state.theme || 'default';
  });
  safe('applyThemeBtn', el=> el.onclick=()=>{
    const newTheme = byId('themeSelect')?.value || 'default';
    state.theme = newTheme;
    save();
    applyTheme(newTheme);
    const themeName = THEMES[newTheme]?.name || 'Dark Ocean';
    alert(`Theme changed to ${themeName}`);
  });



  // Trainer controls
  safe('btnPlay',        el=> el.onclick=async()=>{ firstRtBonusMs=2000; await resumeCtx(); if(paused){ pauseEnd(); } safe('btnPause', b=> b.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else nextTrial(true); });
  safe('btnPause',       el=> el.onclick=()=> pauseResume());
  safe('btnBackMenu',    el=> el.onclick=()=>{
    if(sessionActive){ if(!paused) pauseStart('user-leave'); openStrictModal(); }
    else { showScreen('menuScreen'); populatePitchSelect(); drawChart(); }
  });
  safe('btnToggleAuto',  el=> el.onclick=()=>{
    autoNext=!autoNext; text('autoInfo',`Auto-next: ${autoNext?'On':'Off'}`);
    const sl=byId('delaySlider'); if(sl){ sl.disabled=!autoNext; sl.classList.toggle('disabled', !autoNext); }
    if(!autoNext && autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
  });
  safe('delaySlider', sl=>{
    sl.disabled=true; sl.classList.add('disabled');
    sl.oninput=(e)=>{ delayMs=parseInt(e.target.value,10)||0; updateLevelUI(); };
  });

  // Specials
  safe('btnTarget',el=> el.onclick=()=> answerSpecial(true));
  safe('btnOther', el=> el.onclick=()=> answerSpecial(false));

  // Strict modal buttons
  safe('btnStrictResume', el=> el.onclick=()=>{ closeStrictModal(); showScreen('trainerScreen'); });
  safe('btnStrictMenu',   el=> el.onclick=()=>{ closeStrictModal(); showScreen('menuScreen'); });

  // New pitch modal buttons
  safe('btnHearNewPitch', el=> el.onclick=async()=>{ 
    const pitch = UNLOCK_ORDER[setFromIndex(state.levelIndex) - 1];
    await playNewPitchDemo(pitch); 
  });
  safe('btnContinueTraining', el=> el.onclick=()=>{ 
    closeNewPitchModal(); 
    // D) Removed startFlappyReward() - Flappy only opens from TimeBlock breaks
  });

  // Initial screen
  if(!state.userName){ showScreen('startScreen'); }
  else { safe('greeting', g=> g.textContent=`Hello ${state.userName}!`); showScreen('menuScreen'); updateCapsUI(); }
}

/* ------------------ FLAPPY ------------------ */
let fCtx, flappyRAF=null, running=false, score=0, pipes=[], bird, pipeTimer=0, lastTs=null;

/* Flappy now: start with bigger gap, shrink over first 5 pipes, then keep constant.
   Speed still scales with score. */
const FLAPPY = { gravity:900, flap:-380, baseSpeed:140, maxSpeed:260, speed:140, baseGap:140, gap:140, introPipes:5, introExtra:60, spawnEvery:1.20, width:52 };

function openFlappyFromMenu(){ 
  if(isLocked()) {
    openFlappyModal(); 
  } else if (state.inBreak && sessionActive) {
    // Allow reopening flappy during breaks
    openFlappyModal();
  } else {
    alert('Flappy is intended for lockout/rewards.'); 
  }
}
function openFlappyModal(){ 
  byId('flappyModal').style.display='flex'; 
  const c=byId('flappyCanvas'); 
  if(!c) return; 
  fCtx=c.getContext('2d'); 
  resetFlappy(); 
  attachFlappyControls();
  
  // Show sound toggle button and update description during breaks or lockout
  const soundToggle = byId('flappySoundToggle');
  const description = byId('flappyModal').querySelector('p:last-child');
  
  // Always show sound toggle and update it based on current state
  if (soundToggle) {
    soundToggle.style.display = 'inline-block';
    soundToggle.textContent = state.flappyMuted ? 'üîá Sound Off' : 'üîä Sound On';
  }
  
  // E) Setup sound toggle checkbox
  const soundCheckbox = byId('flappySoundCheckbox');
  if (soundCheckbox) {
    soundCheckbox.checked = state.flappyMuted;
    soundCheckbox.onchange = () => {
      state.flappyMuted = soundCheckbox.checked;
      save();
      // Update button text too
      if (soundToggle) {
        soundToggle.textContent = state.flappyMuted ? 'üîá Sound Off' : 'üîä Sound On';
      }
    };
  }
  
  // C) Hide close button and prevent ESC/backdrop clicks during countdown
  const closeBtn = byId('flappyClose');
  if (state.timeblock?.breakActive && state.timeblock?.breakEndsAt) {
    // During break countdown - hide close button and disable modal close
    if (closeBtn) closeBtn.style.display = 'none';
    byId('flappyModal').style.pointerEvents = 'none'; // Disable backdrop clicks
    byId('flappyModal').querySelector('.card').style.pointerEvents = 'auto'; // Re-enable card clicks
  } else {
    // Normal flappy (lockout) - show close button
    if (closeBtn) closeBtn.style.display = 'inline-block';
    byId('flappyModal').style.pointerEvents = 'auto';
  }
  
  // Update description based on context
  if (description) {
    if (state.timeblock?.breakActive || isLocked()) {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap makes a flappy sound.';
    } else {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap plays a random pitch.';
    }
  }
}
/* D) Removed startFlappyReward() - Flappy only opens from TimeBlock breaks */

// A) Decouple game end from modal close - show overlay during TimeBlock breaks
function onFlappyLose() {
  running = false; // Stop the game
  
  // Call maybeCloseBreakModal when a flappy round ends
  maybeCloseBreakModal();
  
  // If we're in a TimeBlock break, show crash overlay instead of closing modal
  if (state.timeblock.breakActive && state.timeblock.breakEndsAt) {
    const now = Date.now();
    const remaining = Math.max(0, state.timeblock.breakEndsAt - now);
    
    if (remaining > 0) {
      // Show crash overlay with remaining time
      showFlappyCrashOverlay(remaining);
      return; // Don't close the modal
    }
  }
  
  // Not in a break or break time is up - close normally
  closeFlappy(true);
}

function showFlappyCrashOverlay(remaining) {
  const flappyModal = byId('flappyModal');
  if (!flappyModal || flappyModal.style.display !== 'flex') return;
  
  // Remove existing crash overlay if any
  const existingOverlay = flappyModal.querySelector('#flappyCrashOverlay');
  if (existingOverlay) existingOverlay.remove();
  
  // Create crash overlay
  const overlay = document.createElement('div');
  overlay.id = 'flappyCrashOverlay';
  overlay.style.cssText = `
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9);
    color: var(--text);
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    z-index: 100;
  `;
  
  const timeText = document.createElement('p');
  timeText.id = 'crashOverlayTime';
  timeText.style.cssText = 'margin: 0 0 16px 0; font-weight: 600; color: var(--accent);';
  
  const buttonsDiv = document.createElement('div');
  buttonsDiv.style.cssText = 'display: flex; gap: 12px; justify-content: center;';
  
  const playAgainBtn = document.createElement('button');
  playAgainBtn.textContent = 'Play again';
  playAgainBtn.style.cssText = 'padding: 8px 16px; border-radius: 8px; border: none; background: var(--good); color: var(--text); cursor: pointer;';
  playAgainBtn.onclick = () => {
    overlay.remove();
    running = true;
    resetFlappy();
    flappyRAF = requestAnimationFrame(step);
  };
  
  const justRestBtn = document.createElement('button');
  justRestBtn.textContent = 'Just rest';
  justRestBtn.style.cssText = 'padding: 8px 16px; border-radius: 8px; border: none; background: var(--muted); color: var(--text); cursor: pointer;';
  justRestBtn.onclick = () => {
    overlay.remove();
  };
  
  // Function to update the time text
  const updateTimeText = () => {
    if (!state.timeblock.breakActive || !state.timeblock.breakEndsAt) {
      overlay.remove();
      return;
    }
    const now = Date.now();
    const remaining = Math.max(0, state.timeblock.breakEndsAt - now);
    if (remaining <= 0) {
      overlay.remove();
      return;
    }
    timeText.textContent = `You crashed! ‚è≥ ${fmtMMSS(remaining)} left`;
  };
  
  // Initial update
  updateTimeText();
  
  // Update every second
  const updateTimer = setInterval(updateTimeText, 1000);
  
  // Clean up timer when overlay is removed
  const originalRemove = overlay.remove;
  overlay.remove = function() {
    clearInterval(updateTimer);
    originalRemove.call(this);
  };
  
  buttonsDiv.appendChild(playAgainBtn);
  buttonsDiv.appendChild(justRestBtn);
  overlay.appendChild(timeText);
  overlay.appendChild(buttonsDiv);
  
  const flappyCard = flappyModal.querySelector('.card');
  if (flappyCard) {
    flappyCard.style.position = 'relative';
    flappyCard.appendChild(overlay);
  }
}

function closeFlappy(){
  running=false; cancelAnimationFrame(flappyRAF); byId('flappyModal').style.display='none'; detachFlappyControls();
  if(score > (state.flappyHighScore||0)){ state.flappyHighScore = score; save(); }
  
  // Remove break message if it exists
  const breakMessage = byId('breakMessage');
  if (breakMessage) breakMessage.remove();
  
  // If we're in a break and closing flappy manually, we should still wait for break time to finish
  if (state.inBreak && sessionActive) {
    // Don't resume training yet - keep paused until break time is up
    safe('btnPause', el=> el.textContent='‚è∏ Pause');
    text('promptPill','Break time remaining - press "Play Flappy" from menu to reopen or wait for break to end');
  } else if(sessionActive){
    safe('btnPause', el=> el.textContent='‚ñ∂ Resume');
    currentNote=null; clearTimeout(rtTimer); rtTimer=null; clearTimeout(autoTimer); autoTimer=null;
    text('promptPill','Flappy over ‚Äî press Play to continue');
  }
}
function resetFlappy(){ const cnv=byId('flappyCanvas'); if(!cnv) return; bird={x:60,y:cnv.height/2,vy:0,wing:0}; pipes=[]; score=0; pipeTimer=0; lastTs=null; FLAPPY.speed=FLAPPY.baseSpeed; FLAPPY.gap=FLAPPY.baseGap + FLAPPY.introExtra; FLAPPY.introPipes=5; text('flappyScore',`Score: 0 ‚Ä¢ Best: ${state.flappyHighScore||0}`); }
function flap(){ 
  bird.vy = FLAPPY.flap; 
  
  // Only play sound if not muted
  if (!state.flappyMuted) {
    // During TimeBlock breaks or lockout, always play flappy sound
    // During regular play (rewards), play random pitches
    if (state.timeblock?.breakActive || isLocked()) {
      playFlappySound();
    } else {
      // Regular flappy bird with musical pitches (only during rewards)
      const pc = rand(PC); 
      const note = `${pc}${rand(currentOctaves())}`; 
      playSample(note);
    }
  }
}
function progressiveDifficulty(){ // only speed scales; gap remains constant after intro
  const target = FLAPPY.baseSpeed + Math.min(Math.floor(score/5)*18, FLAPPY.maxSpeed - FLAPPY.baseSpeed);
  FLAPPY.speed = target;
}
function drawBird(){ const ctx=fCtx; if(!ctx) return; const body=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#fbbf24'; const wingCol=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; const outline=getComputedStyle(document.documentElement).getPropertyValue('--bg')||'#0f172a';
  ctx.save();
  const tilt=Math.max(-0.6,Math.min(0.6,bird.vy/380)); ctx.translate(bird.x,bird.y); ctx.rotate(tilt);
  ctx.fillStyle=body; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb'; ctx.beginPath(); ctx.arc(3,-4,3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=outline; ctx.beginPath(); ctx.arc(4,-4,1.5,0,Math.PI*2); ctx.fill();
  bird.wing+=0.25; const wing=Math.sin(bird.wing)*0.9; ctx.save(); ctx.rotate(wing);
  ctx.fillStyle=wingCol; ctx.beginPath(); ctx.moveTo(-2,2); ctx.quadraticCurveTo(-16,4,-8,12); ctx.quadraticCurveTo(0,10,-2,2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.restore();
  ctx.restore();
}
function drawPipes(){ const ctx=fCtx; if(!ctx) return; const col=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; ctx.fillStyle=col; const cnv=byId('flappyCanvas'); if(!cnv) return; for(const p of pipes){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; ctx.fillRect(p.x,0,FLAPPY.width,topH); ctx.fillRect(p.x,bottomY,FLAPPY.width,cnv.height-bottomY); } }
function spawnPipe(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const h=cnv.height, m=40;

  // intro ramp: linearly reduce gap to baseGap across first 5 pipes
  if(FLAPPY.introPipes > 0){
    const k = FLAPPY.introPipes; // 5..1
    const extraNow = Math.round(FLAPPY.introExtra * (k/5));
    FLAPPY.gap = FLAPPY.baseGap + extraNow;
    FLAPPY.introPipes--;
    if(FLAPPY.introPipes === 0) FLAPPY.gap = FLAPPY.baseGap; // lock it
  }

  const gapY=Math.max(m,Math.min(h-m-FLAPPY.gap,Math.random()*(h-FLAPPY.gap-2*m)))+FLAPPY.gap/2;
  pipes.push({x: cnv.width, gapY: gapY, passed:false});
}
function step(ts){
  if(!running) return;
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  if(lastTs===null) lastTs = ts;
  let dt = (ts - lastTs) / 1000; if(dt > 0.033) dt = 0.033; lastTs = ts;
  bird.vy += FLAPPY.gravity * dt; bird.y  += bird.vy * dt;
  pipeTimer -= dt; if(pipeTimer <= 0){ pipeTimer += FLAPPY.spawnEvery; spawnPipe(); }
  for(const p of pipes){ p.x -= FLAPPY.speed * dt; }
  for(const p of pipes){ if(!p.passed && p.x + FLAPPY.width < bird.x){ p.passed = true; score++; progressiveDifficulty(); text('flappyScore',`Score: ${score} ‚Ä¢ Best: ${state.flappyHighScore||0}`); } }
  pipes = pipes.filter(p=> p.x + FLAPPY.width > 0);
  fCtx.clearRect(0,0,cnv.width,cnv.height); drawPipes(); drawBird();
  if(bird.y < 0 || bird.y > cnv.height){ return onFlappyLose(); }
  for(const p of pipes){ if(bird.x+10>p.x && bird.x-10<p.x+FLAPPY.width){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; if(bird.y-10<topH || bird.y+10>bottomY){ return onFlappyLose(); } } }
  flappyRAF = requestAnimationFrame(step);
}
let _flHandlers=null;
function attachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const startOrFlap = () => { if(!running){ running=true; resetFlappy(); flappyRAF=requestAnimationFrame(step); } else { flap(); } };
  const onCanvasClick  = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onTouchStart   = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onKey          = (e)=>{ 
    if(e.code==='Space'){ e.preventDefault(); startOrFlap(); } 
    // C) Prevent ESC from closing modal during break countdown
    if(e.code==='Escape' && state.timeblock?.breakActive && state.timeblock?.breakEndsAt) {
      e.preventDefault();
      e.stopPropagation();
    }
  };
  const onClose        = ()=> {
    // C) Only allow manual close if not during break countdown
    if (state.timeblock?.breakActive && state.timeblock?.breakEndsAt) {
      return; // Ignore close attempts during break
    }
    closeFlappy(false);
  };
  cnv.addEventListener('click', onCanvasClick);
  cnv.addEventListener('touchstart', onTouchStart, { passive:false });
  window.addEventListener('keydown', onKey);
  safe('flappyClose', el=> el.onclick=onClose);
  safe('flappySoundToggle', el=> el.onclick=()=> {
    state.flappyMuted = !state.flappyMuted;
    save();
    el.textContent = state.flappyMuted ? 'üîá Sound Off' : 'üîä Sound On';
    // Update checkbox too
    const checkbox = byId('flappySoundCheckbox');
    if (checkbox) checkbox.checked = state.flappyMuted;
  });
  _flHandlers={onCanvasClick,onTouchStart,onKey,onClose};
}
function detachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!_flHandlers||!cnv) return;
  cnv.removeEventListener('click', _flHandlers.onCanvasClick);
  cnv.removeEventListener('touchstart', _flHandlers.onTouchStart);
  window.removeEventListener('keydown', _flHandlers.onKey);
  safe('flappyClose', el=> el.onclick=null);
  safe('flappySoundToggle', el=> el.onclick=null);
}

/* ------------------ STRICT MODAL + NAV GUARDS ------------------ */
let strictModalPending=false;
function openStrictModal(){ if(suppressStrictOnce){ suppressStrictOnce=false; return; } showFlex('strictModal'); setTimeout(()=> byId('btnStrictResume')?.focus(), 0); }
function closeStrictModal(){ hide('strictModal'); strictModalPending=false; }

/* New Pitch Modal */
function showNewPitchModal(setNumber){
  const newPitch = UNLOCK_ORDER[setNumber - 1];
  text('newPitchName', pcLabel(newPitch));
  showFlex('newPitchModal');
  setTimeout(()=> byId('btnHearNewPitch')?.focus(), 0);
}
function closeNewPitchModal(){
  hide('newPitchModal');
}
async function playNewPitchDemo(pitch){
  try{
    await resumeCtx();
    const octaves = currentOctaves();
    
    // Play the pitch slowly across all three octaves
    for(let i = 0; i < octaves.length; i++){
      const note = `${pitch}${octaves[i]}`;
      await playSample(note);
      // Wait 1.2 seconds between notes for slow demonstration  
      await new Promise(resolve => setTimeout(resolve, 1200));
    }
  }catch(e){
    report(e);
  }
}
function reconcileAwayTime(){
  const now = Date.now();
  const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
  if(rec && rec.pauses && rec.pauses.length){
    const openPause = rec.pauses[rec.pauses.length-1];
    if(openPause && !openPause.end){ openPause.end = now; save(); }
  }
  state.lastSeen = now; save();
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden && sessionActive && !paused){ pauseStart('hidden'); strictModalPending = true; }
  if(!document.hidden){ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; }
});
window.addEventListener('blur', ()=>{ if(sessionActive && !paused){ pauseStart('blur'); strictModalPending = true; } });
window.addEventListener('focus', ()=>{ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; });
window.addEventListener('pagehide', ()=>{ try{ if(sessionActive && !paused){ pauseStart('pagehide'); strictModalPending = true; } state.lastSeen = Date.now(); save(); }catch(_){}});

/* --- beforeunload guard --- */
let allowUnloadOnce = false;
window.addEventListener('beforeunload', (e)=>{
  if(allowUnloadOnce) return;
  if(sessionActive && !paused){ e.preventDefault(); e.returnValue=''; }
});

/* ------------------ FACTORY RESET ------------------ */
async function wipeAllStorage(){ try{ localStorage.clear(); }catch(_){}
  try{ sessionStorage.clear(); }catch(_){}
  if('caches' in window){ try{ const keys = await caches.keys(); await Promise.all(keys.map(k=>caches.delete(k))); }catch(_){ } }
  if('indexedDB' in window){
    try{
      if(indexedDB.databases){
        const dbs = await indexedDB.databases();
        await Promise.all((dbs||[]).map(db=> db && db.name ? new Promise(res=>{ const rq = indexedDB.deleteDatabase(db.name); rq.onsuccess=rq.onerror=rq.onblocked=()=>res(); }) : Promise.resolve()));
      }
    }catch(_){}
  }
}
function forceStartScreen(){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  const input = byId('userNameInput');
  byId('startScreen').style.display='block';
  if(input){ input.value=''; input.focus(); }
}
function resetInMemoryStateToDefaults(){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, shepardDoneFor:-1, sessions:[], trials:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null, audioType: AUDIO_TYPES.PIANO, assessmentScores: [], theme: 'default', flappySoundEnabled: true, flappyMuted: false, timeblock: { activeMs: 0, running: false, startedAt: null, breaksCompletedToday: 0, breakActive: false, breakEndsAt: null }, oobController: { targetOobPct: 15, lastAdaptTimeBlock: 0, last60InBounds: [], recentOobTrials: [], healthCheckActive: false, healthCheckEndTimeBlock: 0, globalTimeBlockIndex: 0, oobSeries: [] }, inBoundsLast60: [], trainingBlockIndex: 1, trainingBlockTrials: 0, currentBlockOctaveCount: {3: 0, 4: 0, 5: 0}, oob: { targetPct: 0.15, streak: 0, blockTarget: 0, plan: [], planOctaveMix: [], currentBlockIndex: 0, currentTrialInBlock: 0 }, trialOpen: false, toneStartMs: null };
  save();
}
function doFactoryReset(){
  (async ()=>{
    try{
      if(!confirm('Reset EVERYTHING to factory settings? This erases your progress, timers, and settings.')) return;
      stopAllTimers(); sessionActive=false; paused=false;
      await closeAudio(); await wipeAllStorage(); resetInMemoryStateToDefaults(); forceStartScreen();
      allowUnloadOnce = true; setTimeout(()=>{ try{ location.reload(); }catch(_){ } }, 0);
    }catch(e){ report(e); alert('Reset failed: '+e.message); }
  })();
}

/* ------------------ QA HELPERS ------------------ */
// QA helper functions for testing and debugging

// 1) window.qaSnapshot(tag?:string): returns an object with debugging info
window.qaSnapshot = function(tag) {
  try {
    // Calculate counts from state.trials
    const trials = state.trials || [];
    const totalTrials = trials.length;
    const totalCorrect = trials.filter(t => t.correct).length;
    const totalOOB = trials.filter(t => t.oob).length;
    const totalTimeout = trials.filter(t => t.timeout).length;
    
    // Get last 200 trials (shallow copy)
    const trialsTail = trials.slice(-200);
    
    const snapshot = {
      ts: new Date().toISOString(),
      tag: tag || null,
      set: setFromIndex(state.levelIndex),
      block: blockFromIndex(state.levelIndex),
      dailyMs: SESS_DAILY_MS,
      lockoutMs: LOCKOUT_MS,
      audioType: state.audioType,
      octaves: currentOctaves(),
      trialsTail: trialsTail,
      counts: {
        totalTrials: totalTrials,
        totalCorrect: totalCorrect,
        totalOOB: totalOOB,
        totalTimeout: totalTimeout
      }
    };
    
    // Include oobConstRate if OOB_RATE exists
    if (typeof OOB_RATE !== 'undefined') {
      snapshot.oobConstRate = OOB_RATE;
    }
    
    return snapshot;
  } catch (e) {
    console.error('qaSnapshot error:', e);
    return { error: e.message };
  }
};

// 2) window.qaDownload(obj, name): downloads JSON pretty-printed to "<name>.json"
window.qaDownload = function(obj, name) {
  try {
    const jsonString = JSON.stringify(obj, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `${name || 'qa-data'}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the URL object
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error('qaDownload error:', e);
  }
};

// 3) window.qaSimBlock(n=20, seed=123): synthetic trial simulation
window.qaSimBlock = function(n = 20, seed = 123) {
  try {
    // Simple seeded random number generator for reproducible results
    let seedValue = seed;
    const seededRandom = () => {
      seedValue = (seedValue * 9301 + 49297) % 233280;
      return seedValue / 233280;
    };
    
    const currentSet = setFromIndex(state.levelIndex);
    const currentBlock = blockFromIndex(state.levelIndex);
    const trainedPCs = trainedSet(currentSet);
    const oobPCs = currentOOBs(currentSet);
    const octaves = currentOctaves();
    const oobRate = (typeof OOB_RATE !== 'undefined') ? OOB_RATE : 0.25;
    
    for (let i = 0; i < n; i++) {
      // Determine if this trial is OOB
      const isOOB = seededRandom() < oobRate;
      
      // Choose pitch class
      let pc;
      if (isOOB && oobPCs.length > 0) {
        pc = oobPCs[Math.floor(seededRandom() * oobPCs.length)];
      } else {
        pc = trainedPCs[Math.floor(seededRandom() * trainedPCs.length)];
      }
      
      // Choose octave
      const octave = octaves[Math.floor(seededRandom() * octaves.length)];
      const note = `${pc}${octave}`;
      
      // Synthesize correctness: 80% for in-bounds, 40% for OOB
      const correctnessRate = isOOB ? 0.4 : 0.8;
      const correct = seededRandom() < correctnessRate;
      
      // Generate fake guess (for realism, but not used in correctness calculation)
      let guess;
      if (isOOB) {
        guess = seededRandom() < 0.5 ? 'OOB' : trainedPCs[Math.floor(seededRandom() * trainedPCs.length)];
      } else {
        guess = correct ? pc : trainedPCs[Math.floor(seededRandom() * trainedPCs.length)];
      }
      
      // Create trial object matching the structure used by recordTrial
      const trial = {
        note: note,
        pc: pc,
        guess: guess,
        correct: correct,
        timeout: false,
        oob: isOOB,
        set: currentSet,
        block: currentBlock,
        time: Date.now()
      };
      
      // Push directly to state.trials without calling recordTrial
      state.trials.push(trial);
    }
    
    // Save at the end
    save();
    
    // Return number of trials added
    return n;
  } catch (e) {
    console.error('qaSimBlock error:', e);
    return 0;
  }
};

// 4) window.qaAnalyzeDetune(): analyzes detune mode distribution in recent trials
window.qaAnalyzeDetune = function(last = 200) {
  try {
    const trials = state.trials || [];
    const recentTrials = trials.slice(-last);
    
    const inBounds = recentTrials.filter(t => !t.oob);
    const oobTrials = recentTrials.filter(t => t.oob);
    
    // Count modes for in-bounds trials
    const modeCounts = {
      anchor: 0,
      probe: 0,
      jitter: 0,
      other: 0
    };
    
    inBounds.forEach(t => {
      const mode = t.detuneMode;
      if (mode in modeCounts) {
        modeCounts[mode]++;
      } else {
        modeCounts.other++;
      }
    });
    
    // Calculate percentages
    const totalInBounds = inBounds.length;
    const modePercentages = {};
    Object.keys(modeCounts).forEach(mode => {
      modePercentages[mode] = totalInBounds > 0 ? (modeCounts[mode] / totalInBounds * 100).toFixed(1) : 0;
    });
    
    // Analyze detune cents distribution
    const centsDistribution = {
      zero: 0,
      positive: 0,
      negative: 0
    };
    
    inBounds.forEach(t => {
      const cents = t.detuneCents || 0;
      if (cents === 0) {
        centsDistribution.zero++;
      } else if (cents > 0) {
        centsDistribution.positive++;
      } else {
        centsDistribution.negative++;
      }
    });
    
    const analysis = {
      totalTrials: recentTrials.length,
      inBoundsTrials: totalInBounds,
      oobTrials: oobTrials.length,
      modeCounts: modeCounts,
      modePercentages: modePercentages,
      centsDistribution: centsDistribution,
      sampleTrials: {
        inBounds: inBounds.slice(-10),  // Last 10 in-bounds
        oob: oobTrials.slice(-5)        // Last 5 OOB
      }
    };
    
    // Validate OOB trials have correct detune settings
    const oobIssues = oobTrials.filter(t => 
      t.detuneCents !== 0 || t.detuneMode !== 'oob'
    );
    
    if (oobIssues.length > 0) {
      analysis.oobIssues = oobIssues;
    }
    
    return analysis;
  } catch (e) {
    console.error('qaAnalyzeDetune error:', e);
    return { error: e.message };
  }
};

/* ------------------ JL GUARD SYSTEM ------------------ */
// === JL GUARD: force JL changes only at 20-trial block boundaries, max ¬±1 step ===
(() => {
  window.state ||= {}; state.jl ||= { perPc:{} }; state.counters ||= { trialInBlock:0, blockIndex:0 };
  window.qa ||= {}; qa.jlSeries ||= [];

  function snap() {
    const per = state.jitter?.levelByPc || {};
    const s = {};
    Object.keys(per).forEach(pc => s[pc] = (per[pc]|0));
    return s;
  }

  // keep a shadow of levels at the start of each block + a queue of requested changes
  window.__jlGuard ||= { shadow: null, pending: {}, lastTrialInBlock: -1 };

  function atBoundary() {
    // Detect if we just transitioned to a new block
    const current = (state.counters?.trialInBlock|0);
    const last = window.__jlGuard.lastTrialInBlock;
    
    // Update tracking
    window.__jlGuard.lastTrialInBlock = current;
    
    // We're at boundary if we went from a high number back to 0 (or if it's the first call)
    return (last > 0 && current === 0) || (last === -1 && current === 0);
  }

  function applyQueued() {
    const per = state.jitter?.levelByPc || {};
    const pend = window.__jlGuard.pending || {};
    const bi = state.counters?.blockIndex|0;

    Object.keys(pend).forEach(pc => {
      const from = (per[pc]|0) ?? 0;
      // apply only a single step toward the queued direction
      const dir = Math.sign(pend[pc]); // +1 or -1
      const to = Math.max(0, Math.min(3, from + (dir||0)));
      if (to !== from) {
        per[pc] = to;
        qa.jlSeries.push({ blockIndex: bi, pc, from, to, reason: 'boundary-queued' });
        console.log('[JL]', pc, `JL${from} -> JL${to}`, 'at block', bi);
      }
    });
    // reset queue & resnapshot for the new block
    window.__jlGuard.pending = {};
    window.__jlGuard.shadow = snap();
  }

  function guardJL() {
    const per = state.jitter?.levelByPc || {};
    
    if (atBoundary()) {
      // At boundary: apply any queued changes and reset shadow for new block
      applyQueued();
      return;
    }

    // Ensure we have a shadow (this should be set at boundary, but handle edge cases)
    if (!window.__jlGuard.shadow) {
      window.__jlGuard.shadow = snap();
    }

    // Mid-block: revert any JL changes and queue them for boundary
    const shadow = window.__jlGuard.shadow;
    Object.keys(per).forEach(pc => {
      const cur = (per[pc]|0);
      const base = shadow[pc];
      if (base == null) { 
        // If we don't have a shadow for this PC, record current as the base
        shadow[pc] = cur; 
        return; 
      }
      if (cur !== base) {
        const dir = Math.sign(cur - base); // +1 promotion, -1 demotion
        console.log(`[JL Guard] Mid-block change detected for ${pc}: JL${base} -> JL${cur}, reverting and queueing`);
        // revert now, queue the intent
        per[pc] = base;
        window.__jlGuard.pending[pc] = (window.__jlGuard.pending[pc]||0) + dir;
      }
    });
  }

  // hook finalizeGrade if present; else sample periodically
  const origFinalize = window.finalizeGrade;
  if (typeof origFinalize === 'function') {
    window.finalizeGrade = function(...args){
      const r = origFinalize.apply(this,args);
      try { guardJL(); } catch(e){ console.warn('JL guard error', e); }
      return r;
    };
    console.log('‚úî JL guard hooked into finalizeGrade');
  } else {
    clearInterval(window.__jlGuardTimer);
    window.__jlGuardTimer = setInterval(() => { try { guardJL(); } catch(_){} }, 200);
    console.log('‚úî JL guard running via interval');
  }
})();

/* ------------------ INIT ------------------ */
window.addEventListener('load', wireOnce);
window.addEventListener('resize', ()=>{ try{ drawChart(); }catch(_){ }});
</script>
</body>
</html>
