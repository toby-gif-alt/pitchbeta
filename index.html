<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üéµ Absolute Pitch Trainer</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root { --bg:#0f172a; --card:#1e293b; --muted:#334155; --good:#16a34a; --bad:#dc2626; --text:#e5e7eb; --accent:#fbbf24; --neutral:#94a3b8; --muted2:#2a3a54; }
  *{box-sizing:border-box}
  body{font-family:'Fredoka',sans-serif;background:var(--bg);color:var(--text);margin:0;padding:20px}
  .card{max-width:1060px;margin:auto;background:var(--card);border-radius:20px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.15)}
  h1,h2,h3{margin:0 0 8px}
  button{margin:6px;padding:10px 16px;border-radius:12px;border:none;cursor:pointer;font-size:14px;background:var(--muted);color:var(--text);transition:transform .06s ease, filter .12s ease, background .12s ease, border-color .12s ease}
  button:hover{transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  button:disabled{opacity:.55; cursor:not-allowed; background:var(--muted2); border:1.5px dashed var(--muted)}
  input,select{padding:10px 12px;border-radius:12px;border:1px solid var(--muted);background:var(--card);color:var(--text)}
  select{appearance:none;background-image:linear-gradient(45deg,transparent 50%,var(--text) 50%),linear-gradient(135deg,var(--text) 50%,transparent 50%),linear-gradient(to right,transparent,transparent);
         background-position:calc(100% - 20px) 16px, calc(100% - 14px) 16px, 100% 0; background-size:6px 6px,6px 6px, 2.5em 2.5em; background-repeat:no-repeat}
  label{opacity:.9}
  .screen{display:none}
  .pill{display:inline-flex;align-items:center;background:var(--muted);padding:8px 12px;border-radius:16px;font-size:13px;margin:6px;white-space:nowrap}
  .pill.clickable{cursor:pointer;transition:background 0.2s ease}
  .pill.clickable:hover{background:var(--muted2);transform:translateY(-1px)}

  /* Tooltip system for UI pills */
  .tooltip{position:relative}
  .tooltip-content{position:absolute;bottom:110%;left:50%;transform:translateX(-50%);background:var(--card);border:1px solid var(--muted);color:var(--text);padding:8px 12px;border-radius:8px;font-size:12px;white-space:nowrap;z-index:1000;opacity:0;visibility:hidden;transition:opacity 0.3s,visibility 0.3s;box-shadow:0 4px 12px rgba(0,0,0,0.3);max-width:300px;white-space:normal;line-height:1.4}
  .tooltip:hover .tooltip-content{opacity:1;visibility:visible}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .note-pad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
  .note{min-height:64px;font-size:18px;border-radius:14px}
  .note.inert{background:var(--muted2) !important; border:1.5px dashed var(--muted); cursor:not-allowed}
  .wide{grid-column:1 / -1}
  #barStatus{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  #barControls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  #feedbackOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;pointer-events:none}
  #feedbackBox{min-width:240px;text-align:center;padding:16px 18px;border-radius:14px;font-weight:700;font-size:20px;box-shadow:0 20px 60px rgba(0,0,0,.35);transform:scale(.9);opacity:0;transition:transform .15s,opacity .15s}
  #feedbackOverlay.show #feedbackBox{transform:scale(1.05);opacity:1}

  #bootError{display:none;position:fixed;left:12px;right:12px;bottom:12px;background:var(--bad);color:var(--text);padding:10px 12px;border-radius:10px;box-shadow:0 4px 18px rgba(0,0,0,.35);z-index:9999;font:13px/1.35 system-ui,sans-serif;white-space:pre-wrap}

  /* Flappy */
  #flappyModal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:50}
  #flappyCanvas{background:var(--card);width:320px;height:480px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);cursor:pointer;-webkit-tap-highlight-color:transparent;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;outline:none}

  input[type="range"].disabled{opacity:.4;filter:grayscale(1)}

  /* Suggestion banner */
  #suggestBanner{display:none;margin:8px 0 4px;padding:10px 12px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted);color:var(--text);align-items:center;gap:10px}
  #suggestBanner button{margin:0 4px;padding:8px 12px;border-radius:10px;font-size:13px}
  #btnRestartSet{background:var(--good)}
  #btnDismissSuggest{background:var(--muted)}

  /* Modals */
  #strictModal,#welcomeModal,#newPitchModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,.55);pointer-events:auto}
  #strictBox,#welcomeBox,#newPitchBox{width:min(760px,92vw);background:var(--card);border:1px solid var(--muted);border-radius:16px;padding:18px 20px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
  #strictBox h3,#welcomeBox h2,#newPitchBox h2{margin:0 0 8px}
  #strictBtns,#welcomeBtns,#newPitchBtns{display:flex;gap:10px;justify-content:flex-end;margin-top:12px}
  #btnStrictResume{background:var(--good)}
  #btnStrictMenu{background:var(--muted)}
  #welcomeBtns button{background:var(--muted)}
  #btnHearNewPitch{background:var(--accent);color:var(--bg);font-weight:700}
  #btnContinueTraining{background:var(--good)}
  #tutorialWrap{background:var(--card);border:1px solid var(--muted);border-radius:12px;padding:12px;margin:10px 0}

  /* Progress (charts) */
  #progressCard{margin-top:14px}
  #progressControls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  #progressLegend{display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9}
  .legendDot{width:12px;height:12px;border-radius:50%}

  /* Tutorial pager */
  .tPage{display:none}
  .tPage.active{display:block}
  #tutorialNav{display:flex;gap:8px;justify-content:space-between;margin-top:10px}
  #tBack{visibility:hidden}

  /* Special exercise strip */
  #specialBar{display:none;align-items:center;justify-content:space-between;background:var(--muted2);border:1px solid var(--muted);color:var(--text);padding:8px 12px;border-radius:10px;margin-bottom:10px}

  /* Scope picker CTA styling */
  .scopeWrap{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:12px;background:var(--muted2);border:1px solid var(--muted)}
  .scopeWrap:hover{box-shadow:0 0 0 2px rgba(251,191,36,.25) inset}
  .scopeSelect{background:var(--card);border:1.5px solid var(--muted);border-radius:10px;padding:8px 36px 8px 10px;font-weight:600}
  .scopeSelect:focus{outline:none; box-shadow:0 0 0 2px var(--accent)}
  .scopeBtn{background:var(--accent);color:var(--bg);font-weight:700}
</style>
</head>
<body>
  <!-- Start -->
  <div class="card screen" id="startScreen">
    <h1>Welcome!</h1>
    <p>Enter your name to begin:</p>
    <input id="userNameInput" placeholder="Your name" />
    <button id="startBtn">Start ‚ñ∂</button>
  </div>

  <!-- Welcome / Tutorial -->
  <div id="welcomeModal" aria-modal="true" role="dialog">
    <div id="welcomeBox" class="card">
      <h2>üìò How this program works</h2>
      <div id="tutorialWrap">
        <div class="tPage active" id="tPage1">
          <h3>üéØ Goal</h3>
          <p>Learn to recognize the <strong>12 pitches</strong> by ear (C, C#/Db, D, D#/Eb, E, F, F#/Gb, G, G#/Ab, A, A#/Bb, B). You start with a single pitch and add more.</p>
          <ul>
            <li><strong>Unlock order (study):</strong> alternate semitones around F: <strong>F, E, F#/Gb, Eb, G, D, Ab, Db, A, C, Bb, B</strong>.</li>
            <li>Training uses <strong>sets</strong> (how many pitches you‚Äôre learning) and <strong>blocks</strong> (24 per set).</li>
            <li><strong>RT (reaction time)</strong> = max time to answer; it increases slightly with set size.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage2">
          <h3>‚è± Daily session</h3>
          <ul>
            <li>Train for <strong>30 minutes</strong> (timer runs only while actively training).</li>
            <li><strong>60-second breaks after each 6-minute block</strong> with Flappy.</li>
            <li>Menus and Flappy don't count toward training time.</li>
            <li>Blocks <strong>1‚Äì20</strong> with feedback; <strong>21‚Äì24</strong> are tests (no feedback).</li>
          </ul>
        </div>
        <div class="tPage" id="tPage3">
          <h3>üéπ Octaves (per study)</h3>
          <ul>
            <li>Training tones span <strong>Octaves 3‚Äì5 (C3‚ÄìC5)</strong> with performance-based mixing.</li>
            <li><strong>All audio types:</strong> C3‚ÄìC5 range ‚Ä¢ <strong>Adaptive:</strong> Center/neighbor balance</li>
            <li>This encourages learning the <em>chroma</em> (pitch class), not just pitch height.</li>
            <li>Tone length: <strong>800 ms</strong> with optional jitter for boundary training.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage4">
          <h3>üß™ Special exercises (Block 15)</h3>
          <ul>
            <li>When you‚Äôre learning <strong>‚â• 5 pitches</strong>, Block 15 becomes specials:</li>
            <li><strong>Exercise A</strong>: 12 trials with feedback ‚Äî <em>Target (pitch)</em> vs <em>Other (¬±2 semitones)</em>.</li>
            <li><strong>Exercise B</strong>: 22 trials without feedback ‚Äî same task.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage5">
          <h3>üê§ Flappy breaks</h3>
          <ul>
            <li>Reward mini-game; every flap plays a random pitch.</li>
            <li>Timer stays paused until you press <strong>Play</strong> again.</li>
          </ul>
        </div>
        <div class="tPage" id="tPage6">
          <h3>üìä Assessment Test</h3>
          <ul>
            <li><strong>Purpose:</strong> Measure your absolute pitch ability with 20 random pitches across different audio types.</li>
            <li><strong>When to take:</strong> At the start and end of your 8-week program, or weekly to track progress.</li>
            <li><strong>Features:</strong> No feedback during test, results saved to tracker for progress monitoring.</li>
            <li>View your assessment history and progress in the <strong>Track</strong> section from the main menu.</li>
          </ul>
        </div>
      </div>
      <div id="welcomeBtns">
        <div id="tutorialNav" style="width:100%">
          <button id="tBack">‚óÄ Back</button>
          <div style="flex:1"></div>
          <button id="tNext">Next ‚ñ∂</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Menu -->
  <div class="card screen" id="menuScreen">
    <h1 id="greeting">Absolute Pitch Trainer</h1>
    <div class="row">
      <span class="pill" id="capInfo">Left: 20:00</span>
      <span class="pill" id="weekPill">This week: 0 hrs 0 mins</span>
      <span class="pill" id="lockoutPill" style="display:none">üîí Locked</span>
    </div>
    <div class="row">
      <button id="menuStart">‚ñ∂ Start Training</button>
      <button id="startAssessment">üìä Assessment Test</button>
      <button id="viewTracker">üìä Track</button>
      <button id="playFlappy">üê§ Flappy (lockout only)</button>
      <button id="resetLockout">‚ö° Reset lockout/timer</button>
      <button id="menuReset">‚ü≤ Reset (factory)</button>
      <button id="debugToggle" style="opacity:0.6;font-size:11px;display:none;">Debug</button>
    </div>
    
    <!-- Debug panel -->
    <div id="debugPanel" style="display:none;margin-top:12px;padding:10px;background:var(--muted2);border-radius:8px;font-size:11px;font-family:monospace;">
      <div id="debugContent">Debug info will appear here...</div>
    </div>

    <!-- Scope looks obviously changeable now -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Current scope:</span>
        <select id="setSizeSelect" class="scopeSelect"></select>
        <button id="applySetBtn" class="scopeBtn">Change‚Ä¶</button>
      </div>
    </div>
    
    <!-- Audio Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Audio type:</span>
        <select id="audioTypeSelect" class="scopeSelect">
          <option value="piano">Piano (C3-C5)</option>
          <option value="sine">Sine Wave (C3-C5)</option>
          <option value="guitar">Guitar (C3-C5)</option>
        </select>
        <button id="applyAudioBtn" class="scopeBtn">Change</button>
      </div>
    </div>
    
    <!-- Timbre Variety Mode -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Variety mode:</span>
        <label style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="varietyModeToggle" style="margin: 0;">
          <span id="varietyModeLabel">Will activate after week 3</span>
        </label>
        <button id="varietyInfoBtn" class="scopeBtn" style="padding: 8px 12px;">?</button>
      </div>
    </div>
    
    <!-- Theme Selection -->
    <div class="row" style="margin-top:8px;gap:12px">
      <div class="scopeWrap">
        <span style="opacity:.9">Theme:</span>
        <select id="themeSelect" class="scopeSelect">
          <option value="default">Dark Ocean</option>
          <option value="beach">Beach Sunset</option>
          <option value="jungle">Jungle Canopy</option>
          <option value="sky">Cloud Nine</option>
          <option value="desert">Desert Oasis</option>
          <option value="neon">Neon Nights</option>
          <option value="forest">Mystic Forest</option>
        </select>
        <button id="applyThemeBtn" class="scopeBtn">Change</button>
      </div>
    </div>

    <!-- Progress -->
    <div class="card" id="progressCard">
      <h3>üìà Progress</h3>
      <div id="progressControls">
        <label for="pitchSelect">Pitch:</label>
        <select id="pitchSelect" style="padding-right:28px"></select>
        <label for="granularitySelect">View:</label>
        <select id="granularitySelect" style="padding-right:28px">
          <option value="WEEKLY" selected>Weekly (Day 1 ‚Üí 7)</option>
          <option value="OVERALL">Overall (Week 1 ‚Üí 8)</option>
        </select>
        <div id="progressLegend">
          <span class="legendDot" style="background:var(--good)"></span> <span id="legGood">Correct %</span>
          <span class="legendDot" style="background:var(--bad);margin-left:12px)"></span> <span id="legBad">Incorrect %</span>
          <span class="legendDot" style="background:var(--neutral);margin-left:12px)"></span> <span id="legTrend">No-trial day</span>
        </div>
      </div>
      <canvas id="progressCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
  </div>

  <!-- Assessment Tracker Screen -->
  <div class="card screen" id="trackerScreen">
    <h1>üìä Assessment Tracker</h1>
    <div class="row">
      <span class="pill" id="trackerCount">0 assessments</span>
      <button id="btnBackMenuTracker">‚Ü© Menu</button>
    </div>
    
    <div style="margin:20px 0">
      <div id="trackerLegend" style="display:flex;gap:12px;align-items:center;font-size:13px;opacity:.9;margin-bottom:12px">
        <span class="legendDot" style="background:var(--good)"></span> <span>Exact Correct %</span>
        <span class="legendDot" style="background:var(--accent);margin-left:12px"></span> <span>Within ¬±1 semitone %</span>
      </div>
      <canvas id="trackerCanvas" width="1000" height="300" style="width:100%;height:auto;border-radius:12px;background:var(--card);border:1px solid var(--muted)"></canvas>
    </div>
    
    <div id="trackerDetails" style="margin-top:16px">
      <h3>Assessment History</h3>
      <div id="trackerHistory" style="max-height:200px;overflow-y:auto;border:1px solid var(--muted);border-radius:12px;padding:12px;background:var(--card)">
        <p style="opacity:0.7;text-align:center">No assessments completed yet</p>
      </div>
    </div>
  </div>

  <!-- Trainer -->
  <div class="card screen" id="trainerScreen">
    <div id="specialBar" class="row">
      <span id="specialText">Special Exercise</span>
      <span class="pill" id="specialCount">0 / 0</span>
    </div>

    <div id="suggestBanner" class="row">
      <span>Struggling in the test phase. Restart this pitch set?</span>
      <div style="margin-left:auto"></div>
      <button id="btnRestartSet">Restart set</button>
      <button id="btnDismissSuggest">Dismiss</button>
    </div>

    <div id="barStatus">
      <span class="pill" id="promptPill">Press Play to start</span>
      <span class="pill" id="setInfo">Pitches 1 / 12</span>
      <span class="pill" id="blockInfo">Block 1 / 24</span>
      <span class="pill" id="accInfo">Acc 0% (req 20%)</span>
      <span class="pill" id="autoInfo">Auto-next: Off</span>
      <span class="pill" id="delayInfo">RT limit: 1183ms ‚Ä¢ Delay: 1000ms</span>
      <span class="pill" id="timerInfo">Time left: 30:00</span>
      <span class="pill" id="chunkInfo">Training: 6:00 (1/6)</span>
      <span class="pill" id="jitterInfo" style="display:none;">Jitter: JL1</span>
      <span class="pill" id="octaveInfo" style="display:none;">Mix: 90/10</span>
    </div>
    <div id="barControls">
      <button id="btnPlay">‚ñ∂ Play</button>
      <button id="btnPause">‚è∏ Pause</button>
      <button id="btnToggleAuto">‚èØ Toggle Auto-next</button>
      <input id="delaySlider" type="range" min="0" max="2000" step="50" value="1000" style="width:220px">
      <button id="btnBackMenu">‚Ü© Menu</button>
    </div>

    <!-- Note pad -->
    <div class="note-pad" id="notePad"></div>
    <div class="note-pad" style="margin-top:6px">
      <button class="note wide" id="btnOOB" type="button">Out of Bounds</button>
    </div>

    <!-- Binary pad for specials -->
    <div class="note-pad" id="binaryPad" style="display:none">
      <button class="note" id="btnTarget" type="button">Target</button>
      <button class="note" id="btnOther" type="button">Other (OOB)</button>
    </div>

    <p style="opacity:.75;margin-top:8px">800 ms tone ‚Ä¢ RT limit adapts with set size ‚Ä¢ 24 blocks per set ‚Ä¢ Octaves 3‚Äì5 (C3‚ÄìC5) with performance mixing</p>
  </div>

  <!-- Assessment Screen -->
  <div id="assessmentScreen" class="screen">
    <div class="card">
      <h2>üìä Assessment Test</h2>
      <div class="row">
        <span class="pill" id="assessmentProgress">Trial 0 / 20</span>
        <button id="btnBackMenuAssessment">‚Ü© Menu</button>
      </div>
      
      <div style="text-align:center;margin:20px 0">
        <span id="assessmentPrompt" class="pill">Press Start to begin assessment</span>
        <div style="margin-top:12px">
          <button id="btnStartAssessment">‚ñ∂ Start Assessment</button>
        </div>
      </div>
      
      <!-- Note pad for assessment -->
      <div class="note-pad" id="assessmentPad"></div>
      
      <div id="assessmentResults" style="display:none;text-align:center;margin-top:20px">
        <h3>Assessment Results</h3>
        <div id="assessmentStats" style="margin:16px 0"></div>
        <button id="btnRetryAssessment">Try Again</button>
        <button id="btnBackMenuFromResults">Back to Menu</button>
      </div>
      
      <p style="opacity:.75;margin-top:8px">20 random pitches using random audio types ‚Ä¢ No feedback during test</p>
    </div>
  </div>

  <!-- Feedback -->
  <div id="feedbackOverlay"><div id="feedbackBox"></div></div>



  <!-- Flappy -->
  <div id="flappyModal">
    <div class="card" style="text-align:center">
      <h3>üê§ Flappy Break</h3>
      <p id="breakCountdown" style="display:none;font-size:16px;font-weight:bold;margin:8px 0;color:var(--accent);">Break ends in: 60s</p>
      <canvas id="flappyCanvas" width="320" height="480"></canvas>
      <div style="margin-top:8px">
        <button id="flappySoundToggle" style="display:none;margin-right:8px">üîä Sound On</button>
        <button id="flappyClose">Close</button>
      </div>
      <p id="flappyScore">Score: 0 ‚Ä¢ Best: 0</p>
      <p style="opacity:.8;font-size:12px">Tap/click (or Space) to flap. First tap starts ‚Äî each flap plays a random pitch.</p>
    </div>
  </div>

  <!-- Assessment Warning Modal -->
  <div id="assessmentWarningModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Test</h2>
      <p><strong>Timing Recommendations:</strong></p>
      <ul style="text-align:left;margin:16px 0">
        <li>Take this test at the <strong>start of your 8-week training program</strong></li>
        <li>Take it again at the <strong>end of the 8 weeks</strong> to track improvement</li>
        <li>Optionally take it <strong>weekly</strong> to monitor progress</li>
      </ul>
      <p style="opacity:0.8">This test uses 20 random pitches across different audio types without feedback to assess your current absolute pitch ability.</p>
      <div style="margin-top:20px">
        <button id="btnProceedAssessment" style="background:var(--good);margin:0 8px">Continue to Test</button>
        <button id="btnCancelAssessment" style="background:var(--muted);margin:0 8px">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Assessment Results Modal -->
  <div id="assessmentResultsModal" style="position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:70">
    <div class="card" style="max-width:500px;margin:20px;text-align:center">
      <h2>üìä Assessment Complete!</h2>
      <div id="modalAssessmentStats" style="margin:20px 0;font-size:18px"></div>
      <p style="opacity:0.8;margin:16px 0">Your results have been saved to the tracker.</p>
      <div style="margin-top:20px">
        <button id="btnRetakeAssessmentModal" style="background:var(--good);margin:0 8px">Try Again</button>
        <button id="btnBackMenuModal" style="background:var(--muted);margin:0 8px">Back to Menu</button>
      </div>
    </div>
  </div>

  <!-- Strict session modal -->
  <div id="strictModal" aria-modal="true" role="dialog">
    <div id="strictBox" class="card">
      <h3>‚ö†Ô∏è Don‚Äôt break your session</h3>
      <p>Training is meant to be one strict 30-minute session without interruption. Please finish, then wait until tomorrow.</p>
      <div id="strictBtns">
        <button id="btnStrictResume">Resume Training</button>
        <button id="btnStrictMenu">Go to Menu</button>
      </div>
    </div>
  </div>

  <!-- New Pitch Introduction Modal -->
  <div id="newPitchModal" aria-modal="true" role="dialog">
    <div id="newPitchBox" class="card">
      <h2>üéâ Well Done!</h2>
      <p id="newPitchMessage">Now you are learning: <strong id="newPitchName">F</strong></p>
      <div id="newPitchBtns">
        <button id="btnHearNewPitch">üîä Hear It</button>
        <button id="btnContinueTraining">Continue</button>
      </div>
    </div>
  </div>

  <!-- Pitch Recall Modal -->
  <div id="recallModal" aria-modal="true" role="dialog" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1000;background:rgba(0,0,0,.55);pointer-events:auto">
    <div id="recallBox" style="width:min(600px,92vw);background:var(--card);border:1px solid var(--muted);border-radius:16px;padding:18px 20px;box-shadow:0 20px 60px rgba(0,0,0,.5)">
      <h2 id="recallTitle">üéµ Cold Recall Test</h2>
      <p id="recallInstruction">Before training, please sing/hum the following notes to test your pitch memory:</p>
      
      <div id="recallProgress" style="margin:16px 0">
        <span class="pill" id="recallCounter">Note 1 of 3</span>
        <span class="pill" id="recallCurrentNote">F</span>
      </div>
      
      <div style="text-align:center;margin:20px 0">
        <div id="recallPrompt" style="font-size:18px;margin:12px 0">
          <span>Sing or hum: <strong id="recallTargetNote">F</strong></span>
        </div>
        
        <div style="margin:16px 0">
          <button id="btnStartRecording" style="background:var(--good);font-size:16px;padding:12px 20px">üé§ Start Recording (2s)</button>
          <button id="btnStopRecording" style="background:var(--bad);font-size:16px;padding:12px 20px;display:none">‚èπ Stop Recording</button>
        </div>
        
        <div id="recallFeedback" style="margin:16px 0;min-height:60px;display:none">
          <div id="recallResults" style="font-size:16px;margin:8px 0"></div>
          <div id="recallVerdict" style="font-size:14px;opacity:0.8"></div>
        </div>
      </div>
      
      <div id="recallButtons" style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="btnSkipRecall" style="background:var(--muted)">Skip This Test</button>
        <button id="btnNextRecall" style="background:var(--good);display:none">Next Note</button>
        <button id="btnFinishRecall" style="background:var(--good);display:none">Start Training</button>
      </div>
    </div>
  </div>

  <div id="bootError"></div>

<script>
/* ------------------ CONSTANTS ------------------ */
const AUDIO_PIANO='./audio';
const AUDIO_GUITAR='./Guitar';
const AUDIO_TYPES = {PIANO: 'piano', SINE: 'sine', GUITAR: 'guitar'};

// Theme definitions
const THEMES = {
  default: {
    name: 'Dark Ocean',
    bg: '#0f172a',
    card: '#1e293b', 
    muted: '#334155',
    muted2: '#2a3a54',
    text: '#e5e7eb',
    good: '#16a34a',
    bad: '#dc2626',
    accent: '#fbbf24',
    neutral: '#94a3b8'
  },
  beach: {
    name: 'Beach Sunset',
    bg: '#0f2027',
    card: '#2c5aa0',
    muted: '#44749d',
    muted2: '#5a86ba',
    text: '#fff8dc',
    good: '#ff7f50',
    bad: '#dc143c',
    accent: '#ffa500',
    neutral: '#87ceeb'
  },
  jungle: {
    name: 'Jungle Canopy', 
    bg: '#1a2f1a',
    card: '#2d4a2d',
    muted: '#456545',
    muted2: '#3a5a3a',
    text: '#e8f5e8',
    good: '#32cd32',
    bad: '#cd5c5c',
    accent: '#adff2f',
    neutral: '#9acd32'
  },
  sky: {
    name: 'Cloud Nine',
    bg: '#e6f2ff',
    card: '#ffffff',
    muted: '#b8d4f0',
    muted2: '#a3c9ea',
    text: '#1e3a8a',
    good: '#10b981',
    bad: '#ef4444',
    accent: '#3b82f6',
    neutral: '#6b7280'
  },
  desert: {
    name: 'Desert Oasis',
    bg: '#2d1810',
    card: '#8b4513',
    muted: '#cd853f',
    muted2: '#a0522d',
    text: '#faebd7',
    good: '#daa520',
    bad: '#b22222',
    accent: '#ff8c00',
    neutral: '#d2b48c'
  },
  neon: {
    name: 'Neon Nights',
    bg: '#0a0a0f',
    card: '#1a1a2e',
    muted: '#16213e',
    muted2: '#0f172a',
    text: '#00ffff',
    good: '#00ff00',
    bad: '#ff1493',
    accent: '#ff00ff',
    neutral: '#9370db'
  },
  forest: {
    name: 'Mystic Forest',
    bg: '#0d1421',
    card: '#1e3a3a',
    muted: '#2f5a5a',
    muted2: '#1a3030',
    text: '#f0fff0',
    good: '#228b22',
    bad: '#dc143c',
    accent: '#ffd700',
    neutral: '#8fbc8f'
  }
};
const PC=["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
const PC_LABEL={ C:"C", Db:"C#/Db", D:"D", Eb:"D#/Eb", E:"E", F:"F", Gb:"F#/Gb", G:"G", Ab:"G#/Ab", A:"A", Bb:"A#/Bb", B:"B" };
const UNLOCK_ORDER = ["F","E","Gb","Eb","G","D","Ab","Db","A","C","Bb","B"];

const LEVELS_PER_SET=24, SETS=12, LEVELS_TOTAL=SETS*LEVELS_PER_SET;
const TONE_MS=800;
const THRESH_24=[0.20,0.25,0.30,0.35,0.40,0.45,0.50,0.55,0.60,0.60,0.65,0.70,0.75,0.78,0.80,0.83,0.85,0.88,0.90,0.90,0.90,0.90,0.90,0.90];
function blockHasFeedback(block){ return block<=20; }
function rtWindowForSet(n){const a=1183,b=2028;return Math.round(a+(n-1)*(b-a)/11);}
/* ------------------ ENHANCED OOB SYSTEM ------------------ */
// B) OOB GENERATION = BERNOULLI PER TRIAL + ‚â§2 STREAK (no adaptation here)
function shouldGenerateOOB(set) {
  const oobs = currentOOBs(set);
  if (oobs.length === 0) return false;
  
  const rate = state.oobStats.adaptiveRate ?? 0.18;
  const canOOB = (state.oobStats.streakCount || 0) < (state.oobStats.maxInRow || 2);
  
  // Check if health check is active and reduce rate
  let effectiveRate = rate;
  if (state.oobStats.healthCheckActive) {
    effectiveRate = Math.min(rate, 0.12);
  }
  
  const isOOB = canOOB && Math.random() < effectiveRate;
  state.oobStats.streakCount = isOOB ? (state.oobStats.streakCount + 1) : 0;
  return isOOB;
}

function recordOOBTrial(wasOOB, correct) {
  const stats = state.oobStats;
  
  if (wasOOB) {
    // Add to OOB trials tracking
    stats.oobTrials.push({ correct, timestamp: Date.now() });
    if (stats.oobTrials.length > 20) {
      stats.oobTrials = stats.oobTrials.slice(-20);
    }
    
    // D) OOB HEALTH CHECK (novice case)
    if (stats.oobTrials.length >= 20) {
      const oobAccuracy = stats.oobTrials.filter(t => t.correct).length / stats.oobTrials.length;
      if (oobAccuracy < 0.60) {
        // For the next 2 blocks set reduced rate
        stats.healthCheckActive = true;
        stats.healthCheckBlocks = 2;
      } else if (oobAccuracy >= 0.75 && stats.healthCheckActive) {
        // Restore when OOB ‚â• 0.75
        stats.healthCheckActive = false;
        stats.healthCheckBlocks = 0;
      }
    }
  } else {
    // Add to recent in-bounds trials for adaptation
    stats.recentTrials.push({ correct, timestamp: Date.now() });
    if (stats.recentTrials.length > 60) {
      stats.recentTrials = stats.recentTrials.slice(-60);
    }
  }
  
  save();
}

// Enhanced OOB selection with octave mirroring
function selectOOBNote(set) {
  const oobs = currentOOBs(set);
  if (oobs.length === 0) return null;
  
  // Prefer OOB chroma far from trained notes if health check is active
  if (state.oobStats?.healthCheckActive) {
    const trainedPcs = trainedSet(set);
    const farOOBs = oobs.filter(oob => {
      return !trainedPcs.some(trained => {
        const oobIdx = PC.indexOf(oob);
        const trainedIdx = PC.indexOf(trained);
        const dist = Math.min(
          Math.abs(oobIdx - trainedIdx),
          12 - Math.abs(oobIdx - trainedIdx)
        );
        return dist <= 1; // Avoid ¬±1 semitone
      });
    });
    
    if (farOOBs.length > 0) {
      return rand(farOOBs);
    }
  }
  
  return rand(oobs);
}

const OOB_RATE=0.25; // Keep as fallback, but use adaptive rate
const SESS_DAILY_MS=30*60*1000; // Changed from 20 to 30 minutes
const WEEKLY_TARGET_MS=2*3600*1000;
const BLOCK_LEN_MIN = 6; // Length of each training block in minutes
const BREAK_SEC = 60; // Length of mandatory break in seconds
const BREAK_INTERVAL_MS=BLOCK_LEN_MIN*60*1000; // Break every 6 minutes
const BREAK_DURATION_MS=BREAK_SEC*1000; // 60-second mandatory break
// Lockout until next calendar day (calculated dynamically)
const RECALL_DURATION_MS=2000; // 2-second recording for recall tests
const RECALL_SAMPLE_RATE=22050; // Lower sample rate for recall processing
const LATENCY_CUSHION_MS=100;
const DEV_UI = false; // Controls debug UI visibility

/* ------------------ THEME SYSTEM ------------------ */
function applyTheme(themeName) {
  const theme = THEMES[themeName] || THEMES.default;
  const root = document.documentElement;
  
  root.style.setProperty('--bg', theme.bg);
  root.style.setProperty('--card', theme.card);
  root.style.setProperty('--muted', theme.muted);
  root.style.setProperty('--muted2', theme.muted2);
  root.style.setProperty('--text', theme.text);
  root.style.setProperty('--good', theme.good);
  root.style.setProperty('--bad', theme.bad);
  root.style.setProperty('--accent', theme.accent);
  root.style.setProperty('--neutral', theme.neutral);
}

/* ------------------ SAFE HELPERS + STATE ------------------ */
function byId(id){ return document.getElementById(id); }
function safe(id, fn){ const el=byId(id); if(el) try{ fn(el); }catch(e){report(e);} }
function showFlex(id){ safe(id, el=> el.style.display='flex'); }
function showBlock(id){ safe(id, el=> el.style.display='block'); }
function hide(id){ safe(id, el=> el.style.display='none'); }
function text(id, v){ safe(id, el=> el.textContent=v); }
function textWithTooltip(id, v){ 
  safe(id, el=> {
    const tooltip = el.querySelector('.tooltip-content');
    el.textContent = v;
    if (tooltip) {
      el.appendChild(tooltip);
    }
  }); 
}

// Initialize tooltips for UI pills
function initializeTooltips() {
  const tooltips = {
    setInfo: "Shows how many pitches you're currently learning. You start with 1 pitch (F) and gradually add more up to all 12 pitches.",
    blockInfo: "Each set has 24 blocks. Blocks 1-20 give feedback, blocks 21-24 are tests with no feedback. You need to achieve the required accuracy to advance.",
    accInfo: "Your current accuracy percentage and the required accuracy to advance to the next block. The requirement increases with each block.",
    autoInfo: "When enabled, the next tone plays automatically after the delay period. Toggle with the ‚èØ button or adjust the delay slider.",
    delayInfo: "RT limit: Maximum reaction time to answer before timeout. Delay: Time between trials when auto-next is enabled.",
    timerInfo: "Remaining time in your 30-minute daily training session. Timer only runs during active training, not during menus or breaks.",
    chunkInfo: "Time remaining in current 6-minute training chunk before a mandatory 60-second break. Shows current chunk number out of 5 total chunks.",
    jitterInfo: "Jitter Level shows how much pitch variation is added for training. JL0 = easiest (¬±3-8¬¢), JL1 = early (¬±5-10¬¢), JL2 = mid (¬±5-15¬¢), JL3 = hardest (¬±5-15¬¢ + probes). Example: currently you are on JL0 for F, JL2 for E. Jitter helps you learn where the pitch boundaries are.",
    octaveInfo: "Octave mixing ratio. Shows percentage of center octave vs neighbor octaves. Adaptive mixing based on your performance to encourage learning pitch class rather than absolute pitch height."
  };
  
  Object.keys(tooltips).forEach(id => {
    const element = byId(id);
    if (element) {
      element.classList.add('clickable', 'tooltip');
      let tooltipContent = element.querySelector('.tooltip-content');
      if (!tooltipContent) {
        tooltipContent = document.createElement('div');
        tooltipContent.className = 'tooltip-content';
        tooltipContent.textContent = tooltips[id];
        element.appendChild(tooltipContent);
      }
    }
  });
}
function report(err){ const el=byId('bootError'); if(!el) return; el.style.display='block'; el.textContent = '‚ö†Ô∏è Script error: ' + (err && err.message ? err.message : String(err)); if(err && err.stack){ el.textContent += '\n' + err.stack; } }

let state;
try{
  state = JSON.parse(localStorage.getItem('apTrainer')||'null') || {
    userName:null,
    levelIndex:1,
    levelTrials:0, levelCorrect:0,
    sessions:[], trials:[],
    startDate:null, lockoutUntil:null, capResetAt:null,
    testFailStreak:0, suggestShownSet:null,
    lastSeen:null, flappyHighScore:0,
    thisWeekIdx:0, thisWeekMs:0,
    levelFailCounts:{},
    specialRanForLevel:null,
    audioType: AUDIO_TYPES.PIANO,
    assessmentScores: [],
    theme: 'default',
    flappySoundEnabled: true,
    // New state for enhanced features
    sessionBreakTime: 0, // Time when next break should occur
    lastBreakTime: 0, // Time of last break
    inBreak: false, // Currently in a break
    coldRecallDone: false, // Cold recall completed today
    warmRecallDone: false, // Warm recall completed today
    recallResults: [], // Recall test results
    jitterLevels: {}, // Per-note jitter levels (JL0-JL3)
    confusionMatrix: {}, // 12x12 confusion tracking
    noteStats: {}, // Per-note rolling statistics
    varietyModeEnabled: false, // Timbre variety mode
    minutesToday: 0 // Track minutes completed today in 6-minute blocks
  };
} catch(e){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, sessions:[], trials:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null, audioType: AUDIO_TYPES.PIANO };
}
// Migration for audioType
if (!state.audioType) {
  state.audioType = AUDIO_TYPES.PIANO;
  save();
}
// Migration for assessmentScores
if (!state.assessmentScores) {
  state.assessmentScores = [];
  save();
}
// Migration for theme
if (!state.theme) {
  state.theme = 'default';
  save();
}
// Migration for flappySoundEnabled
if (state.flappySoundEnabled === undefined) {
  state.flappySoundEnabled = true;
  save();
}
// Migration for new enhanced features
if (state.sessionBreakTime === undefined) {
  state.sessionBreakTime = 0;
  state.lastBreakTime = 0;
  state.inBreak = false;
  state.coldRecallDone = false;
  state.warmRecallDone = false;
  state.recallResults = [];
  state.jitterLevels = {};
  state.confusionMatrix = {};
  state.noteStats = {};
  state.varietyModeEnabled = false;
  save();
}

// A) INITIALIZE/REPAIR STATE (prevents .push crash)
state.oobStats ??= {};
state.oobStats.oobTrials ??= [];
state.oobStats.recentTrials ??= [];   // in-bounds only, 1/0
state.oobStats.streakCount ??= 0;     // generation streak
if (typeof state.oobStats.adaptiveRate !== 'number') state.oobStats.adaptiveRate = 0.18; // 18%
state.oobStats.maxInRow = 2;          // streak cap
save();

// Apply theme on load
applyTheme(state.theme);
function save(){ try{ localStorage.setItem('apTrainer', JSON.stringify(state)); }catch(e){ report(e); } }
window.state = state;

/* ------------------ TIME HELPERS ------------------ */
function fmtMMSS(ms){ const s=Math.max(0,Math.floor(ms/1000)); const m=Math.floor(s/60); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
function fmtHMM(ms){ const s=Math.max(0,Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h}h ${String(m).padStart(2,'0')}m`; }
function fmtHrsMins(ms){ let s=Math.max(0, Math.floor(ms/1000)); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); return `${h} hr${h===1?'':'s'} ${m} min${m===1?'':'s'}`; }
function dateAtMidnight(ts){ const d=new Date(ts); d.setHours(0,0,0,0); return d.getTime(); }
function todayKey(ts){ return dateAtMidnight(ts||Date.now()); }
function nextMidnight(ts){ const today = dateAtMidnight(ts||Date.now()); return today + 24*60*60*1000; }
function weekIndex(ts){ const base=ts||Date.now(); if(!state.startDate) return 0; return Math.floor((base-state.startDate)/(7*24*60*60*1000)); }
function currentWeekIdx(){ return weekIndex(Date.now()); }
function weekStartTs(){ if(!state.startDate) return todayKey(Date.now()); const idx=currentWeekIdx(); const base=dateAtMidnight(state.startDate); return base + idx*7*86400000; }

/* ------------------ DURATION ------------------ */
function activeDuration(session){
  const endAt = session.end ?? Date.now();
  let total = Math.max(0, endAt - session.start);
  for(const p of (session.pauses||[])){
    const pe = p.end ?? Date.now();
    const ps = p.start ?? session.start;
    const a = Math.max(session.start, ps);
    const b = Math.min(endAt, pe);
    if(b > a) total -= (b - a);
  }
  return Math.max(0, total);
}

/* ------------------ FLAGS/TIMERS ------------------ */
let sessionActive=false, paused=false;
let rtTimer=null, autoTimer=null, tickId=null;

/* Recall system state */
let recallActive=false, recallType='cold', recallNotes=[], recallIndex=0;
let recallStream=null, recallRecorder=null, recallData=[];
function stopAllTimers(){ if(tickId){ clearInterval(tickId); tickId=null; } if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; } if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }

/* one-shot suppression so strict modal doesn't appear right after specials */
}
let suppressStrictOnce=false;

/* ------------------ SANITY ------------------ */
function sealDanglingSession(){
  try{
    const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
    if(!rec) return;
    if(rec.end == null){
      const now = Date.now();
      if(rec.pauses && rec.pauses.length){
        const last = rec.pauses[rec.pauses.length-1];
        if(last && !last.end) last.end = now;
      }
      rec.end = now; save();
    }
  }catch(e){ report(e); }
}

/* ------------------ UI ------------------ */
function showScreen(id){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  if(id === 'menuScreen'){
    sessionActive=false; paused=false;
    stopAllTimers(); sealDanglingSession(); updateCapsUI();
    try{ populatePitchSelect(); drawChart(); }catch(_){}
  } else if(id !== 'trainerScreen'){
    if(sessionActive && !paused){ pauseStart('nav-away'); }
  }
  const el = byId(id); if(el) el.style.display='block';
}
function ensureWeekRoll(){ const wi=currentWeekIdx(); if(state.thisWeekIdx!==wi){ state.thisWeekIdx=wi; state.thisWeekMs=0; save(); } }
function isLocked(){ return state.lockoutUntil && Date.now() < state.lockoutUntil; }
function updateCapsUI(){
  ensureWeekRoll();
  const left = Math.max(0, SESS_DAILY_MS - msUsedQuota());
  text('capInfo', `Left: ${fmtMMSS(left)}`);
  const usedW = state.thisWeekMs || 0;
  const wp = byId('weekPill');
  if(wp){
    wp.textContent = `This week: ${fmtHrsMins(usedW)}`;
    let color = '#dc2626';
    if(usedW >= 1*3600000 && usedW < 2*3600000) color = 'var(--text)';
    else if(usedW >= 2*3600000 && usedW < 3*3600000) color = '#16a34a';
    else if(usedW >= 3*3600000) color = '#fbbf24';
    wp.style.color = color;
    wp.title = `Target: ${fmtHMM(WEEKLY_TARGET_MS)}`;
  }
  const locked = isLocked();
  const lp = byId('lockoutPill');
  if(lp){
    if(locked){ 
      const timeLeft = state.lockoutUntil - Date.now();
      const message = timeLeft > 12*60*60*1000 ? 'üîí Come back tomorrow' : `üîí Locked (${fmtHMM(timeLeft)} left)`;
      lp.style.display='inline-flex'; 
      lp.textContent = message; 
    }
    else lp.style.display='none';
  }
  const pf = byId('playFlappy'); if(pf) pf.disabled = !locked;
}
function setFromIndex(i){return Math.floor((i-1)/LEVELS_PER_SET)+1;}
function blockFromIndex(i){return ((i-1)%LEVELS_PER_SET)+1;}
function thresholdForIndex(i){return THRESH_24[blockFromIndex(i)-1];}
function trainedSet(k){ return UNLOCK_ORDER.slice(0,k); }

/* ------------------ AUDIO ------------------ */
let ACTX=null; const BUF_CACHE=new Map();
function getCtx(){ if(!ACTX){ ACTX=new (window.AudioContext||window.webkitAudioContext)(); } return ACTX; }
async function resumeCtx(){ try{ const ctx=getCtx(); if(ctx.state==='suspended') await ctx.resume(); }catch(e){ report(e); } }
async function loadBuffer(url){ if(BUF_CACHE.has(url)) return BUF_CACHE.get(url); const res=await fetch(url); if(!res.ok) throw new Error('Missing audio '+url); const arr=await res.arrayBuffer(); const buf=await getCtx().decodeAudioData(arr); BUF_CACHE.set(url,buf); return buf; }
async function closeAudio(){ try{ if(ACTX){ await ACTX.close(); } }catch(_){} finally{ ACTX=null; BUF_CACHE.clear(); } }

/* Guitar sample mapping - available samples and their pitches */
const GUITAR_SAMPLES = {
  'E2': 'E2.wav', 'A2': 'A2.wav', 'D3': 'D3.wav', 
  'G3': 'G3.wav', 'B3': 'B3.wav', 'E4': 'E4.wav', 'A4': 'A4.wav'
};

/* Find closest guitar sample for pitch shifting */
function findClosestGuitarSample(targetNote) {
  const m=/^([A-G](?:b)?)(\d)$/.exec(targetNote);
  const pc=m?m[1]:'A', o=m?+m[2]:4;
  const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
  const targetSemis=(idx[pc]??9)+(o-4)*12;
  
  let bestSample = 'E2';
  let bestDistance = 999;
  
  for (const sampleNote of Object.keys(GUITAR_SAMPLES)) {
    const sm=/^([A-G](?:b)?)(\d)$/.exec(sampleNote);
    const spc=sm?sm[1]:'E', so=sm?+sm[2]:2;
    const sampleSemis=(idx[spc]??4)+(so-4)*12;
    const distance = Math.abs(targetSemis - sampleSemis);
    if (distance < bestDistance) {
      bestDistance = distance;
      bestSample = sampleNote;
    }
  }
  
  return { sample: bestSample, semitones: targetSemis - ((idx[bestSample.match(/^([A-G](?:b)?)/)[1]]??4)+((+bestSample.match(/(\d)$/)[1])-4)*12) };
}

/* Always play a tone (sample -> oscillator -> fallback) */
async function playSample(note, jitterCents = 0, forceTimbre = null){
  // Skip audio during simulation
  if (SIMULATING) return;
  
  try{
    await resumeCtx();
    const ctx = getCtx();
    
    // Determine which timbre to use
    const noteWithoutOctave = note.replace(/\d/, '');
    const preferredTimbre = forceTimbre || state.audioType;
    const actualTimbre = forceTimbre || getTimbreForTrial(preferredTimbre, noteWithoutOctave);
    
    // Store the timbre used for this trial
    currentTrialTimbre = actualTimbre;
    
    // Handle different audio types
    if (actualTimbre === AUDIO_TYPES.PIANO) {
      try{
        const url = `${AUDIO_PIANO}/${note}.mp3`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply jitter via playback rate if specified
        if (jitterCents !== 0) {
          const pitchRatio = Math.pow(2, jitterCents / 1200);
          src.playbackRate.value = pitchRatio;
        }
        
        const g = ctx.createGain(); g.gain.value = 1;
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        const duration = jitterCents !== 0 ? TONE_MS/1000 / src.playbackRate.value : TONE_MS/1000;
        src.start(t); src.stop(t + duration);
        return;
      }catch(_e){}
    } else if (actualTimbre === AUDIO_TYPES.GUITAR) {
      try{
        const {sample, semitones} = findClosestGuitarSample(note);
        const url = `${AUDIO_GUITAR}/${GUITAR_SAMPLES[sample]}`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply pitch shifting with jitter
        const basePitchRatio = Math.pow(2, semitones / 12);
        const jitterRatio = jitterCents !== 0 ? Math.pow(2, jitterCents / 1200) : 1;
        src.playbackRate.value = basePitchRatio * jitterRatio;
        
        // Guitar samples are louder, so reduce gain
        const g = ctx.createGain(); 
        g.gain.value = 0.7; // Reduce guitar volume
        
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        src.start(t); src.stop(t + TONE_MS/1000 / src.playbackRate.value);
        return;
      }catch(_e){}
    } else if (actualTimbre === AUDIO_TYPES.SINE) {
      // Skip to sine wave generation
    } else {
      // Default to piano, fallback to sine
      try{
        const url = `${AUDIO_PIANO}/${note}.mp3`;
        const buf = await loadBuffer(url);
        const src = ctx.createBufferSource();
        src.buffer = buf;
        
        // Apply jitter via playback rate if specified
        if (jitterCents !== 0) {
          const pitchRatio = Math.pow(2, jitterCents / 1200);
          src.playbackRate.value = pitchRatio;
        }
        
        const g = ctx.createGain(); g.gain.value = 1;
        src.connect(g).connect(ctx.destination);
        const t = ctx.currentTime;
        const duration = jitterCents !== 0 ? TONE_MS/1000 / src.playbackRate.value : TONE_MS/1000;
        src.start(t); src.stop(t + duration);
        return;
      }catch(_e){}
    }
    
    // Fallback to sine wave
    const m=/^([A-G](?:b)?)(\d)$/.exec(note);
    const pc=m?m[1]:'A', o=m?+m[2]:4;
    const idx={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
    const semis=(idx[pc]??9)+(o-4)*12;
    let freq=440*Math.pow(2,(semis-9)/12);
    
    // Apply jitter to frequency
    if (jitterCents !== 0) {
      freq = freq * Math.pow(2, jitterCents / 1200);
    }
    
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.type='sine'; osc.frequency.value=freq;
    const t0 = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.25, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + TONE_MS/1000);
    osc.connect(g).connect(ctx.destination);
    osc.start(t0); osc.stop(t0 + TONE_MS/1000);
  }catch(e){
    try{
      const ctx=getCtx(); const osc=ctx.createOscillator(); const g=ctx.createGain();
      osc.type='sine'; osc.frequency.value=440;
      const t0=ctx.currentTime; g.gain.setValueAtTime(0.0001,t0); g.gain.linearRampToValueAtTime(0.2,t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t0+0.3);
      osc.connect(g).connect(ctx.destination); osc.start(t0); osc.stop(t0+0.3);
    }catch(_){}
  }
}

/* Flappy sound for Flappy Bird lockout */
async function playFlappySound(){
  try{
    await resumeCtx();
    const ctx = getCtx();
    const url = `${AUDIO_PIANO}/flappy.mp3`;
    const buf = await loadBuffer(url);
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const g = ctx.createGain(); 
    g.gain.value = 0.8; // Set volume level
    src.connect(g).connect(ctx.destination);
    const t = ctx.currentTime;
    src.start(t);
  }catch(_e){}
}

/* ------------------ JITTER SYSTEM ------------------ */
// Jitter Level Constants
const JITTER_LEVELS = {
  JL0: { // Onboarding (new pitch or new timbre)
    jitterRange: [-8, 8], // ¬±3-8¬¢
    probeRate: 0.02, // 0-3%
    probeRange: [-30, 30], // ¬±25-40¬¢
    promoteAcc: 0.75,
    promoteMedian: 20,
    trials: 40
  },
  JL1: { // Early stable
    jitterRange: [-10, 10], // ¬±5-10¬¢
    probeRate: 0.05, // ~5%
    probeRange: [-35, 35],
    promoteAcc: 0.80,
    promoteMedian: 15,
    trials: 40
  },
  JL2: { // Mid stable
    jitterRange: [-15, 15], // ¬±5-15¬¢
    probeRate: 0.08, // ~8%
    probeRange: [-40, 40],
    promoteAcc: 0.90,
    promoteMedian: 10,
    promoteSD: 15,
    trials: 40
  },
  JL3: { // Mature
    jitterRange: [-15, 15], // ¬±5-15¬¢ (global default)
    probeRate: 0.11, // ~10-12%
    probeRange: [-40, 40],
    demoteAcc: 0.75,
    demoteMedian: 25,
    demoteSD: 30,
    trials: 20
  }
};

function initializeJitterLevel(note) {
  if (!state.jitterLevels) state.jitterLevels = {};
  if (!state.jitterLevels[note]) {
    state.jitterLevels[note] = 'JL0'; // Start at onboarding level
  }
  if (!state.noteStats) state.noteStats = {};
  if (!state.noteStats[note]) {
    state.noteStats[note] = {
      trials: [],
      accuracy: 0,
      medianError: 0,
      stdDev: 0,
      lastUpdated: Date.now()
    };
  }
}

function updateNoteStats(note, isCorrect, centsError = 0) {
  initializeJitterLevel(note);
  
  const stats = state.noteStats[note];
  const trial = {
    correct: isCorrect,
    centsError: centsError,
    timestamp: Date.now()
  };
  
  // Add trial and maintain rolling window
  stats.trials.push(trial);
  const maxTrials = 40; // Rolling window size
  if (stats.trials.length > maxTrials) {
    stats.trials = stats.trials.slice(-maxTrials);
  }
  
  // Calculate rolling statistics
  const recentTrials = stats.trials.slice(-maxTrials);
  stats.accuracy = recentTrials.filter(t => t.correct).length / recentTrials.length;
  
  // Calculate median error and standard deviation
  const errors = recentTrials.map(t => Math.abs(t.centsError || 0));
  errors.sort((a, b) => a - b);
  stats.medianError = errors.length > 0 ? errors[Math.floor(errors.length / 2)] : 0;
  
  const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
  const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
  stats.stdDev = Math.sqrt(variance);
  
  stats.lastUpdated = Date.now();
  
  // Check for level promotion/demotion
  updateJitterLevel(note);
  save();
}

function updateJitterLevel(note) {
  const currentLevel = state.jitterLevels[note];
  const stats = state.noteStats[note];
  const config = JITTER_LEVELS[currentLevel];
  
  if (!stats || stats.trials.length < 20) return; // Need minimum trials
  
  switch (currentLevel) {
    case 'JL0':
      if (stats.accuracy >= config.promoteAcc && stats.medianError <= config.promoteMedian && stats.trials.length >= config.trials) {
        state.jitterLevels[note] = 'JL1';
      }
      break;
    case 'JL1':
      if (stats.accuracy >= config.promoteAcc && stats.medianError <= config.promoteMedian) {
        state.jitterLevels[note] = 'JL2';
      } else if (stats.accuracy < 0.60 || stats.medianError > 30) {
        state.jitterLevels[note] = 'JL0'; // Demote to rescue
      }
      break;
    case 'JL2':
      if (stats.accuracy >= config.promoteAcc && stats.medianError <= config.promoteMedian && stats.stdDev <= config.promoteSD) {
        state.jitterLevels[note] = 'JL3';
      } else if (stats.accuracy < 0.75 || stats.medianError > 25) {
        state.jitterLevels[note] = 'JL1';
      }
      break;
    case 'JL3':
      if (stats.accuracy < config.demoteAcc || stats.medianError > config.demoteMedian || stats.stdDev > config.demoteSD) {
        state.jitterLevels[note] = 'JL2'; // Demote one level
      }
      break;
  }
}

function calculateJitter(note, isProbe = false) {
  initializeJitterLevel(note);
  
  const level = state.jitterLevels[note];
  const config = JITTER_LEVELS[level];
  
  if (isProbe) {
    // Boundary probe
    const range = config.probeRange;
    const sign = Math.random() < 0.5 ? -1 : 1;
    const min = Math.abs(range[0]) * 0.6; // 25¬¢ minimum
    const max = Math.abs(range[1]); // 40¬¢ maximum
    return sign * (min + Math.random() * (max - min));
  } else {
    // Regular jitter
    const range = config.jitterRange;
    return range[0] + Math.random() * (range[1] - range[0]);
  }
}

function shouldUseProbe(note) {
  initializeJitterLevel(note);
  const level = state.jitterLevels[note];
  const config = JITTER_LEVELS[level];
  return Math.random() < config.probeRate;
}

function selectInBoundsNote(usableNotes) {
  if (usableNotes.length === 0) return 'F'; // Fallback
  
  // Get weak notes and confusion pairs
  const weakNotes = getWeakNotes().map(w => w.note);
  const confusionPairs = getConfusionPairs();
  
  // Create weighted selection
  const weights = {};
  const baseWeight = 1; // Minimum weight for all notes
  
  // Initialize all notes with base weight
  usableNotes.forEach(note => {
    weights[note] = baseWeight;
  });
  
  // Boost weight for weak notes
  weakNotes.forEach(note => {
    if (weights[note] !== undefined) {
      weights[note] += 2; // Extra weight for weak notes
    }
  });
  
  // Boost weight for notes in top confusion pairs
  confusionPairs.slice(0, 2).forEach(pair => {
    if (weights[pair.truePc] !== undefined) {
      weights[pair.truePc] += 1.5; // Extra weight for confused notes
    }
  });
  
  // Weighted random selection
  const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
  let random = Math.random() * totalWeight;
  
  for (const [note, weight] of Object.entries(weights)) {
    random -= weight;
    if (random <= 0) {
      return note;
    }
  }
  
  return rand(usableNotes); // Fallback to random
}

/* ------------------ CONFUSION MATRIX & SCHEDULING ------------------ */
function updateConfusionMatrix(truePc, guessPc) {
  if (!state.confusionMatrix) state.confusionMatrix = {};
  
  const key = `${truePc}->${guessPc}`;
  state.confusionMatrix[key] = (state.confusionMatrix[key] || 0) + 1;
}

function getConfusionPairs() {
  // Return the most confused note pairs for targeted training
  if (!state.confusionMatrix) return [];
  
  const pairs = Object.entries(state.confusionMatrix)
    .map(([key, count]) => {
      const [truePc, guessPc] = key.split('->');
      return { truePc, guessPc, count };
    })
    .sort((a, b) => b.count - a.count);
  
  return pairs.slice(0, 3); // Top 3 confusion pairs
}

function getWeakNotes() {
  // Return notes that need more training based on recent performance
  if (!state.noteStats) return [];
  
  const weakNotes = Object.entries(state.noteStats)
    .filter(([note, stats]) => {
      return stats.trials.length >= 10 && (
        stats.accuracy < 0.75 || 
        stats.medianError > 25
      );
    })
    .map(([note, stats]) => ({ note, accuracy: stats.accuracy, medianError: stats.medianError }))
    .sort((a, b) => a.accuracy - b.accuracy);
  
  return weakNotes.slice(0, 3); // Top 3 weak notes
}

function updateJitterStatusUI(set) {
  const trainedNotes = trainedSet(set);
  if (trainedNotes.length === 0) return;
  
  // Get average jitter level across trained notes
  const levels = trainedNotes.map(note => {
    initializeJitterLevel(note);
    return state.jitterLevels[note];
  });
  
  const levelCounts = levels.reduce((acc, level) => {
    acc[level] = (acc[level] || 0) + 1;
    return acc;
  }, {});
  
  // Show most common level
  const mostCommon = Object.entries(levelCounts)
    .sort(([,a], [,b]) => b - a)[0];
  
  if (mostCommon) {
    textWithTooltip('jitterInfo', `Jitter: ${mostCommon[0]}`);
    byId('jitterInfo').style.display = 'inline-flex';
  }
}

function updateOctaveStatusUI() {
  initializeOctaveState();
  const mix = state.octaveStats.currentMix;
  const centerPct = Math.round(mix.center * 100);
  const neighborPct = Math.round(mix.neighbors * 100);
  
  textWithTooltip('octaveInfo', `Mix: ${centerPct}/${neighborPct}`);
  byId('octaveInfo').style.display = 'inline-flex';
}

function updateVarietyModeUI() {
  const label = byId('varietyModeLabel');
  const toggle = byId('varietyModeToggle');
  
  if (!label || !toggle) return;
  
  if (!state.startDate) {
    label.textContent = "Will activate after week 3";
    return;
  }
  
  const weeksSinceStart = Math.floor((Date.now() - state.startDate) / (7 * 24 * 60 * 60 * 1000));
  
  if (weeksSinceStart < 3) {
    label.textContent = `Will activate in ${3 - weeksSinceStart} week(s)`;
  } else if (state.varietyModeEnabled && shouldUseVarietyMode()) {
    label.textContent = "Active: 80%/20% mix";
  } else if (state.varietyModeEnabled) {
    label.textContent = "Enabled, will activate week 3+";
  } else {
    label.textContent = "Available now - click to enable";
  }
}

function updateDebugInfo() {
  const content = byId('debugContent');
  if (!content) return;
  
  const info = [];
  
  // System state
  info.push(`=== SYSTEM STATE ===`);
  info.push(`Session Active: ${sessionActive}`);
  info.push(`Current Level: ${state.levelIndex} (Set ${setFromIndex(state.levelIndex)}, Block ${blockFromIndex(state.levelIndex)})`);
  info.push(`Variety Mode: ${state.varietyModeEnabled} (Active: ${shouldUseVarietyMode()})`);
  
  // Jitter levels
  if (state.jitterLevels && Object.keys(state.jitterLevels).length > 0) {
    info.push(`\n=== JITTER LEVELS ===`);
    Object.entries(state.jitterLevels).forEach(([note, level]) => {
      const stats = state.noteStats?.[note];
      const acc = stats ? (stats.accuracy * 100).toFixed(0) : 'N/A';
      const err = stats ? stats.medianError.toFixed(0) : 'N/A';
      info.push(`${note}: ${level} (${acc}% acc, ${err}¬¢ err)`);
    });
  }
  
  // OOB state
  if (state.oobStats) {
    info.push(`\n=== OOB SYSTEM ===`);
    info.push(`Adaptive Rate: ${(state.oobStats.adaptiveRate * 100).toFixed(1)}%`);
    info.push(`Streak Count: ${state.oobStats.streakCount}`);
    info.push(`Health Check: ${state.oobStats.healthCheckActive}`);
    info.push(`Recent Trials: ${state.oobStats.recentTrials.length}/60`);
  }
  
  // Octave mixing
  if (state.octaveStats) {
    info.push(`\n=== OCTAVE MIXING ===`);
    const mix = state.octaveStats.currentMix;
    info.push(`Current Mix: ${(mix.center * 100).toFixed(0)}% center, ${(mix.neighbors * 100).toFixed(0)}% neighbors`);
    info.push(`Set Trials: ${state.octaveStats.setTrials.length}/24`);
  }
  
  // Timbre state
  if (state.timbreStats && shouldUseVarietyMode()) {
    info.push(`\n=== TIMBRE VARIETY ===`);
    info.push(`Daily Alternate: ${state.timbreStats.dailyAlternate || 'None'}`);
    info.push(`Last Rotation: ${state.timbreStats.lastRotation || 'Never'}`);
  }
  
  content.textContent = info.join('\n');
}

/* ------------------ ENHANCED AUDIO WITH JITTER ------------------ */
// Simplified pitch detection using autocorrelation
function detectPitch(audioBuffer) {
  const sampleRate = audioBuffer.sampleRate;
  const buffer = audioBuffer.getChannelData(0);
  const bufferSize = buffer.length;
  
  // Basic autocorrelation for pitch detection
  const minPeriod = Math.floor(sampleRate / 800); // ~800 Hz max
  const maxPeriod = Math.floor(sampleRate / 80);  // ~80 Hz min
  
  let bestCorrelation = 0;
  let bestPeriod = 0;
  
  for (let period = minPeriod; period < maxPeriod && period < bufferSize / 2; period++) {
    let correlation = 0;
    for (let i = 0; i < bufferSize - period; i++) {
      correlation += buffer[i] * buffer[i + period];
    }
    
    if (correlation > bestCorrelation) {
      bestCorrelation = correlation;
      bestPeriod = period;
    }
  }
  
  if (bestPeriod === 0) return null;
  
  const frequency = sampleRate / bestPeriod;
  return frequency;
}

function frequencyToCents(freq, referenceFreq = 440) {
  if (!freq || freq <= 0) return null;
  return Math.round(1200 * Math.log2(freq / referenceFreq));
}

function centsToNoteName(cents) {
  // A4 = 440Hz = 0 cents reference
  const noteNames = ['A', 'Bb', 'B', 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab'];
  const semitonesFromA = Math.round(cents / 100);
  const noteIndex = ((semitonesFromA % 12) + 12) % 12;
  return noteNames[noteIndex];
}

function targetNoteToCents(note) {
  // Convert note name to cents offset from A4, considering closest octave F1-F7
  const noteOffsets = {A: 0, Bb: 100, B: 200, C: 300, Db: 400, D: 500, Eb: 600, E: 700, F: 800, Gb: 900, G: 1000, Ab: 1100};
  const baseCents = noteOffsets[note] || 0;
  
  // Return array of possible target cents for octaves 1-7
  const possibleCents = [];
  for (let octave = 1; octave <= 7; octave++) {
    const octaveCents = baseCents + (octave - 4) * 1200; // A4 is reference (0 cents)
    possibleCents.push(octaveCents);
  }
  
  return possibleCents;
}

async function startRecallTest(type = 'cold') {
  if (!state.userName) return;
  
  recallType = type;
  recallActive = true;
  recallIndex = 0;
  recallData = [];
  
  // Determine which notes to test (2-3 learned notes)
  const set = setFromIndex(state.levelIndex);
  const learnedNotes = trainedSet(Math.min(set, 3)); // Use first 2-3 learned notes
  recallNotes = learnedNotes.slice(0, Math.min(3, learnedNotes.length));
  
  if (recallNotes.length === 0) {
    // No learned notes yet, skip recall
    if (type === 'cold') startTrainingDirectly();
    return;
  }
  
  // Update modal
  document.getElementById('recallTitle').textContent = type === 'cold' ? 'üåÖ Cold Recall Test' : 'üî• Warm Recall Test';
  document.getElementById('recallInstruction').textContent = 
    type === 'cold' 
      ? 'Before training, please sing/hum the following notes to test your pitch memory:'
      : 'After training, please sing/hum the following notes again:';
  
  updateRecallUI();
  document.getElementById('recallModal').style.display = 'flex';
}

function updateRecallUI() {
  if (!recallActive || recallIndex >= recallNotes.length) return;
  
  const currentNote = recallNotes[recallIndex];
  document.getElementById('recallCounter').textContent = `Note ${recallIndex + 1} of ${recallNotes.length}`;
  document.getElementById('recallCurrentNote').textContent = pcLabel(currentNote);
  document.getElementById('recallTargetNote').textContent = pcLabel(currentNote);
  
  // Reset UI state
  document.getElementById('recallFeedback').style.display = 'none';
  document.getElementById('btnStartRecording').style.display = 'inline-block';
  document.getElementById('btnStopRecording').style.display = 'none';
  document.getElementById('btnNextRecall').style.display = 'none';
  document.getElementById('btnFinishRecall').style.display = 'none';
}

async function startRecallRecording() {
  try {
    // Request microphone access
    recallStream = await navigator.mediaDevices.getUserMedia({ 
      audio: { 
        sampleRate: RECALL_SAMPLE_RATE,
        channelCount: 1,
        echoCancellation: false,
        noiseSuppression: false 
      } 
    });
    
    const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: RECALL_SAMPLE_RATE });
    const source = audioContext.createMediaStreamSource(recallStream);
    
    // Use MediaRecorder for simplicity
    recallRecorder = new MediaRecorder(recallStream);
    const chunks = [];
    
    recallRecorder.ondataavailable = (event) => {
      chunks.push(event.data);
    };
    
    recallRecorder.onstop = async () => {
      const blob = new Blob(chunks, { type: 'audio/wav' });
      const arrayBuffer = await blob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      processRecallRecording(audioBuffer);
      
      // Clean up
      recallStream.getTracks().forEach(track => track.stop());
      recallStream = null;
      audioContext.close();
    };
    
    // Update UI
    document.getElementById('btnStartRecording').style.display = 'none';
    document.getElementById('btnStopRecording').style.display = 'inline-block';
    
    // Start recording
    recallRecorder.start();
    
    // Auto-stop after 2 seconds
    setTimeout(() => {
      if (recallRecorder && recallRecorder.state === 'recording') {
        recallRecorder.stop();
      }
    }, RECALL_DURATION_MS);
    
  } catch (error) {
    console.error('Error accessing microphone:', error);
    alert('Could not access microphone. Please check permissions and try again.');
    document.getElementById('btnStartRecording').style.display = 'inline-block';
    document.getElementById('btnStopRecording').style.display = 'none';
  }
}

function stopRecallRecording() {
  if (recallRecorder && recallRecorder.state === 'recording') {
    recallRecorder.stop();
  }
}

function processRecallRecording(audioBuffer) {
  const targetNote = recallNotes[recallIndex];
  const possibleTargetCents = targetNoteToCents(targetNote);
  
  // Analyze multiple segments of the recording for better accuracy
  const segmentSize = Math.floor(audioBuffer.length / 4);
  const frequencies = [];
  
  for (let i = 0; i < 4; i++) {
    const start = i * segmentSize;
    const segmentBuffer = audioBuffer.getChannelData(0).slice(start, start + segmentSize);
    const segmentAudioBuffer = {
      sampleRate: audioBuffer.sampleRate,
      getChannelData: () => segmentBuffer,
      length: segmentBuffer.length
    };
    
    const freq = detectPitch(segmentAudioBuffer);
    if (freq && freq > 80 && freq < 800) {
      frequencies.push(freq);
    }
  }
  
  if (frequencies.length === 0) {
    showRecallResult('No clear pitch detected. Please try again.', null, null);
    return;
  }
  
  // Calculate median frequency and convert to cents
  frequencies.sort((a, b) => a - b);
  const medianFreq = frequencies[Math.floor(frequencies.length / 2)];
  const detectedCents = frequencyToCents(medianFreq);
  
  // Find the closest target octave
  let closestTargetCents = possibleTargetCents[0];
  let smallestError = Math.abs(detectedCents - possibleTargetCents[0]);
  
  for (const targetCents of possibleTargetCents) {
    const error = Math.abs(detectedCents - targetCents);
    if (error < smallestError) {
      smallestError = error;
      closestTargetCents = targetCents;
    }
  }
  
  const centsError = detectedCents - closestTargetCents;
  
  // Calculate standard deviation
  const avgCents = frequencies.map(f => frequencyToCents(f));
  const mean = avgCents.reduce((a, b) => a + b, 0) / avgCents.length;
  const variance = avgCents.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / avgCents.length;
  const stdDev = Math.sqrt(variance);
  
  // Determine verdict
  let verdict;
  const absError = Math.abs(centsError);
  if (absError <= 10 && stdDev <= 15) {
    verdict = 'On target';
  } else if (absError <= 30) {
    verdict = 'Close';
  } else {
    verdict = 'Off';
  }
  
  // Store result
  const result = {
    note: targetNote,
    type: recallType,
    date: Date.now(),
    medianCents: detectedCents,
    centsError: centsError,
    stdDev: stdDev,
    verdict: verdict,
    frequency: medianFreq
  };
  
  recallData.push(result);
  state.recallResults.push(result);
  save();
  
  showRecallResult(`${Math.abs(centsError)} cents ${centsError >= 0 ? 'sharp' : 'flat'}`, verdict, centsError);
}

function showRecallResult(message, verdict, centsError) {
  const feedbackDiv = document.getElementById('recallFeedback');
  const resultsDiv = document.getElementById('recallResults');
  const verdictDiv = document.getElementById('recallVerdict');
  
  resultsDiv.textContent = message;
  verdictDiv.textContent = verdict ? `Verdict: ${verdict}` : '';
  
  // Color code the result
  if (verdict === 'On target') {
    resultsDiv.style.color = 'var(--good)';
  } else if (verdict === 'Close') {
    resultsDiv.style.color = 'var(--accent)';
  } else {
    resultsDiv.style.color = 'var(--bad)';
  }
  
  feedbackDiv.style.display = 'block';
  
  // Show appropriate next button
  if (recallIndex < recallNotes.length - 1) {
    document.getElementById('btnNextRecall').style.display = 'inline-block';
  } else {
    document.getElementById('btnFinishRecall').style.display = 'inline-block';
  }
}

function nextRecallNote() {
  recallIndex++;
  if (recallIndex >= recallNotes.length) {
    finishRecallTest();
  } else {
    updateRecallUI();
  }
}

function skipRecallTest() {
  recallActive = false;
  document.getElementById('recallModal').style.display = 'none';
  
  if (recallType === 'cold') {
    startTrainingDirectly();
  } else {
    // Warm recall finished, show session complete
    alert('Training session complete!');
    showScreen('menuScreen');
  }
}

function finishRecallTest() {
  recallActive = false;
  document.getElementById('recallModal').style.display = 'none';
  
  if (recallType === 'cold') {
    state.coldRecallDone = true;
    save();
    startTrainingDirectly();
  } else {
    state.warmRecallDone = true;
    save();
    alert('Training session and warm recall complete!');
    showScreen('menuScreen');
  }
}

/* ------------------ TRAINING FLOW ------------------ */
let autoNext=false, delayMs=1000;
let currentNote=null, truePc=null, isOOBTrial=false;
let currentTrialJitter=null; // Track jitter info for current trial
let currentTrialTimbre=null; // Track timbre used for current trial
let firstRtBonusMs=0, inFlightTrial=false;
let suggestedRestartFlag=false;

/* Specials runtime */
let special=null; // {mode:'A'|'B', targetPc:'F', total:12|22, done:0, withFeedback:true, correct:0}

/* Assessment runtime */
let assessmentActive=false, assessmentTrials=[], assessmentCurrentTrial=0;

const PC2I={C:0,Db:1,D:2,Eb:3,E:4,F:5,Gb:6,G:7,Ab:8,A:9,Bb:10,B:11};
function currentOOBs(setSize){
  if(setSize>=12) return [];
  const learned = trainedSet(setSize).map(n=>PC2I[n]).sort((a,b)=>a-b);
  const low=learned[0], high=learned[learned.length-1];
  const up1=(high+1)%12, up2=(high+2)%12, dn1=(low+11)%12, dn2=(low+10)%12;
  const out=[];
  if(!learned.includes(up1)) out.push(PC[up1]);
  if(!learned.includes(up2) && !learned.includes(up1)) out.push(PC[up2]);
  if(!learned.includes(dn1)) out.push(PC[dn1]);
  if(!learned.includes(dn2) && !learned.includes(dn1)) out.push(PC[dn2]);
  return out;
}
function getPlusMinusTwoSemitones(targetPc){
  const targetIndex = PC2I[targetPc];
  if (targetIndex === undefined) return [targetPc]; // fallback
  
  const pitches = [];
  for (let offset = -2; offset <= 2; offset++) {
    const index = (targetIndex + offset + 12) % 12;
    pitches.push(PC[index]);
  }
  return pitches;
}
/* ------------------ TIMBRE VARIETY SYSTEM ------------------ */
function initializeTimbreState() {
  if (!state.timbreStats) {
    state.timbreStats = {
      weekStarted: null,
      dailyAlternate: null,
      lastRotation: null,
      perTimbreRescue: {} // Track per-timbre performance for rescue
    };
  }
}

function shouldUseVarietyMode() {
  if (!state.varietyModeEnabled) return false;
  
  initializeTimbreState();
  
  // Check if we've been training for 3+ weeks
  if (!state.startDate) return false;
  
  const weeksSinceStart = Math.floor((Date.now() - state.startDate) / (7 * 24 * 60 * 60 * 1000));
  return weeksSinceStart >= 3;
}

function getTimbreForTrial(preferredTimbre, note) {
  if (!shouldUseVarietyMode()) {
    return preferredTimbre;
  }
  
  initializeTimbreState();
  
  // Check if we need to rotate daily alternate
  const today = Math.floor(Date.now() / (24 * 60 * 60 * 1000));
  if (state.timbreStats.lastRotation !== today) {
    // Rotate to different timbre
    const timbres = [AUDIO_TYPES.PIANO, AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR];
    const alternates = timbres.filter(t => t !== preferredTimbre);
    state.timbreStats.dailyAlternate = rand(alternates);
    state.timbreStats.lastRotation = today;
    save();
  }
  
  // Check for per-timbre rescue
  const noteTimbreKey = `${note}-${preferredTimbre}`;
  const alternateTimbreKey = `${note}-${state.timbreStats.dailyAlternate}`;
  
  const preferredStats = state.timbreStats.perTimbreRescue[noteTimbreKey];
  const alternateStats = state.timbreStats.perTimbreRescue[alternateTimbreKey];
  
  // If this note is weak on the alternate timbre, give it more examples
  if (alternateStats && (alternateStats.accuracy < 0.70 || alternateStats.medianError > 30)) {
    return state.timbreStats.dailyAlternate;
  }
  
  // Week 3+: 80% chosen timbre, 20% alternate
  return Math.random() < 0.80 ? preferredTimbre : state.timbreStats.dailyAlternate;
}

function updateTimbreStats(timbre, note, correct, centsError = 0) {
  if (!shouldUseVarietyMode()) return;
  
  initializeTimbreState();
  
  const key = `${note}-${timbre}`;
  if (!state.timbreStats.perTimbreRescue[key]) {
    state.timbreStats.perTimbreRescue[key] = {
      trials: [],
      accuracy: 0,
      medianError: 0
    };
  }
  
  const stats = state.timbreStats.perTimbreRescue[key];
  stats.trials.push({ correct, centsError, timestamp: Date.now() });
  
  // Keep last 20 trials
  if (stats.trials.length > 20) {
    stats.trials = stats.trials.slice(-20);
  }
  
  // Update metrics
  stats.accuracy = stats.trials.filter(t => t.correct).length / stats.trials.length;
  const errors = stats.trials.map(t => Math.abs(t.centsError || 0));
  errors.sort((a, b) => a - b);
  stats.medianError = errors.length > 0 ? errors[Math.floor(errors.length / 2)] : 0;
  
  save();
}

/* ------------------ OCTAVE MIXING SYSTEM ------------------ */
function initializeOctaveState() {
  if (!state.octaveStats) {
    state.octaveStats = {
      currentMix: { center: 0.90, neighbors: 0.10 }, // Start with 90/10
      centerOctave: 4, // Default center octave
      trialCount: 0,
      setTrials: [], // Current set's trial data
      performanceWindows: {
        window8_12: null,
        window12_16: null, 
        window16_20: null,
        window20_24: null
      }
    };
  }
}

function getOctaveRange() {
  // All audio types now use octaves 3-5
  return [3, 4, 5];
}

function selectOctaveForNote(note) {
  initializeOctaveState();
  
  const stats = state.octaveStats;
  const octaves = getOctaveRange();
  const centerOctave = stats.centerOctave;
  const neighbors = octaves.filter(o => o !== centerOctave);
  
  // Check for per-note override (weak notes get more center)
  const noteStats = state.noteStats?.[note];
  let centerBoost = 0;
  if (noteStats && (noteStats.accuracy < 0.75 || noteStats.medianError > 25)) {
    centerBoost = 0.20; // +20% center for weak notes
  }
  
  const centerProb = Math.min(0.95, stats.currentMix.center + centerBoost);
  const neighborProb = 1 - centerProb;
  
  // ~10% surprise checks (count within neighbor share)
  const surpriseCheck = Math.random() < 0.10;
  
  if (Math.random() < centerProb && !surpriseCheck) {
    return centerOctave;
  } else {
    // Select from neighbors, including surprise checks
    return rand(neighbors);
  }
}

function updateOctaveMixing(trialData) {
  initializeOctaveState();
  
  const stats = state.octaveStats;
  stats.trialCount++;
  
  // Only count graded in-bounds trials
  if (!trialData.oob && trialData.set) {
    stats.setTrials.push(trialData);
    
    // Check performance windows at specific trial counts
    const trialNum = stats.setTrials.length;
    
    if (trialNum === 12) {
      checkOctaveStep(8, 12, 'window8_12');
    } else if (trialNum === 16) {
      checkOctaveStep(12, 16, 'window12_16');
    } else if (trialNum === 20) {
      checkOctaveStep(16, 20, 'window16_20');
    } else if (trialNum === 24) {
      checkOctaveStep(20, 24, 'window20_24');
      processEndOfSetPromotion();
    }
  }
  
  save();
}

function checkOctaveStep(startTrial, endTrial, windowKey) {
  const stats = state.octaveStats;
  const windowTrials = stats.setTrials.slice(startTrial - 1, endTrial);
  
  if (windowTrials.length < 4) return; // Need minimum trials
  
  const accuracy = windowTrials.filter(t => t.correct).length / windowTrials.length;
  const errors = windowTrials.map(t => Math.abs(t.jitter?.jitter || 0));
  const medianError = errors.sort((a, b) => a - b)[Math.floor(errors.length / 2)];
  
  const windowData = { accuracy, medianError, trials: windowTrials.length };
  stats.performanceWindows[windowKey] = windowData;
  
  // Apply stepping rules
  if (windowKey === 'window8_12') {
    if (accuracy >= 0.80 && medianError <= 15) {
      stats.currentMix = { center: 0.70, neighbors: 0.30 };
    } else {
      // Re-check at trial 16
      stats.recheckAt16 = true;
    }
  } else if (windowKey === 'window12_16' && stats.recheckAt16) {
    if (accuracy >= 0.80 && medianError <= 15) {
      stats.currentMix = { center: 0.70, neighbors: 0.30 };
    }
    delete stats.recheckAt16;
  } else if (windowKey === 'window16_20') {
    if (accuracy >= 0.85 && medianError <= 12) {
      stats.currentMix = { center: 0.60, neighbors: 0.40 };
    }
  }
}

function processEndOfSetPromotion() {
  const stats = state.octaveStats;
  const window20_24 = stats.performanceWindows.window20_24;
  
  if (!window20_24) return;
  
  const { accuracy, medianError } = window20_24;
  const errors = stats.setTrials.slice(-4).map(t => Math.abs(t.jitter?.jitter || 0));
  const mean = errors.reduce((a, b) => a + b, 0) / errors.length;
  const variance = errors.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / errors.length;
  const stdDev = Math.sqrt(variance);
  
  // Determine next set baseline
  if (accuracy >= 0.90 && medianError <= 10 && stdDev <= 15) {
    stats.currentMix = { center: 0.50, neighbors: 0.50 }; // 50/50
  } else if (accuracy >= 0.85 && medianError <= 12) {
    stats.currentMix = { center: 0.60, neighbors: 0.40 }; // 60/40
  } else if (accuracy < 0.80) {
    stats.currentMix = { center: 0.90, neighbors: 0.10 }; // Back to 90/10 if struggling
  } else {
    stats.currentMix = { center: 0.70, neighbors: 0.30 }; // Default to 70/30
  }
  
  // Reset for next set
  stats.setTrials = [];
  stats.performanceWindows = {
    window8_12: null,
    window12_16: null,
    window16_20: null,
    window20_24: null
  };
}

function currentOctaves(){ 
  // All audio types now use octaves 3-5
  return [3, 4, 5];
}
function rand(a){ return a[Math.floor(Math.random()*a.length)]; }
function pcLabel(pc){ return PC_LABEL[pc] || pc; }

function updateLevelUI(){
  const set=setFromIndex(state.levelIndex), block=blockFromIndex(state.levelIndex);
  textWithTooltip('setInfo', `Pitches ${set} / 12`);
  textWithTooltip('blockInfo', `Block ${block} / 24`);
  if(block >= 21){ textWithTooltip('accInfo', `Testing ‚Äî No Feedback`); }
  else{
    const req=(thresholdForIndex(state.levelIndex)*100).toFixed(0);
    const acc=((state.levelCorrect/state.levelTrials*100)||0).toFixed(0);
    textWithTooltip('accInfo', `Acc ${acc}% (req ${req}%)`);
  }
  textWithTooltip('delayInfo', `RT limit: ${rtWindowForSet(set)}ms ‚Ä¢ Delay: ${delayMs}ms`);
  
  // Update jitter and octave status for active sessions
  if (sessionActive && set >= 1) {
    updateJitterStatusUI(set);
    updateOctaveStatusUI();
  } else {
    byId('jitterInfo').style.display = 'none';
    byId('octaveInfo').style.display = 'none';
  }
}

/* Build note pad and attach handlers */
function paintNotes(){
  const pad=byId('notePad'); if(!pad) return; pad.innerHTML='';
  const set=setFromIndex(state.levelIndex);
  const learned = new Set(trainedSet(set));
  const sorted = PC.filter(pc=> learned.has(pc));
  for(const pc of sorted){
    const b=document.createElement('button');
    b.textContent=pcLabel(pc);
    b.dataset.pc=pc;
    b.className='note';
    b.type='button';
    b.addEventListener('click', ()=> guess(pc));
    pad.appendChild(b);
  }
  safe('btnOOB', el=> {
    el.style.display = set>=12 ? 'none' : 'block';
    el.onclick = ()=> chooseOOB();
  });
}

/* ---------- Specials at BLOCK 15 (weakest from last 15 blocks) ---------- */
function chooseWeakestFromLastBlocks(nBlocks=15){
  const set = setFromIndex(state.levelIndex);
  const curBlock = blockFromIndex(state.levelIndex);
  const from = Math.max(1, curBlock - (nBlocks - 1));
  const trained = new Set(trainedSet(set));
  const windowTrials = (state.trials||[]).filter(t =>
    t.set === set && t.block >= from && t.block <= curBlock && t.block >= 1 && t.block <= 20
  );
  const stats = new Map();
  for(const pc of trained) stats.set(pc, {ok:0, n:0, order:UNLOCK_ORDER.indexOf(pc)});
  for(const t of windowTrials){ if(!trained.has(t.pc)) continue; const s=stats.get(t.pc); s.n++; if(t.correct) s.ok++; }
  let pick=null;
  for(const [pc,s] of stats){
    if(pick===null) pick={pc,...s};
    else if(s.ok < pick.ok || (s.ok===pick.ok && s.n > pick.n) || (s.ok===pick.ok && s.n===pick.n && s.order < pick.order)) pick={pc,...s};
  }
  return pick ? pick.pc : UNLOCK_ORDER[Math.min(set-1, UNLOCK_ORDER.length-1)];
}
function startSpecialAtBlock15(){
  const set = setFromIndex(state.levelIndex);
  if(set < 5) return false;
  if(blockFromIndex(state.levelIndex) !== 15) return false;
  if(state.specialRanForLevel === state.levelIndex) return false;
  state.specialRanForLevel = state.levelIndex; save();

  const targetPc = chooseWeakestFromLastBlocks(15);
  special = {mode:'A', targetPc, total:12, done:0, withFeedback:true, correct:0};
  showSpecialUI(true, `Special A ‚Äî focus: ${pcLabel(targetPc)}`);
  text('btnTarget', `Target (${pcLabel(targetPc)})`);
  text('btnOther',  'Other (¬±2 semitones)');
  nextSpecialTrial(true);
  return true;
}
function showSpecialUI(show, label){
  if(show){
    showFlex('specialBar'); text('specialText', label||'Special Exercise');
    text('specialCount', '0 / 0');
    showBlock('binaryPad'); hide('notePad'); hide('btnOOB');
  }else{
    hide('specialBar'); hide('binaryPad'); showBlock('notePad');
    const set=setFromIndex(state.levelIndex);
    safe('btnOOB', el=> el.style.display = set>=12 ? 'none' : 'block');
  }
}
function nextSpecialTrial(){
  if(!special) return;
  const set=setFromIndex(state.levelIndex);
  const plusMinusTwoPitches = getPlusMinusTwoSemitones(special.targetPc);
  const isTarget = Math.random()<0.5;
  const pitchPc = isTarget ? special.targetPc : rand(plusMinusTwoPitches.filter(p => p !== special.targetPc));
  truePc = pitchPc; isOOBTrial = !isTarget;
  currentNote = `${pitchPc}${rand(currentOctaves())}`;
  playSample(currentNote);
  clearTimeout(rtTimer); rtTimer=null; // no RT in specials
  text('promptPill','Target or Other?');
  text('specialCount', `${special.done} / ${special.total}`);
}
function endSpecialOrAdvance(){
  if(!special) return;
  if(special.done >= special.total){
    if(special.mode==='A'){
      special = {mode:'B', targetPc: special.targetPc, total:22, done:0, withFeedback:false, correct:0};
      showSpecialUI(true, `Special B ‚Äî focus: ${pcLabel(special.targetPc)}`);
      text('btnTarget', `Target (${pcLabel(special.targetPc)})`);
      nextSpecialTrial();
    }else{
      const trials = (state.trials||[]).filter(t=> (t.special==='A' || t.special==='B') && t.pc===special.targetPc);
      const ok = trials.filter(t=> t.correct).length;
      const n  = trials.length;
      const pct = n ? Math.round((ok/n)*1000)/10 : 0;
      alert(`üéâ Hooray! You identified ${pcLabel(special.targetPc)} at ${pct}% accuracy.`);
      special = null; showSpecialUI(false);
      text('promptPill','Specials done ‚Äî press Play to continue');
      /* one-shot suppress strict modal after specials */
      suppressStrictOnce = true;
    }
  }
}
function answerSpecial(userSaysTarget){
  if(!special) return;
  const correct = (userSaysTarget && !isOOBTrial) || (!userSaysTarget && isOOBTrial);
  state.trials.push({note:currentNote, pc:truePc, guess:userSaysTarget?'TARGET':'OTHER', correct, timeout:false, oob:isOOBTrial, set:setFromIndex(state.levelIndex), block:0, time:Date.now(), special:special.mode});
  save();
  if(special.withFeedback){
    feedback(correct, correct ? undefined : (isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`));
  }
  if(correct) special.correct = (special.correct||0) + 1;
  special.done++; text('specialCount', `${special.done} / ${special.total}`);
  if(special.done >= special.total) { endSpecialOrAdvance(); return; }
  setTimeout(()=> nextSpecialTrial(), Math.max(500, delayMs));
}

/* ------------------ ASSESSMENT TEST ------------------ */
function startAssessment() {
  // Show warning modal first
  byId('assessmentWarningModal').style.display = 'flex';
}

function proceedWithAssessment() {
  // Hide warning modal and start assessment
  byId('assessmentWarningModal').style.display = 'none';
  
  showScreen('assessmentScreen');
  assessmentActive = false;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  text('assessmentProgress', 'Trial 0 / 20');
  text('assessmentPrompt', 'Press Start to begin assessment');
  hide('assessmentResults');
  
  populateAssessmentNotes();
}

function cancelAssessment() {
  byId('assessmentWarningModal').style.display = 'none';
}

function populateAssessmentNotes() {
  const pad = byId('assessmentPad');
  if (!pad) return;
  pad.innerHTML = '';
  
  for (const pc of PC) {
    const b = document.createElement('button');
    b.textContent = pcLabel(pc);
    b.dataset.pc = pc;
    b.className = 'note';
    b.type = 'button';
    b.addEventListener('click', () => assessmentGuess(pc));
    pad.appendChild(b);
  }
}

function beginAssessment() {
  assessmentActive = true;
  assessmentTrials = [];
  assessmentCurrentTrial = 0;
  
  // Generate 20 random trials with random audio types and pitches
  for (let i = 0; i < 20; i++) {
    const audioTypes = [AUDIO_TYPES.PIANO, AUDIO_TYPES.SINE, AUDIO_TYPES.GUITAR];
    const randomAudioType = rand(audioTypes);
    const randomPc = rand(PC);
    
    // Use octaves 3-5 for all audio types
    const octaves = [3, 4, 5];
    const randomOctave = rand(octaves);
    
    assessmentTrials.push({
      pc: randomPc,
      note: `${randomPc}${randomOctave}`,
      audioType: randomAudioType,
      answered: false,
      guess: null,
      correct: false
    });
  }
  
  nextAssessmentTrial();
}

async function nextAssessmentTrial() {
  if (assessmentCurrentTrial >= assessmentTrials.length) {
    completeAssessment();
    return;
  }
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  text('assessmentProgress', `Trial ${assessmentCurrentTrial + 1} / 20`);
  text('assessmentPrompt', 'Listening‚Ä¶ choose the pitch');
  
  // Temporarily change audio type for this trial
  const originalAudioType = state.audioType;
  state.audioType = trial.audioType;
  
  try {
    await playSample(trial.note);
  } finally {
    // Restore original audio type
    state.audioType = originalAudioType;
  }
}

function assessmentGuess(pc) {
  if (!assessmentActive || assessmentCurrentTrial >= assessmentTrials.length) return;
  
  const trial = assessmentTrials[assessmentCurrentTrial];
  if (trial.answered) return;
  
  trial.answered = true;
  trial.guess = pc;
  trial.correct = (pc === trial.pc);
  
  assessmentCurrentTrial++;
  
  // Small delay before next trial
  setTimeout(() => {
    if (assessmentCurrentTrial < assessmentTrials.length) {
      nextAssessmentTrial();
    } else {
      completeAssessment();
    }
  }, 800);
}

function completeAssessment() {
  assessmentActive = false;
  
  let correct = 0;
  let nearMiss = 0; // Within ¬±1 semitone
  
  for (const trial of assessmentTrials) {
    if (trial.correct) {
      correct++;
    } else if (trial.guess) {
      const targetIdx = PC2I[trial.pc];
      const guessIdx = PC2I[trial.guess];
      const distance = Math.min(
        Math.abs(targetIdx - guessIdx),
        12 - Math.abs(targetIdx - guessIdx)
      );
      if (distance <= 1) {
        nearMiss++;
      }
    }
  }
  
  const exactPercent = Math.round((correct / 20) * 100);
  const nearMissPercent = Math.round((nearMiss / 20) * 100);
  
  // Store result
  const result = {
    date: Date.now(),
    exact: exactPercent,
    nearMiss: nearMissPercent,
    trials: assessmentTrials.slice()
  };
  
  state.assessmentScores.push(result);
  save();
  
  // Show results in modal
  const modalStats = byId('modalAssessmentStats');
  if (modalStats) {
    modalStats.innerHTML = `
      <div style="font-size:18px;margin:8px 0">
        <div><strong>Exact Correct: ${exactPercent}%</strong> (${correct}/20)</div>
        <div>Within ¬±1 semitone: ${nearMissPercent}% (${nearMiss}/20)</div>
      </div>
    `;
  }
  
  // Show results modal
  byId('assessmentResultsModal').style.display = 'flex';
  
  // Update chart if possible
  try { drawChart(); } catch(_) {}
}

/* ------------------ ASSESSMENT TRACKER ------------------ */
function showTracker() {
  showScreen('trackerScreen');
  updateTrackerDisplay();
  drawTrackerChart();
}

function updateTrackerDisplay() {
  const scores = state.assessmentScores || [];
  const count = scores.length;
  text('trackerCount', `${count} assessment${count === 1 ? '' : 's'}`);
  
  const history = byId('trackerHistory');
  if (!history) return;
  
  if (count === 0) {
    history.innerHTML = '<p style="opacity:0.7;text-align:center">No assessments completed yet</p>';
    return;
  }
  
  // Sort by date (most recent first)
  const sortedScores = [...scores].sort((a, b) => b.date - a.date);
  
  let html = '';
  sortedScores.forEach((score, index) => {
    const date = new Date(score.date).toLocaleDateString();
    const time = new Date(score.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    html += `
      <div style="padding:8px;margin:4px 0;border-radius:8px;background:var(--muted2);display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>${date} ${time}</strong>
        </div>
        <div>
          <span style="color:var(--good)">Exact: ${score.exact}%</span> ‚Ä¢ 
          <span style="color:var(--accent)">¬±1: ${score.nearMiss}%</span>
        </div>
      </div>
    `;
  });
  
  history.innerHTML = html;
}

function drawTrackerChart() {
  const canvas = byId('trackerCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  
  const P = {l: 56, r: 24, t: 16, b: 28};
  const AX = P.l, AY = P.t, AW = W - P.l - P.r, AH = H - P.t - P.b;
  
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  const colMuted = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.fillStyle = colCard;
  ctx.fillRect(0, 0, W, H);
  
  const scores = state.assessmentScores || [];
  if (scores.length === 0) {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
    ctx.font = '14px Fredoka, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No assessment data yet', W / 2, H / 2);
    return;
  }
  
  // Sort by date
  const sortedScores = [...scores].sort((a, b) => a.date - b.date);
  
  const maxTests = Math.max(10, sortedScores.length);
  const xScale = (i) => AX + (i / (maxTests - 1)) * AW;
  const yScale = (pct) => AY + AH - (pct / 100) * AH;
  
  // Draw grid lines
  ctx.strokeStyle = colMuted;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 100; i += 20) {
    const y = yScale(i);
    ctx.beginPath();
    ctx.moveTo(AX, y);
    ctx.lineTo(AX + AW, y);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#334155';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(AX, AY);
  ctx.lineTo(AX, AY + AH);
  ctx.lineTo(AX + AW, AY + AH);
  ctx.stroke();
  
  // Draw Y-axis labels
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb';
  ctx.font = '12px Fredoka, sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 100; i += 20) {
    ctx.fillText(`${i}%`, AX - 8, yScale(i) + 4);
  }
  
  if (sortedScores.length > 1) {
    // Draw exact scores line
    const exactColor = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.beginPath();
    ctx.strokeStyle = exactColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.exact);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Draw near-miss scores line
    const nearMissColor = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.beginPath();
    ctx.strokeStyle = nearMissColor;
    ctx.lineWidth = 3;
    sortedScores.forEach((score, i) => {
      const x = xScale(i);
      const y = yScale(score.nearMiss);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }
  
  // Draw data points
  sortedScores.forEach((score, i) => {
    const x = xScale(i);
    
    // Exact score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.exact), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--good') || '#16a34a';
    ctx.fill();
    
    // Near-miss score point
    ctx.beginPath();
    ctx.arc(x, yScale(score.nearMiss), 4, 0, Math.PI * 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#fbbf24';
    ctx.fill();
  });
}

/* -------- Normal trials -------- */
function guess(pc){
  if(!sessionActive || paused || special) return;
  if(!currentNote){ return; }
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  const ok = (!isOOBTrial && pc === truePc);
  recordTrial(pc, ok, false, false);
  feedback(ok, ok ? undefined : (isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`));
  currentNote = null; // Clear currentNote to prevent repeated guesses
  advanceCheck();
  scheduleAuto();
}
function chooseOOB(){
  if(!sessionActive || paused || special) return;
  if(!currentNote) return;
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  const ok = isOOBTrial;
  recordTrial('OOB', ok, false, true);
  const msg = ok ? undefined : `Incorrect ‚Äî ${pcLabel(truePc)}`;
  feedback(ok, msg);
  currentNote = null; // Clear currentNote to prevent repeated guesses
  advanceCheck();
  scheduleAuto();
}

/* Driving */
function scheduleAuto(){ if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; } if(autoNext && sessionActive && !paused && !special){ autoTimer = setTimeout(()=> nextTrial(true), delayMs); } }
async function nextTrial(forceNew=false){
  if(!sessionActive || paused || special) return;
  if(inFlightTrial) return;

  /* clear the one-shot strict suppression as soon as normal play resumes */
  suppressStrictOnce = false;

  if(startSpecialAtBlock15()) return;

  inFlightTrial=true;
  try{
    await resumeCtx();
    if(paused || !sessionActive || special) return;
    if(!currentNote || forceNew){
      const set = setFromIndex(state.levelIndex);
      const usable = trainedSet(set);
      
      // Use enhanced OOB system
      isOOBTrial = shouldGenerateOOB(set);
      
      if (isOOBTrial) {
        const pc = selectOOBNote(set);
        truePc = pc;
      } else {
        // Apply confusion-aware scheduling for in-bounds
        const pc = selectInBoundsNote(usable);
        truePc = pc;
      }
      
      currentNote = `${truePc}${selectOctaveForNote(truePc)}`;
    }
    
    // Apply jitter system for in-bounds trials only
    let appliedJitter = 0;
    let isProbe = false;
    if (!isOOBTrial) {
      // Initialize jitter level for this note if needed
      initializeJitterLevel(truePc);
      
      // Check if this should be a boundary probe
      isProbe = shouldUseProbe(truePc);
      
      // Calculate jitter/probe amount
      appliedJitter = calculateJitter(truePc, isProbe);
      
      // Store jitter info for this trial
      currentTrialJitter = {
        jitter: appliedJitter,
        isProbe: isProbe,
        level: state.jitterLevels[truePc]
      };
    } else {
      // OOB trials have no jitter (0¬¢ detune, stationary)
      currentTrialJitter = {
        jitter: 0,
        isProbe: false,
        level: null
      };
    }
    
    await playSample(currentNote, appliedJitter);
    if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
    const baseRt = rtWindowForSet(setFromIndex(state.levelIndex));
    const rtms = baseRt + firstRtBonusMs + LATENCY_CUSHION_MS;
    firstRtBonusMs = 0;
    rtTimer = setTimeout(()=>handleTimeout(), rtms);
    text('promptPill','Listening‚Ä¶ choose the pitch');
  }catch(e){ report(e); }
  finally{ inFlightTrial=false; }
}
function handleTimeout(){
  if(!sessionActive || paused || special) return;
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  recordTrial(null,false,true);
  feedback(false, isOOBTrial ? 'Incorrect ‚Äî Out of Bounds' : `Incorrect ‚Äî ${pcLabel(truePc)}`);
  advanceCheck(); scheduleAuto();
}

/* Suggestion banner */
function hideSuggestBanner(){ hide('suggestBanner'); }
function showSuggestBanner(){ const set = setFromIndex(state.levelIndex); if(state.suggestShownSet === set) return; byId('suggestBanner').style.display='flex'; }
function restartCurrentSet(){
  const set = setFromIndex(state.levelIndex);
  state.levelIndex = (set-1)*LEVELS_PER_SET + 1;
  state.levelTrials = 0; state.levelCorrect = 0;
  state.testFailStreak = 0;
  state.suggestShownSet = null; save();
  updateLevelUI(); paintNotes();
  text('promptPill', `Restarted Set ${set}. Press Play to begin.`);
  hideSuggestBanner();
}
function maybeSuggestRestart(){
  const block = blockFromIndex(state.levelIndex);
  if(block < 21){ state.testFailStreak = 0; hideSuggestBanner(); suggestedRestartFlag=false; save(); return; }
  if(state.testFailStreak >= 10 && !suggestedRestartFlag){ suggestedRestartFlag = true; showSuggestBanner(); }
}

function recordTrial(guessLabel, ok, timeout=false, oobChosen=false){
  state.levelTrials++; if(ok) state.levelCorrect++;
  const block = blockFromIndex(state.levelIndex);
  if(block >= 21){ if(ok){ state.testFailStreak=0; hideSuggestBanner(); suggestedRestartFlag=false; } else { state.testFailStreak=(state.testFailStreak||0)+1; } }
  else { state.testFailStreak=0; hideSuggestBanner(); suggestedRestartFlag=false; }
  
  // Enhanced trial data with jitter information
  const trialData = {
    note: currentNote,
    pc: truePc,
    guess: guessLabel,
    correct: ok,
    timeout,
    oob: oobChosen,
    set: setFromIndex(state.levelIndex),
    block: block,
    time: Date.now(),
    jitter: currentTrialJitter,
    actualTimbre: currentTrialTimbre // Store which timbre was actually used
  };
  
  state.trials.push(trialData);
  
  // Update note statistics for in-bounds trials
  if (!isOOBTrial && truePc) {
    const centsError = currentTrialJitter ? currentTrialJitter.jitter : 0;
    updateNoteStats(truePc, ok, centsError);
    
    // Update timbre-specific statistics
    if (currentTrialTimbre) {
      updateTimbreStats(currentTrialTimbre, truePc, ok, centsError);
    }
    
    // Update confusion matrix if incorrect
    if (!ok && guessLabel !== 'OOB' && guessLabel !== truePc) {
      updateConfusionMatrix(truePc, guessLabel);
    }
  }
  
  // Record OOB trial data for adaptive system
  recordOOBTrial(isOOBTrial, ok);
  
  // Update octave mixing performance
  updateOctaveMixing(trialData);
  
  // Validate OOB state
  validateOOBState();
  
  save(); updateLevelUI(); try{ drawChart(); }catch(_){}; 
  if(block >= 21 && !ok) maybeSuggestRestart();
}

function feedback(ok, wrongMsgOverride){
  const fb=blockHasFeedback(blockFromIndex(state.levelIndex));
  if(!fb && !special?.withFeedback) return;
  const box=byId('feedbackBox'); const overlay=byId('feedbackOverlay');
  if(!box||!overlay) return;
  box.style.background= ok? 'var(--good)':'var(--bad)';
  if(ok) box.textContent = 'Correct!';
  else   box.textContent = wrongMsgOverride || 'Incorrect';
  overlay.style.display='flex'; requestAnimationFrame(()=>overlay.classList.add('show'));
  setTimeout(()=>{ overlay.classList.remove('show'); overlay.style.display='none'; }, 500);
}

function advanceCheck(){
  if(state.levelTrials<20) return;
  const acc=state.levelCorrect/state.levelTrials, need=thresholdForIndex(state.levelIndex);
  const passed = acc>=need;
  const block = blockFromIndex(state.levelIndex);
  const key = String(state.levelIndex);
  
  // Show feedback for test blocks (21-24) at completion
  if(block >= 21) {
    const percentage = Math.round(acc * 100);
    if(passed) {
      alert(`Well done, you passed with ${percentage}%!`);
    } else {
      // Suppress strict modal during failure dialogs
      suppressStrictOnce = true;
      alert(`Sorry you didn't make it with ${percentage}%.`);
      
      // Check for 10-fail streak and show struggle suggestion
      if(state.testFailStreak >= 10) {
        const confirmed = confirm(`Struggling? Perhaps go back to the start of set?\n\nClick OK to restart the set, or Cancel to dismiss and try again.`);
        if(confirmed) {
          restartCurrentSet();
          return;
        }
      }
      // Keep suppression active after dialogs
      suppressStrictOnce = true;
    }
  }
  
  if(!passed){
    state.levelFailCounts[key] = (state.levelFailCounts[key]||0) + 1;
    if(state.levelFailCounts[key] >= 10){
      if(confirm('You‚Äôve attempted this level 10+ times without passing. Drop to a lower level?')){
        if(state.levelIndex>1) state.levelIndex--;
        state.levelTrials=0; state.levelCorrect=0;
        save(); updateLevelUI(); paintNotes();
        alert('Dropped one level. Keep going!');
        return;
      }
    }
  }else{
    state.levelFailCounts[key]=0;
  }
  state.levelTrials=0; state.levelCorrect=0;
  
  // Track completed 6-minute block
  if(passed) {
    state.minutesToday += BLOCK_LEN_MIN;
  }
  
  // C) ADAPT OOB% ONLY AT BLOCK BOUNDARIES (every 3 blocks), using last 60 in-bounds
  if(passed && block % 3 === 0) {
    const last60 = (state.trials || []).filter(t => !t.oob).slice(-60);
    if (last60.length >= 30) {
      const acc = last60.reduce((a,t)=>a+(t.correct?1:0),0) / last60.length;
      let r = state.oobStats.adaptiveRate ?? 0.18;
      // Target 70‚Äì85% overall accuracy:
      if (acc > 0.85)      r = Math.min(0.35, r + 0.03); // +3pp harder
      else if (acc < 0.70) r = Math.max(0.05, r - 0.03); // -3pp easier
      state.oobStats.adaptiveRate = r;
    }
    state.oobStats.streakCount = 0; // reset at block boundary
    
    // Update health check block countdown
    if (state.oobStats.healthCheckActive && state.oobStats.healthCheckBlocks > 0) {
      state.oobStats.healthCheckBlocks--;
      if (state.oobStats.healthCheckBlocks <= 0) {
        state.oobStats.healthCheckActive = false;
      }
    }
  }

  if(passed && state.levelIndex<LEVELS_TOTAL){
    const oldSet = setFromIndex(state.levelIndex);
    state.levelIndex++;
    const newSet = setFromIndex(state.levelIndex);
    save(); updateLevelUI(); paintNotes();
    
    // Check if we're moving to a new set (new pitch introduced)
    if(newSet > oldSet && newSet <= UNLOCK_ORDER.length){
      showNewPitchModal(newSet);
    }
  } else save();
}

/* ------------------ SESSION ------------------ */
function startSession(){
  stopAllTimers();
  sealDanglingSession();
  if(isLocked()){
    const left = state.lockoutUntil - Date.now();
    alert(`Training is locked for ${fmtHMM(left)}.\nYou can still play Flappy from the menu, or Reset lockout/timer.`);
    showScreen('menuScreen'); return;
  }
  
  // Check if we need to do cold recall first
  const today = todayKey(Date.now());
  const lastColdRecall = state.recallResults
    .filter(r => r.type === 'cold')
    .map(r => todayKey(r.date))
    .pop();
  
  if (!lastColdRecall || lastColdRecall < today) {
    // Need to do cold recall first
    state.coldRecallDone = false;
    state.warmRecallDone = false;
    save();
    startRecallTest('cold');
    return;
  }
  
  // Go directly to training
  startTrainingDirectly();
}

function startTrainingDirectly(){
  // Start the training session directly
  sessionActive = true;
  paused = false;
  
  // Create new session record
  const sessionRecord = {
    start: Date.now(),
    end: null,
    pauses: []
  };
  
  state.sessions = state.sessions || [];
  state.sessions.push(sessionRecord);
  
  // Set up break timing
  state.sessionBreakTime = Date.now() + BREAK_INTERVAL_MS;
  state.inBreak = false;
  save();
  
  // Show trainer screen and start
  showScreen('trainerScreen');
  updateLevelUI();
  initializeTooltips();
  paintNotes();
  text('promptPill', 'Session started ‚Äî press Play to begin training');
  
  // Start session timer that checks for breaks and cap
  startSessionTimer();
}

function startSessionTimer(){
  if(tickId) clearInterval(tickId);
  
  tickId = setInterval(() => {
    if(!sessionActive || paused) return;
    
    const now = Date.now();
    const usedMs = msUsedQuota();
    
    // Check if we've hit the daily cap
    if(usedMs >= SESS_DAILY_MS) {
      clearInterval(tickId);
      tickId = null;
      
      // Set lockout until next calendar day
      state.lockoutUntil = nextMidnight(now);
      save();
      
      endSession(true);
      return;
    }
    
    // Check if we need a mandatory break
    if(!state.inBreak && now >= state.sessionBreakTime) {
      triggerMandatoryBreak();
      return;
    }
    
    // Update timer display
    const left = Math.max(0, SESS_DAILY_MS - usedMs);
    textWithTooltip('timerInfo', `Time left: ${fmtMMSS(left)}`);
    
    // Update training chunk display
    if(!state.inBreak) {
      const chunkUsedMs = usedMs % BREAK_INTERVAL_MS;
      const chunkLeft = Math.max(0, BREAK_INTERVAL_MS - chunkUsedMs);
      const currentChunk = Math.floor(usedMs / BREAK_INTERVAL_MS) + 1;
      const totalChunks = Math.ceil(SESS_DAILY_MS / BREAK_INTERVAL_MS);
      textWithTooltip('chunkInfo', `Training: ${fmtMMSS(chunkLeft)} (${currentChunk}/${totalChunks})`);
    }
    
  }, 1000); // Update every second
}

function endSession(auto){
  if(!sessionActive) return;
  sessionActive=false;
  stopAllTimers();
  
  // Clear trial state
  currentNote = null;
  currentTrialJitter = null;
  currentTrialTimbre = null;
  
  const rec=state.sessions[state.sessions.length-1]; if(rec && !rec.end) rec.end=Date.now();
  save(); updateCapsUI(); try{ drawChart(); }catch(_){};
  
  if(auto){
    // Session completed naturally (30 minutes reached)
    if(!state.warmRecallDone) {
      // Trigger warm recall test
      startRecallTest('warm');
      return;
    } else {
      const left = state.lockoutUntil ? fmtHMM(state.lockoutUntil - Date.now()) : 'some time';
      alert(`Training session complete! Come back tomorrow for your next session.`);
      showScreen('menuScreen');
    }
  } else {
    // Manual session end
    showScreen('menuScreen');
  }
}
function pauseStart(reason){
  const rec=state.sessions[state.sessions.length-1]; if(!rec) return;
  rec.pauses=rec.pauses||[]; const last=rec.pauses[rec.pauses.length-1];
  if(!(last && !last.end)) rec.pauses.push({start:Date.now(), end:null, reason});
  paused=true;
  if(rtTimer){ clearTimeout(rtTimer); rtTimer=null; }
  if(autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
  
  // Stop session timer when paused
  if(tickId){ clearInterval(tickId); tickId=null; }
}
function pauseEnd(){
  const rec=state.sessions[state.sessions.length-1]; if(!rec||!rec.pauses||!rec.pauses.length) return;
  const last=rec.pauses[rec.pauses.length-1]; if(last && !last.end) last.end=Date.now();
  paused=false;
  
  // Restart session timer when unpaused
  if(sessionActive) startSessionTimer();
}
function pauseResume(){
  if(!sessionActive) return;
  if(paused){ pauseEnd(); safe('btnPause', el=> el.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else if(currentNote){ nextTrial(false); } }
  else { safe('btnPause', el=> el.textContent='‚ñ∂ Resume'); pauseStart('user'); }
}

/* ------------------ QUOTA ------------------ */
function quotaStart(){ if(state.capResetAt && Date.now() >= state.capResetAt) return state.capResetAt; const d = new Date(); d.setHours(0,0,0,0); return d.getTime(); }
function msUsedQuota(){ const start = quotaStart(); return (state.sessions || []).filter(s => s.start >= start).reduce((a, s) => a + activeDuration(s), 0); }

/* ------------------ PROGRESS / CHARTS ------------------ */
function eightWeekBins(pitch){
  const t0=todayKey(Date.now());
  const bins=[];
  for(let w=1; w<=8; w++){ const start=t0 - (w-1)*7*86400000; const end=start+7*86400000; bins.push({w,start,end,n:0,ok:0}); }
  const oldest=bins[7].start;
  const trials=(state.trials||[]).filter(tr=>{
    const d=dateAtMidnight(tr.time);
    return d>=oldest && d<bins[0].end && (pitch==='OVERALL'|| tr.pc===pitch);
  });
  for(const tr of trials){
    const d=dateAtMidnight(tr.time);
    const daysAgo=Math.floor((t0 - d)/86400000);
    const w=Math.floor(daysAgo/7)+1;
    const idx=Math.min(8,Math.max(1,w))-1;
    const b=bins[idx]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function thisWeekBins(pitch){
  const ws = weekStartTs();
  const bins=[];
  for(let i=0;i<7;i++){ bins.push({day:i+1,start:ws+i*86400000,end:ws+(i+1)*86400000,n:0,ok:0}); }
  const trials=(state.trials||[]).filter(tr=> tr.time>=ws && tr.time<ws+7*86400000 && (pitch==='OVERALL'|| tr.pc===pitch));
  for(const tr of trials){
    const day = Math.floor((dateAtMidnight(tr.time) - ws)/86400000);
    const b = bins[Math.max(0, Math.min(6, day))]; b.n++; if(tr.correct) b.ok++;
  }
  return bins;
}
function drawLine(ctx, pts, color, xscale, yscale){ ctx.beginPath(); let started=false; for(const p of pts){ if(p.y===null) continue; const x=xscale(p.x), y=yscale(p.y); if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y); } if(!started) return; ctx.strokeStyle=color; ctx.lineWidth=2.5; ctx.stroke(); }
function drawDot(ctx, x, y, color, r=6){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); }
function drawChart(){
  const canvas = byId('progressCanvas'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  const P={l:56,r:24,t:16,b:28}; const AX=P.l, AY=P.t, AW=W-P.l-P.r, AH=H-P.t-P.b;
  const colCard = getComputedStyle(document.documentElement).getPropertyValue('--card') || '#1e293b';
  ctx.fillStyle=colCard; ctx.fillRect(0,0,W,H);
  const mode=byId('granularitySelect')?.value||'WEEKLY';
  const pitch=byId('pitchSelect')?.value||'OVERALL';
  const colGood=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a';
  const colNeutral=getComputedStyle(document.documentElement).getPropertyValue('--neutral')||'#94a3b8';
  const colMuted=getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#334155';
  const colText=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb';
  const yscale=(v)=> AY + AH - (v/100)*AH;

  /* Y grid + labels */
  ctx.strokeStyle=colMuted; ctx.lineWidth=1; ctx.beginPath();
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy); ctx.moveTo(AX,y); ctx.lineTo(AX+AW,y);} ctx.stroke();
  ctx.fillStyle=colText; ctx.font='12px system-ui,sans-serif';
  for(let gy=0; gy<=100; gy+=20){ const y=yscale(gy)+4; ctx.fillText(String(gy)+'%', 8, y); }

  if(mode==='WEEKLY'){
    const bins=thisWeekBins(pitch);
    const xscale=(d)=> AX + ((d - 1)/(7 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let d=1; d<=7; d++){ const x=xscale(d); ctx.fillText(`Day ${d}`, x-18, H-6); }
    const pts=bins.map(b=> b.n===0? {x:b.day,y:null}:{x:b.day,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const b of bins){
      if(b.n>0) drawDot(ctx,xscale(b.day), yscale(Math.round((b.ok/b.n)*1000)/10), colGood, 6);
      else      drawDot(ctx,xscale(b.day), yscale(0), colNeutral, 5);
    }
  } else {
    const weeks=eightWeekBins(pitch);
    const xscale=(w)=> AX + ((w - 1)/(8 - 1))*AW;
    ctx.strokeStyle=colMuted; ctx.beginPath();
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.moveTo(x,AY); ctx.lineTo(x,AY+AH);} ctx.stroke();
    ctx.fillStyle=colText;
    for(let w=1; w<=8; w++){ const x=xscale(w); ctx.fillText(`Week ${w}`, x-22, H-6); }
    const pts=weeks.map(b=> b.n===0? {x:b.w,y:null}:{x:b.w,y:Math.round((b.ok/b.n)*1000)/10});
    const accPts=pts.filter(p=> p.y!==null);
    drawLine(ctx,accPts,colGood,xscale,yscale);
    for(const p of weeks){
      if(p.n>0) drawDot(ctx,xscale(p.w), yscale(Math.round((p.ok/p.n)*1000)/10), colGood, 5);
      else      drawDot(ctx,xscale(p.w), yscale(0), colNeutral, 4);
    }
  }
  ctx.fillStyle=colText; ctx.font='13px system-ui,sans-serif';
  const label=(pitch==='OVERALL')?'Overall':`Pitch: ${pcLabel(pitch)}`;
  ctx.fillText(label, AX, AY-2);
}

/* Pitch dropdown + view toggle */
function populatePitchSelect(){
  const sel = byId('pitchSelect'); if(!sel) return;
  sel.innerHTML='';
  const mk=(v,t)=>{ const o=document.createElement('option'); o.value=v; o.textContent=t; return o; };
  sel.appendChild(mk('OVERALL','Overall'));
  PC.forEach(pc=> sel.appendChild(mk(pc, pcLabel(pc))));
  sel.onchange = ()=> drawChart();
  const gran = byId('granularitySelect'); if(gran){ gran.onchange = ()=> drawChart(); gran.value='WEEKLY'; }
}

/* ------------------ TUTORIAL PAGER ------------------ */
let tIndex = 0;
function setTutorialPage(i){
  tIndex = Math.max(0, Math.min(5, i));
  ['tPage1','tPage2','tPage3','tPage4','tPage5','tPage6'].forEach((id, idx)=>{
    const el = byId(id);
    if(el) el.classList.toggle('active', idx===tIndex);
  });
  const back = byId('tBack'); if(back) back.style.visibility = (tIndex===0 ? 'hidden' : 'visible');
  const next = byId('tNext'); if(next) next.textContent = (tIndex===5 ? 'Got it' : 'Next ‚ñ∂');
}
function nextTutorial(){ if(tIndex<5){ setTutorialPage(tIndex+1); return; } hide('welcomeModal'); showScreen('menuScreen'); updateCapsUI(); populatePitchSelect(); drawChart(); }
function prevTutorial(){ setTutorialPage(tIndex-1); }

/* ------------------ WIRING ------------------ */
function wireOnce(){
  sealDanglingSession();
  try{ populatePitchSelect(); drawChart(); }catch(_){}
  // Start
  safe('startBtn', el=> el.onclick=()=>{
    const name=(byId('userNameInput')?.value||'').trim()||'Player';
    state.userName=name; save();
    safe('greeting', g=> g.textContent=`Hello ${state.userName}!`);
    showFlex('welcomeModal'); setTutorialPage(0);
  });
  safe('tNext', el=> el.onclick=()=> nextTutorial());
  safe('tBack', el=> el.onclick=()=> prevTutorial());

  // Menu
  safe('menuStart',   el=> el.onclick=()=> startSession());
  safe('startAssessment', el=> el.onclick=()=> startAssessment());
  safe('viewTracker', el=> el.onclick=()=> showTracker());
  safe('playFlappy',  el=> el.onclick=()=> openFlappyFromMenu());
  safe('resetLockout',el=> el.onclick=()=>{
    if(!confirm('Reset lockout/timer now? This starts a fresh 30-minute window immediately.')) return;
    state.lockoutUntil = null; state.capResetAt = Date.now(); state.lastSeen = Date.now();
    save(); updateCapsUI(); alert('Timer reset. You can start training now.');
  });
  safe('menuReset',   el=> el.onclick=()=> doFactoryReset());

  // Assessment warning modal
  safe('btnProceedAssessment', el=> el.onclick=()=> proceedWithAssessment());
  safe('btnCancelAssessment', el=> el.onclick=()=> cancelAssessment());
  
  // Assessment results modal
  safe('btnRetakeAssessmentModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    proceedWithAssessment();
  });
  safe('btnBackMenuModal', el=> el.onclick=()=> {
    byId('assessmentResultsModal').style.display = 'none';
    showScreen('menuScreen'); 
    populatePitchSelect(); 
    drawChart();
  });

  // Assessment screen
  safe('btnStartAssessment', el=> el.onclick=()=> beginAssessment());
  safe('btnBackMenuAssessment', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });
  safe('btnRetryAssessment', el=> el.onclick=()=> { hide('assessmentResults'); beginAssessment(); });
  safe('btnBackMenuFromResults', el=> el.onclick=()=> { assessmentActive=false; showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Tracker screen
  safe('btnBackMenuTracker', el=> el.onclick=()=> { showScreen('menuScreen'); populatePitchSelect(); drawChart(); });

  // Set selector
  safe('setSizeSelect', sel=>{
    if(!sel.options.length){
      for(let i=1;i<=SETS;i++){
        const o=document.createElement('option');
        o.value=i; o.textContent=`${i} ${i===1?'pitch':'pitches'}`;
        sel.appendChild(o);
      }
    }
    sel.value = String(setFromIndex(state.levelIndex));
  });
  safe('applySetBtn', el=> el.onclick=()=>{
    const v = parseInt(byId('setSizeSelect')?.value||'1',10)||1;
    state.levelIndex=(v-1)*LEVELS_PER_SET+1; state.levelTrials=0; state.levelCorrect=0; state.testFailStreak=0; suggestedRestartFlag=false; state.suggestShownSet=null; save();
    alert(`Scope set to ${v} ${v===1?'pitch':'pitches'} (Block 1/24)`); paintNotes();
  });

  // Audio type selection
  safe('audioTypeSelect', el=> {
    el.value = state.audioType || AUDIO_TYPES.PIANO;
  });
  safe('applyAudioBtn', el=> el.onclick=()=>{
    const newType = byId('audioTypeSelect')?.value || AUDIO_TYPES.PIANO;
    state.audioType = newType;
    save();
    const labels = {
      [AUDIO_TYPES.PIANO]: 'Piano (C3-C5)',
      [AUDIO_TYPES.SINE]: 'Sine Wave (C3-C5)', 
      [AUDIO_TYPES.GUITAR]: 'Guitar (C3-C5)'
    };
    alert(`Audio changed to ${labels[newType] || 'Piano'}`);
  });

  // Variety mode toggle
  safe('varietyModeToggle', el=> {
    el.checked = state.varietyModeEnabled || false;
    el.onchange = ()=> {
      state.varietyModeEnabled = el.checked;
      updateVarietyModeUI();
      save();
    };
  });
  
  safe('varietyInfoBtn', el=> el.onclick=()=>{
    const explanation = `Variety Mode adds timbre diversity to your training:

‚Ä¢ Weeks 1-2: 100% your chosen audio type (faster early learning)
‚Ä¢ Week 3+: 80% chosen type, 20% rotating alternate type
‚Ä¢ Changes daily to prevent over-adaptation
‚Ä¢ Weak notes get extra practice in struggling timbres
‚Ä¢ Helps build robust pitch recognition across instruments`;
    
    alert(explanation);
  });
  
  updateVarietyModeUI();

  // Debug toggle - only show if DEV_UI is enabled
  if (DEV_UI) {
    safe('debugToggle', el=> {
      el.style.display = 'inline-block';
      el.onclick=()=>{
        const panel = byId('debugPanel');
        if(panel.style.display === 'none') {
          panel.style.display = 'block';
          updateDebugInfo();
          el.textContent = 'Hide Debug';
        } else {
          panel.style.display = 'none';
          el.textContent = 'Debug';
        }
      };
    });
  }

  // Theme selection
  safe('themeSelect', el=> {
    el.value = state.theme || 'default';
  });
  safe('applyThemeBtn', el=> el.onclick=()=>{
    const newTheme = byId('themeSelect')?.value || 'default';
    state.theme = newTheme;
    save();
    applyTheme(newTheme);
    const themeName = THEMES[newTheme]?.name || 'Dark Ocean';
    alert(`Theme changed to ${themeName}`);
  });

  // Trainer controls
  safe('btnPlay',        el=> el.onclick=async()=>{ firstRtBonusMs=2000; await resumeCtx(); if(paused){ pauseEnd(); } safe('btnPause', b=> b.textContent='‚è∏ Pause'); if(special) nextSpecialTrial(); else nextTrial(true); });
  safe('btnPause',       el=> el.onclick=()=> pauseResume());
  safe('btnBackMenu',    el=> el.onclick=()=>{
    if(sessionActive){ if(!paused) pauseStart('user-leave'); openStrictModal(); }
    else { showScreen('menuScreen'); populatePitchSelect(); drawChart(); }
  });
  safe('btnToggleAuto',  el=> el.onclick=()=>{
    autoNext=!autoNext; textWithTooltip('autoInfo',`Auto-next: ${autoNext?'On':'Off'}`);
    const sl=byId('delaySlider'); if(sl){ sl.disabled=!autoNext; sl.classList.toggle('disabled', !autoNext); }
    if(!autoNext && autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
  });
  safe('delaySlider', sl=>{
    sl.disabled=true; sl.classList.add('disabled');
    sl.oninput=(e)=>{ delayMs=parseInt(e.target.value,10)||0; updateLevelUI(); };
  });

  // Specials
  safe('btnTarget',el=> el.onclick=()=> answerSpecial(true));
  safe('btnOther', el=> el.onclick=()=> answerSpecial(false));

  // Strict modal buttons
  safe('btnStrictResume', el=> el.onclick=()=>{ closeStrictModal(); showScreen('trainerScreen'); initializeTooltips(); });
  safe('btnStrictMenu',   el=> el.onclick=()=>{ closeStrictModal(); showScreen('menuScreen'); });

  // New pitch modal buttons
  safe('btnHearNewPitch', el=> el.onclick=async()=>{ 
    const pitch = UNLOCK_ORDER[setFromIndex(state.levelIndex) - 1];
    await playNewPitchDemo(pitch); 
  });
  safe('btnContinueTraining', el=> el.onclick=()=>{ 
    closeNewPitchModal(); 
    startFlappyReward(); 
  });

  // Recall modal buttons
  safe('btnStartRecording', el=> el.onclick=()=> startRecallRecording());
  safe('btnStopRecording', el=> el.onclick=()=> stopRecallRecording());
  safe('btnSkipRecall', el=> el.onclick=()=> skipRecallTest());
  safe('btnNextRecall', el=> el.onclick=()=> nextRecallNote());
  safe('btnFinishRecall', el=> el.onclick=()=> finishRecallTest());

  // Initial screen
  if(!state.userName){ showScreen('startScreen'); }
  else { safe('greeting', g=> g.textContent=`Hello ${state.userName}!`); showScreen('menuScreen'); updateCapsUI(); }
}

/* ------------------ FLAPPY ------------------ */
let fCtx, flappyRAF=null, running=false, score=0, pipes=[], bird, pipeTimer=0, lastTs=null;

/* Flappy now: start with bigger gap, shrink over first 5 pipes, then keep constant.
   Speed still scales with score. */
const FLAPPY = { gravity:900, flap:-380, baseSpeed:140, maxSpeed:260, speed:140, baseGap:140, gap:140, introPipes:5, introExtra:60, spawnEvery:1.20, width:52 };

function openFlappyFromMenu(){ if(isLocked()) openFlappyModal(); else alert('Flappy is intended for lockout/rewards.'); }

/* Mandatory Break System */
function triggerMandatoryBreak(){
  if(!sessionActive || state.inBreak) return;
  
  // Pause the session and start break
  if(!paused) pauseStart('mandatory-break');
  state.inBreak = true;
  state.lastBreakTime = Date.now();
  
  // Schedule next break in 6 minutes from now
  state.sessionBreakTime = Date.now() + BREAK_INTERVAL_MS;
  save();
  
  // Hide training chunk display during break
  const chunkEl = byId('chunkInfo');
  if(chunkEl) chunkEl.textContent = 'Break in progress...';
  
  // Show Flappy with lockout sound (always enabled during mandatory breaks)
  openMandatoryBreakFlappy();
}

function openMandatoryBreakFlappy(){
  byId('flappyModal').style.display='flex'; 
  const c=byId('flappyCanvas'); 
  if(!c) return; 
  fCtx=c.getContext('2d'); 
  resetFlappy(); 
  attachFlappyControls();
  
  // Update UI to show this is a mandatory break
  const modalTitle = byId('flappyModal').querySelector('h3');
  if(modalTitle) modalTitle.textContent = '‚è±Ô∏è Mandatory 60s Break';
  
  // Show sound toggle and set appropriate description
  const soundToggle = byId('flappySoundToggle');
  const description = byId('flappyModal').querySelector('p:last-child');
  if (soundToggle) {
    soundToggle.style.display = 'inline-block';
    soundToggle.textContent = state.flappySoundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
  }
  if (description) {
    description.textContent = 'Mandatory 60-second break. Tap/click (or Space) to flap ‚Äî each flap makes a flappy sound.';
  }
  
  // Start the break timer
  startBreakTimer();
}

function startBreakTimer(){
  // Show countdown display
  const countdownEl = byId('breakCountdown');
  if(countdownEl) countdownEl.style.display = 'block';
  
  const startTime = Date.now();
  
  // Update countdown every second
  const countdownInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const remaining = Math.max(0, BREAK_DURATION_MS - elapsed);
    const seconds = Math.ceil(remaining / 1000);
    
    if(countdownEl) {
      countdownEl.textContent = `Break ends in: ${seconds}s`;
    }
    
    if(remaining <= 0) {
      clearInterval(countdownInterval);
    }
  }, 1000);
  
  // Force close after 60 seconds minimum, but allow game to continue if in progress
  setTimeout(() => {
    clearInterval(countdownInterval);
    if(countdownEl) countdownEl.style.display = 'none';
    
    if(state.inBreak) {
      // Check if user is still playing - if so, let them finish their current game
      if(running && bird && bird.y > 0 && bird.y < byId('flappyCanvas')?.height) {
        // Game is active, wait for it to end naturally
        const checkGameEnd = setInterval(() => {
          if(!running) {
            clearInterval(checkGameEnd);
            endMandatoryBreak();
          }
        }, 100);
      } else {
        // Game not active or already ended, close immediately
        endMandatoryBreak();
      }
    }
  }, BREAK_DURATION_MS);
}

function endMandatoryBreak(){
  if(!state.inBreak) return;
  
  // Store minutesToday before break ends to verify it doesn't change
  const minutesTodayBeforeBreak = state.minutesToday;
  
  // Close Flappy
  running = false;
  cancelAnimationFrame(flappyRAF);
  byId('flappyModal').style.display = 'none';
  detachFlappyControls();
  
  // Reset modal title
  const modalTitle = byId('flappyModal').querySelector('h3');
  if(modalTitle) modalTitle.textContent = 'üê§ Flappy Break';
  
  // Hide break countdown
  const countdownEl = byId('breakCountdown');
  if(countdownEl) countdownEl.style.display = 'none';
  
  // End break state and schedule next break
  state.inBreak = false;
  state.sessionBreakTime = Date.now() + BREAK_INTERVAL_MS; // Next break in 6 minutes
  save();
  
  // Console assert that minutesToday is unchanged during break
  console.assert(state.minutesToday === minutesTodayBeforeBreak, 
    `minutesToday changed during break: before=${minutesTodayBeforeBreak}, after=${state.minutesToday}`);
  
  // Resume session
  if(sessionActive) {
    pauseEnd();
    safe('btnPause', el=> el.textContent='‚è∏ Pause');
    currentNote = null;
    clearTimeout(rtTimer); rtTimer = null;
    clearTimeout(autoTimer); autoTimer = null;
    text('promptPill', 'Break over ‚Äî press Play to continue');
  }
}
function openFlappyModal(){ 
  byId('flappyModal').style.display='flex'; 
  const c=byId('flappyCanvas'); 
  if(!c) return; 
  fCtx=c.getContext('2d'); 
  resetFlappy(); 
  attachFlappyControls();
  
  // Show sound toggle button and update description when in lockout
  const soundToggle = byId('flappySoundToggle');
  const description = byId('flappyModal').querySelector('p:last-child');
  if (isLocked()) {
    if (soundToggle) {
      soundToggle.style.display = 'inline-block';
      soundToggle.textContent = state.flappySoundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
    }
    if (description) {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap makes a flappy sound.';
    }
  } else {
    if (soundToggle) soundToggle.style.display = 'none';
    if (description) {
      description.textContent = 'Tap/click (or Space) to flap. First tap starts ‚Äî each flap plays a random pitch.';
    }
  }
}
function startFlappyReward(){ if(sessionActive && !paused){ pauseStart('flappy'); } clearTimeout(rtTimer); rtTimer=null; clearTimeout(autoTimer); autoTimer=null; openFlappyModal(); }
function closeFlappy(){
  running=false; cancelAnimationFrame(flappyRAF); byId('flappyModal').style.display='none'; detachFlappyControls();
  if(score > (state.flappyHighScore||0)){ state.flappyHighScore = score; save(); }
  if(sessionActive){
    safe('btnPause', el=> el.textContent='‚ñ∂ Resume');
    currentNote=null; clearTimeout(rtTimer); rtTimer=null; clearTimeout(autoTimer); autoTimer=null;
    text('promptPill','Flappy over ‚Äî press Play to continue');
  }
}
function resetFlappy(){ const cnv=byId('flappyCanvas'); if(!cnv) return; bird={x:60,y:cnv.height/2,vy:0,wing:0}; pipes=[]; score=0; pipeTimer=0; lastTs=null; FLAPPY.speed=FLAPPY.baseSpeed; FLAPPY.gap=FLAPPY.baseGap + FLAPPY.introExtra; FLAPPY.introPipes=5; text('flappyScore',`Score: 0 ‚Ä¢ Best: ${state.flappyHighScore||0}`); }
function flap(){ 
  bird.vy = FLAPPY.flap; 
  
  // Use flappy sound for lockout or mandatory breaks, musical pitches otherwise
  if (state.flappySoundEnabled && (isLocked() || state.inBreak)) {
    playFlappySound();
  } else if (state.flappySoundEnabled && !isLocked() && !state.inBreak) {
    // Regular flappy bird with musical pitches
    const pc = rand(PC); 
    const note = `${pc}${rand(currentOctaves())}`; 
    playSample(note);
  }
}
function progressiveDifficulty(){ // only speed scales; gap remains constant after intro
  const target = FLAPPY.baseSpeed + Math.min(Math.floor(score/5)*18, FLAPPY.maxSpeed - FLAPPY.baseSpeed);
  FLAPPY.speed = target;
}
function drawBird(){ const ctx=fCtx; if(!ctx) return; const body=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#fbbf24'; const wingCol=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; const outline=getComputedStyle(document.documentElement).getPropertyValue('--bg')||'#0f172a';
  ctx.save();
  const tilt=Math.max(-0.6,Math.min(0.6,bird.vy/380)); ctx.translate(bird.x,bird.y); ctx.rotate(tilt);
  ctx.fillStyle=body; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--text')||'#e5e7eb'; ctx.beginPath(); ctx.arc(3,-4,3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=outline; ctx.beginPath(); ctx.arc(4,-4,1.5,0,Math.PI*2); ctx.fill();
  bird.wing+=0.25; const wing=Math.sin(bird.wing)*0.9; ctx.save(); ctx.rotate(wing);
  ctx.fillStyle=wingCol; ctx.beginPath(); ctx.moveTo(-2,2); ctx.quadraticCurveTo(-16,4,-8,12); ctx.quadraticCurveTo(0,10,-2,2); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.restore();
  ctx.restore();
}
function drawPipes(){ const ctx=fCtx; if(!ctx) return; const col=getComputedStyle(document.documentElement).getPropertyValue('--good')||'#16a34a'; ctx.fillStyle=col; const cnv=byId('flappyCanvas'); if(!cnv) return; for(const p of pipes){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; ctx.fillRect(p.x,0,FLAPPY.width,topH); ctx.fillRect(p.x,bottomY,FLAPPY.width,cnv.height-bottomY); } }
function spawnPipe(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const h=cnv.height, m=40;

  // intro ramp: linearly reduce gap to baseGap across first 5 pipes
  if(FLAPPY.introPipes > 0){
    const k = FLAPPY.introPipes; // 5..1
    const extraNow = Math.round(FLAPPY.introExtra * (k/5));
    FLAPPY.gap = FLAPPY.baseGap + extraNow;
    FLAPPY.introPipes--;
    if(FLAPPY.introPipes === 0) FLAPPY.gap = FLAPPY.baseGap; // lock it
  }

  const gapY=Math.max(m,Math.min(h-m-FLAPPY.gap,Math.random()*(h-FLAPPY.gap-2*m)))+FLAPPY.gap/2;
  pipes.push({x: cnv.width, gapY: gapY, passed:false});
}
function step(ts){
  if(!running) return;
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  if(lastTs===null) lastTs = ts;
  let dt = (ts - lastTs) / 1000; if(dt > 0.033) dt = 0.033; lastTs = ts;
  bird.vy += FLAPPY.gravity * dt; bird.y  += bird.vy * dt;
  pipeTimer -= dt; if(pipeTimer <= 0){ pipeTimer += FLAPPY.spawnEvery; spawnPipe(); }
  for(const p of pipes){ p.x -= FLAPPY.speed * dt; }
  for(const p of pipes){ if(!p.passed && p.x + FLAPPY.width < bird.x){ p.passed = true; score++; progressiveDifficulty(); text('flappyScore',`Score: ${score} ‚Ä¢ Best: ${state.flappyHighScore||0}`); } }
  pipes = pipes.filter(p=> p.x + FLAPPY.width > 0);
  fCtx.clearRect(0,0,cnv.width,cnv.height); drawPipes(); drawBird();
  if(bird.y < 0 || bird.y > cnv.height){ return closeFlappy(true); }
  for(const p of pipes){ if(bird.x+10>p.x && bird.x-10<p.x+FLAPPY.width){ const topH=p.gapY-FLAPPY.gap/2, bottomY=p.gapY+FLAPPY.gap/2; if(bird.y-10<topH || bird.y+10>bottomY){ return closeFlappy(true); } } }
  flappyRAF = requestAnimationFrame(step);
}
let _flHandlers=null;
function attachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!cnv) return;
  const startOrFlap = () => { if(!running){ running=true; resetFlappy(); flappyRAF=requestAnimationFrame(step); } else { flap(); } };
  const onCanvasClick  = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onTouchStart   = (e)=>{ e.preventDefault(); startOrFlap(); };
  const onKey          = (e)=>{ if(e.code==='Space'){ e.preventDefault(); startOrFlap(); } };
  const onClose        = ()=> closeFlappy(false);
  cnv.addEventListener('click', onCanvasClick);
  cnv.addEventListener('touchstart', onTouchStart, { passive:false });
  window.addEventListener('keydown', onKey);
  safe('flappyClose', el=> el.onclick=onClose);
  safe('flappySoundToggle', el=> el.onclick=()=> {
    state.flappySoundEnabled = !state.flappySoundEnabled;
    save();
    el.textContent = state.flappySoundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
  });
  _flHandlers={onCanvasClick,onTouchStart,onKey,onClose};
}
function detachFlappyControls(){
  const cnv=byId('flappyCanvas'); if(!_flHandlers||!cnv) return;
  cnv.removeEventListener('click', _flHandlers.onCanvasClick);
  cnv.removeEventListener('touchstart', _flHandlers.onTouchStart);
  window.removeEventListener('keydown', _flHandlers.onKey);
  safe('flappyClose', el=> el.onclick=null);
  safe('flappySoundToggle', el=> el.onclick=null);
}

/* ------------------ STRICT MODAL + NAV GUARDS ------------------ */
let strictModalPending=false;
function openStrictModal(){ if(suppressStrictOnce){ suppressStrictOnce=false; return; } showFlex('strictModal'); setTimeout(()=> byId('btnStrictResume')?.focus(), 0); }
function closeStrictModal(){ hide('strictModal'); strictModalPending=false; }

/* New Pitch Modal */
function showNewPitchModal(setNumber){
  const newPitch = UNLOCK_ORDER[setNumber - 1];
  text('newPitchName', pcLabel(newPitch));
  showFlex('newPitchModal');
  setTimeout(()=> byId('btnHearNewPitch')?.focus(), 0);
}
function closeNewPitchModal(){
  hide('newPitchModal');
}
async function playNewPitchDemo(pitch){
  try{
    await resumeCtx();
    const octaves = currentOctaves();
    
    // Play the pitch slowly across all three octaves
    for(let i = 0; i < octaves.length; i++){
      const note = `${pitch}${octaves[i]}`;
      await playSample(note);
      // Wait 1.2 seconds between notes for slow demonstration  
      await new Promise(resolve => setTimeout(resolve, 1200));
    }
  }catch(e){
    report(e);
  }
}
function reconcileAwayTime(){
  const now = Date.now();
  const rec = (state.sessions||[])[(state.sessions||[]).length - 1];
  if(rec && rec.pauses && rec.pauses.length){
    const openPause = rec.pauses[rec.pauses.length-1];
    if(openPause && !openPause.end){ openPause.end = now; save(); }
  }
  state.lastSeen = now; save();
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden && sessionActive && !paused){ pauseStart('hidden'); strictModalPending = true; }
  if(!document.hidden){ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; }
});
window.addEventListener('blur', ()=>{ if(sessionActive && !paused){ pauseStart('blur'); strictModalPending = true; } });
window.addEventListener('focus', ()=>{ reconcileAwayTime(); if(strictModalPending && !suppressStrictOnce) openStrictModal(); strictModalPending=false; });
window.addEventListener('pagehide', ()=>{ try{ if(sessionActive && !paused){ pauseStart('pagehide'); strictModalPending = true; } state.lastSeen = Date.now(); save(); }catch(_){}});

/* --- beforeunload guard --- */
let allowUnloadOnce = false;
window.addEventListener('beforeunload', (e)=>{
  if(allowUnloadOnce) return;
  if(sessionActive && !paused){ e.preventDefault(); e.returnValue=''; }
});

/* ------------------ FACTORY RESET ------------------ */
async function wipeAllStorage(){ try{ localStorage.clear(); }catch(_){}
  try{ sessionStorage.clear(); }catch(_){}
  if('caches' in window){ try{ const keys = await caches.keys(); await Promise.all(keys.map(k=>caches.delete(k))); }catch(_){ } }
  if('indexedDB' in window){
    try{
      if(indexedDB.databases){
        const dbs = await indexedDB.databases();
        await Promise.all((dbs||[]).map(db=> db && db.name ? new Promise(res=>{ const rq = indexedDB.deleteDatabase(db.name); rq.onsuccess=rq.onerror=rq.onblocked=()=>res(); }) : Promise.resolve()));
      }
    }catch(_){}
  }
}
function forceStartScreen(){
  document.querySelectorAll('.screen').forEach(el=> el.style.display='none');
  const input = byId('userNameInput');
  byId('startScreen').style.display='block';
  if(input){ input.value=''; input.focus(); }
}
function resetInMemoryStateToDefaults(){
  state = { userName:null, levelIndex:1, levelTrials:0, levelCorrect:0, sessions:[], trials:[], startDate:null, lockoutUntil:null, capResetAt:null, testFailStreak:0, suggestShownSet:null, lastSeen:null, flappyHighScore:0, thisWeekIdx:0, thisWeekMs:0, levelFailCounts:{}, specialRanForLevel:null };
  save();
}
function doFactoryReset(){
  (async ()=>{
    try{
      if(!confirm('Reset EVERYTHING to factory settings? This erases your progress, timers, and settings.')) return;
      stopAllTimers(); sessionActive=false; paused=false;
      await closeAudio(); await wipeAllStorage(); resetInMemoryStateToDefaults(); forceStartScreen();
      allowUnloadOnce = true; setTimeout(()=>{ try{ location.reload(); }catch(_){ } }, 0);
    }catch(e){ report(e); alert('Reset failed: '+e.message); }
  })();
}

/* ------------------ SANITY GUARDS & DEBUG ------------------ */
// F) SANITY GUARDS (dev-only console asserts ok)
function validateOOBState() {
  console.assert(state.oobStats.adaptiveRate >= 0.05 && state.oobStats.adaptiveRate <= 0.35, 'OOB rate clamp failed');
  if (isOOBTrial) console.assert(currentTrialJitter?.jitter === 0, 'OOB must be 0¬¢');
  if (currentNote) {
    const octave = parseInt(currentNote.slice(-1));
    console.assert([3,4,5].includes(octave), 'Octave outside 3‚Äì5');
  }
}

// Tiny helper:
window.getOOBDebug = () => {
  const last60 = (state.trials||[]).filter(t=>!t.oob).slice(-60);
  const acc = last60.length ? last60.reduce((a,t)=>a+(t.correct?1:0),0)/last60.length : null;
  return { rate: state.oobStats.adaptiveRate, maxInRow: state.oobStats.maxInRow, last60InBoundsAcc: acc };
};

/* ------------------ OFFLINE SIMULATOR ------------------ */

// Seeded RNG (mulberry32) for reproducible simulations
function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// Simulation constants
const SIM_TRIALS_PER_BLOCK = 20;
const SIM_DAILY_BLOCKS = 5;

// Global simulation state
let SIMULATING = false;
let simRNG = null;

// Learner model state
let learnerSkills = {}; // per-pitch class skills [0..1]
let simConfusionMatrix = {}; // 12x12 confusion tracking

// Initialize learner skills
function initializeLearnerSkills() {
  learnerSkills = {};
  PC.forEach(pc => {
    learnerSkills[pc] = 0.55; // Initial skill level
  });
}

// Initialize simulation confusion matrix
function initializeSimConfusionMatrix() {
  simConfusionMatrix = {};
  PC.forEach(truePc => {
    simConfusionMatrix[truePc] = {};
    PC.forEach(guessPc => {
      simConfusionMatrix[truePc][guessPc] = 0;
    });
  });
}

// Learner model response
function simulateLearnerResponse(truePc, isOOB, jitterInfo) {
  if (isOOB) {
    // OOB trials are always incorrect, no skill update
    return { correct: false, guess: 'OOB' };
  }
  
  // Calculate base probability of correct response
  let base = learnerSkills[truePc] || 0.55;
  
  // Apply penalties/bonuses based on jitter
  if (jitterInfo.isProbe) {
    base -= 0.18; // Probe penalty (¬±25-40¬¢)
  } else if (jitterInfo.jitter !== 0) {
    const penalty = Math.min(Math.abs(jitterInfo.jitter) / 40, 0.12);
    base -= penalty; // Jitter penalty up to -0.12
  } else {
    base += 0.03; // Anchor bonus (0¬¢)
  }
  
  // Clamp probability
  base = Math.max(0.05, Math.min(0.98, base));
  
  // Determine if correct
  const correct = simRNG() < base;
  
  let guess = truePc;
  if (!correct) {
    // Choose incorrect guess using confusion distribution
    const confusionRow = simConfusionMatrix[truePc];
    const neighbors = getNeighboringSemitones(truePc);
    
    if (simRNG() < 0.5) {
      // 50% chance: prefer nearest semitones
      guess = neighbors[Math.floor(simRNG() * neighbors.length)];
    } else {
      // 50% chance: sample from confusion matrix
      const weights = PC.map(pc => (confusionRow[pc] || 0) + 0.01); // epsilon
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      const rand = simRNG() * totalWeight;
      let cumulative = 0;
      for (let i = 0; i < PC.length; i++) {
        cumulative += weights[i];
        if (rand <= cumulative) {
          guess = PC[i];
          break;
        }
      }
    }
  }
  
  return { correct, guess };
}

// Get neighboring semitones for confusion
function getNeighboringSemitones(pc) {
  const idx = PC.indexOf(pc);
  const prev = PC[(idx + 11) % 12];
  const next = PC[(idx + 1) % 12];
  return [prev, next];
}

// Update learner skills after trial
function updateLearnerSkills(truePc, correct, guess) {
  const skill = learnerSkills[truePc];
  
  if (correct) {
    // Increase skill, with diminishing returns
    const increment = 0.01 * (1 - skill);
    learnerSkills[truePc] = Math.min(0.97, skill + increment);
  } else {
    // Decrease skill, with bonus penalty for nearby confusions
    let decrement = 0.005;
    const neighbors = getNeighboringSemitones(truePc);
    if (neighbors.includes(guess)) {
      decrement += 0.005; // Extra penalty for ¬±1 semitone errors
    }
    learnerSkills[truePc] = Math.max(0.40, skill - decrement);
  }
}

// Update confusion matrix
function updateSimConfusionMatrix(truePc, guess) {
  if (!simConfusionMatrix[truePc]) simConfusionMatrix[truePc] = {};
  simConfusionMatrix[truePc][guess] = (simConfusionMatrix[truePc][guess] || 0) + 1;
}

// Simulate cold/warm recall
function simulateRecall(type) {
  const learnedPcs = Object.keys(learnerSkills).filter(pc => learnerSkills[pc] > 0.55);
  const testPcs = learnedPcs.length >= 3 ? 
    shuffleArray(learnedPcs).slice(0, 3) : 
    learnedPcs;
  
  return testPcs.map(pc => {
    const skill = learnerSkills[pc];
    const meanError = (1 - skill) * 35; // Cents error mean
    const sdError = 12; // Standard deviation
    
    // Generate normal distribution error, clamped to ¬±60¬¢
    let error = normalRandom() * sdError + meanError;
    error = Math.max(-60, Math.min(60, error));
    
    return { pc, cents: Math.round(error * 10) / 10 };
  });
}

// Box-Muller normal distribution
function normalRandom() {
  const u1 = simRNG();
  const u2 = simRNG();
  return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
}

// Fisher-Yates shuffle using seeded RNG
function shuffleArray(array) {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(simRNG() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Override Math.random during simulation
function withSimulatedRandom(fn) {
  if (!SIMULATING) return fn();
  
  const originalRandom = Math.random;
  Math.random = simRNG;
  try {
    return fn();
  } finally {
    Math.random = originalRandom;
  }
}

// Helper functions that may not exist - provide fallbacks
function selectInBoundsNote(usable) {
  if (typeof window.selectInBoundsNote === 'function') {
    return window.selectInBoundsNote(usable);
  }
  // Fallback: random selection from usable set
  return usable[Math.floor(simRNG() * usable.length)];
}

function selectOctaveForNote(pc) {
  if (typeof window.selectOctaveForNote === 'function') {
    return window.selectOctaveForNote(pc);
  }
  // Fallback: weighted random from [3,4,5] with bias toward 4
  const weights = [0.15, 0.7, 0.15]; // Favor octave 4
  const rand = simRNG();
  let cumulative = 0;
  for (let i = 0; i < weights.length; i++) {
    cumulative += weights[i];
    if (rand <= cumulative) {
      return 3 + i;
    }
  }
  return 4; // Fallback
}

function initializeJitterLevel(pc) {
  if (typeof window.initializeJitterLevel === 'function') {
    return window.initializeJitterLevel(pc);
  }
  // Fallback: initialize to JL1
  if (!state.jitterLevels) state.jitterLevels = {};
  if (!(pc in state.jitterLevels)) {
    state.jitterLevels[pc] = 1; // Default to JL1
  }
}

function shouldUseProbe(pc) {
  if (typeof window.shouldUseProbe === 'function') {
    return window.shouldUseProbe(pc);
  }
  // Fallback: 5% chance of probe
  return simRNG() < 0.05;
}

function calculateJitter(pc, isProbe) {
  if (typeof window.calculateJitter === 'function') {
    return window.calculateJitter(pc, isProbe);
  }
  // Fallback jitter calculation
  if (isProbe) {
    // Probe: ¬±25-40¬¢ range
    const sign = simRNG() < 0.5 ? -1 : 1;
    return sign * (25 + simRNG() * 15); // 25-40 cents
  } else {
    // Regular jitter: ¬±5-15¬¢ based on level
    const level = state.jitterLevels[pc] || 1;
    const maxJitter = Math.min(15, 5 + level * 3);
    const sign = simRNG() < 0.5 ? -1 : 1;
    return sign * simRNG() * maxJitter;
  }
}

// Simulate a single trial
function simulateTrial(set, blockNum, trialNum) {
  return withSimulatedRandom(() => {
    // Generate trial using existing logic
    const usable = trainedSet(set);
    const wasOOB = shouldGenerateOOB(set);
    
    let truePc, currentNote, jitterInfo;
    
    if (wasOOB) {
      truePc = selectOOBNote(set);
      const octave = selectOctaveForNote(truePc);
      currentNote = `${truePc}${octave}`;
      jitterInfo = { jitter: 0, isProbe: false, level: null };
    } else {
      truePc = selectInBoundsNote(usable);
      const octave = selectOctaveForNote(truePc);
      currentNote = `${truePc}${octave}`;
      
      // Initialize jitter level if needed
      initializeJitterLevel(truePc);
      
      const isProbe = shouldUseProbe(truePc);
      const jitter = calculateJitter(truePc, isProbe);
      
      jitterInfo = {
        jitter: jitter,
        isProbe: isProbe,
        level: state.jitterLevels[truePc]
      };
    }
    
    // Get learner response
    const response = simulateLearnerResponse(truePc, wasOOB, jitterInfo);
    
    // Record trial data
    const trialData = {
      day: Math.floor((Date.now() - simStartTime) / (24 * 60 * 60 * 1000)) + 1,
      block: blockNum,
      t: trialNum,
      pc: truePc,
      octave: parseInt(currentNote.slice(-1)),
      isOOB: wasOOB,
      detuneCents: Math.round(jitterInfo.jitter * 10) / 10,
      probe: jitterInfo.isProbe,
      anchor: jitterInfo.jitter === 0 && !wasOOB,
      ok: response.correct
    };
    
    // Update learner state for in-bounds trials
    if (!wasOOB) {
      updateLearnerSkills(truePc, response.correct, response.guess);
      if (!response.correct && response.guess !== truePc) {
        updateSimConfusionMatrix(truePc, response.guess);
      }
    }
    
    // Record in app state (simulate recordTrial call)
    recordTrial(response.guess, response.correct, false, wasOOB);
    
    return trialData;
  });
}

// Track simulation start time
let simStartTime = 0;

// Main simulation function
window.runSimWeek = function(opts = {}) {
  const days = opts.days ?? 7;
  const seed = opts.seed ?? 1234;
  const dailyBlocks = opts.dailyBlocks ?? SIM_DAILY_BLOCKS;
  const trialsPerBlock = opts.trialsPerBlock ?? SIM_TRIALS_PER_BLOCK;
  
  // Initialize simulation
  SIMULATING = true;
  simRNG = mulberry32(seed);
  simStartTime = Date.now();
  
  // Initialize learner model
  initializeLearnerSkills();
  initializeSimConfusionMatrix();
  
  // Data collection arrays
  const perDayData = [];
  const rawTrials = [];
  const oobSeries = [];
  
  // Save original state
  const originalState = JSON.parse(JSON.stringify(state));
  
  try {
    // Run simulation for each day
    for (let day = 1; day <= days; day++) {
      // Reset daily counters but keep cross-day state
      const dayStartMinutes = state.minutesToday || 0;
      
      let dayOobTrials = 0;
      let dayOobCorrect = 0;
      let dayOobMaxStreak = 0;
      let dayCurrentStreak = 0;
      let dayAnchors = 0;
      let dayProbes = 0;
      let dayJittered = 0;
      let dayTotalTrials = 0;
      
      const octaveCounts = {
        inBounds: { 3: 0, 4: 0, 5: 0 },
        oob: { 3: 0, 4: 0, 5: 0 }
      };
      
      // Simulate cold recall at start of day
      const coldRecall = simulateRecall('cold');
      
      // Run daily blocks
      for (let block = 1; block <= dailyBlocks; block++) {
        for (let trial = 1; trial <= trialsPerBlock; trial++) {
          const set = setFromIndex(state.levelIndex);
          const trialData = simulateTrial(set, block, trial);
          
          // Collect statistics
          dayTotalTrials++;
          
          if (trialData.isOOB) {
            dayOobTrials++;
            if (trialData.ok) dayOobCorrect++;
            dayCurrentStreak = trialData.ok ? 0 : dayCurrentStreak + 1;
            dayOobMaxStreak = Math.max(dayOobMaxStreak, dayCurrentStreak);
            octaveCounts.oob[trialData.octave]++;
          } else {
            dayCurrentStreak = 0;
            octaveCounts.inBounds[trialData.octave]++;
            
            if (trialData.anchor) dayAnchors++;
            else if (trialData.probe) dayProbes++;
            else if (trialData.detuneCents !== 0) dayJittered++;
          }
          
          // Store recent trials (keep last 1000)
          rawTrials.push(trialData);
          if (rawTrials.length > 1000) {
            rawTrials.shift();
          }
        }
        
        // Trigger block boundary logic every 3 blocks
        if (block % 3 === 0) {
          // Force OOB adaptation logic to run
          const blockIndex = (day - 1) * dailyBlocks + block;
          const currentOobRate = state.oobStats?.adaptiveRate ?? 0.18;
          oobSeries.push({
            block: blockIndex,
            targetPct: Math.round(currentOobRate * 1000) / 10
          });
        }
      }
      
      // Simulate warm recall at end of day
      const warmRecall = simulateRecall('warm');
      
      // Calculate day statistics
      const oobTargetPct = state.oobStats?.adaptiveRate ? 
        Math.round(state.oobStats.adaptiveRate * 1000) / 10 : 18.0;
      const oobObservedPct = dayOobTrials > 0 ? 
        Math.round((dayOobTrials / dayTotalTrials) * 1000) / 10 : 0;
      
      const last60InBounds = state.trials
        .filter(t => !t.oob)
        .slice(-60);
      const last60Acc = last60InBounds.length > 0 ? 
        Math.round((last60InBounds.filter(t => t.correct).length / last60InBounds.length) * 1000) / 10 : 0;
      
      // Store per-day summary
      perDayData.push({
        day: day,
        blocksDone: dailyBlocks,
        oobTargetPct: oobTargetPct,
        oobObservedPct: oobObservedPct,
        oobMaxStreak: dayOobMaxStreak,
        anchorsPct: dayTotalTrials > 0 ? Math.round((dayAnchors / dayTotalTrials) * 1000) / 10 : 0,
        probesPct: dayTotalTrials > 0 ? Math.round((dayProbes / dayTotalTrials) * 1000) / 10 : 0,
        jitterPct: dayTotalTrials > 0 ? Math.round((dayJittered / dayTotalTrials) * 1000) / 10 : 0,
        octaveCounts: octaveCounts,
        last60InBoundsAcc: last60Acc,
        cold: coldRecall,
        warm: warmRecall
      });
    }
    
    // Generate final summary statistics
    const perPitchStats = {};
    PC.forEach(pc => {
      const pcTrials = rawTrials.filter(t => t.pc === pc && !t.isOOB);
      if (pcTrials.length > 0) {
        const anchors = pcTrials.filter(t => t.anchor).length;
        const probes = pcTrials.filter(t => t.probe).length;
        const jittered = pcTrials.filter(t => t.detuneCents !== 0 && !t.probe && !t.anchor).length;
        const totalCents = pcTrials.reduce((sum, t) => sum + Math.abs(t.detuneCents), 0);
        
        perPitchStats[pc] = {
          tones: pcTrials.length,
          anchorsPercent: Math.round((anchors / pcTrials.length) * 1000) / 10,
          probesPercent: Math.round((probes / pcTrials.length) * 1000) / 10,
          jitterPercent: Math.round((jittered / pcTrials.length) * 1000) / 10,
          meanAbsCents: Math.round((totalCents / pcTrials.length) * 10) / 10
        };
      }
    });
    
    // Build final result
    const result = {
      days: days,
      dailyBlocks: dailyBlocks,
      trialsPerBlock: trialsPerBlock,
      seed: seed,
      perDay: perDayData,
      confusionMatrix: simConfusionMatrix,
      perPitch: perPitchStats,
      oobSeries: oobSeries,
      raw: {
        trialsTail: rawTrials
      }
    };
    
    return result;
    
  } finally {
    // Restore original state
    Object.assign(state, originalState);
    SIMULATING = false;
    simRNG = null;
  }
};

// Export simulation results to JSON file
window.exportSimWeek = async function(opts) {
  const results = await window.runSimWeek(opts);
  const dateStr = new Date().toISOString().slice(0, 10);
  const filename = `sim_week_${dateStr}.json`;
  
  const blob = new Blob([JSON.stringify(results, null, 2)], { 
    type: 'application/json' 
  });
  
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  
  setTimeout(() => URL.revokeObjectURL(a.href), 0);
  
  return results;
};

/* ------------------ INIT ------------------ */
window.addEventListener('load', wireOnce);
window.addEventListener('resize', ()=>{ try{ drawChart(); }catch(_){ }});
</script>
</body>
</html>
